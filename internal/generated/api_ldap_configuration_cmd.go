// Copyright 2023 MongoDB Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package generated

import (
	"context"
	"os"
	"time"

	"github.com/spf13/cobra"
	"go.mongodb.org/atlas-sdk/v20230201008/admin"
	"github.com/mongodb/mongodb-atlas-cli/internal/cli"
)

type deleteLDAPConfigurationOpts struct {
	cli.GlobalOpts
	cli.OutputOpts
	client *admin.APIClient
	groupId string
}

func (opts *deleteLDAPConfigurationOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *deleteLDAPConfigurationOpts) Run(ctx context.Context) error {
	params := &admin.DeleteLDAPConfigurationApiParams{
		GroupId: opts.groupId,
	}
	_, err := opts.client.LDAPConfigurationApi.DeleteLDAPConfigurationWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return opts.Print(nil)
}

func deleteLDAPConfigurationBuilder() *cobra.Command {
	const template = "<<some template>>"

	opts := deleteLDAPConfigurationOpts{}
	cmd := &cobra.Command{
		Use: "deleteLDAPConfiguration",
		Short: "Remove the Current LDAP User to DN Mapping",
		Annotations: map[string]string{
			"output":      template,
		},
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
				opts.InitOutput(cmd.OutOrStdout(), template),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)


	_ = cmd.MarkFlagRequired("groupId")
	return cmd
}
type getLDAPConfigurationOpts struct {
	cli.GlobalOpts
	cli.OutputOpts
	client *admin.APIClient
	groupId string
}

func (opts *getLDAPConfigurationOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *getLDAPConfigurationOpts) Run(ctx context.Context) error {
	params := &admin.GetLDAPConfigurationApiParams{
		GroupId: opts.groupId,
	}
	resp, _, err := opts.client.LDAPConfigurationApi.GetLDAPConfigurationWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return opts.Print(resp)
}

func getLDAPConfigurationBuilder() *cobra.Command {
	const template = "<<some template>>"

	opts := getLDAPConfigurationOpts{}
	cmd := &cobra.Command{
		Use: "getLDAPConfiguration",
		Short: "Return the Current LDAP or X.509 Configuration",
		Annotations: map[string]string{
			"output":      template,
		},
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
				opts.InitOutput(cmd.OutOrStdout(), template),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)


	_ = cmd.MarkFlagRequired("groupId")
	return cmd
}
type getLDAPConfigurationStatusOpts struct {
	cli.GlobalOpts
	cli.OutputOpts
	client *admin.APIClient
	groupId string
	requestId string
}

func (opts *getLDAPConfigurationStatusOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *getLDAPConfigurationStatusOpts) Run(ctx context.Context) error {
	params := &admin.GetLDAPConfigurationStatusApiParams{
		GroupId: opts.groupId,
		RequestId: opts.requestId,
	}
	resp, _, err := opts.client.LDAPConfigurationApi.GetLDAPConfigurationStatusWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return opts.Print(resp)
}

func getLDAPConfigurationStatusBuilder() *cobra.Command {
	const template = "<<some template>>"

	opts := getLDAPConfigurationStatusOpts{}
	cmd := &cobra.Command{
		Use: "getLDAPConfigurationStatus",
		Short: "Return the Status of One Verify LDAP Configuration Request",
		Annotations: map[string]string{
			"output":      template,
		},
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
				opts.InitOutput(cmd.OutOrStdout(), template),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)
	cmd.Flags().StringVar(&opts.requestId, "requestId", "", `Unique string that identifies the request to verify an &lt;abbr title&#x3D;&quot;Lightweight Directory Access Protocol&quot;&gt;LDAP&lt;/abbr&gt; configuration.`)


	_ = cmd.MarkFlagRequired("groupId")
	_ = cmd.MarkFlagRequired("requestId")
	return cmd
}
type saveLDAPConfigurationOpts struct {
	cli.GlobalOpts
	cli.OutputOpts
	client *admin.APIClient
	groupId string
	
}

func (opts *saveLDAPConfigurationOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *saveLDAPConfigurationOpts) Run(ctx context.Context) error {
	params := &admin.SaveLDAPConfigurationApiParams{
		GroupId: opts.groupId,
		
	}
	resp, _, err := opts.client.LDAPConfigurationApi.SaveLDAPConfigurationWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return opts.Print(resp)
}

func saveLDAPConfigurationBuilder() *cobra.Command {
	const template = "<<some template>>"

	opts := saveLDAPConfigurationOpts{}
	cmd := &cobra.Command{
		Use: "saveLDAPConfiguration",
		Short: "Edit the LDAP or X.509 Configuration",
		Annotations: map[string]string{
			"output":      template,
		},
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
				opts.InitOutput(cmd.OutOrStdout(), template),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)
	

	cmd.Flags().CustomerX509Var(&opts.customerX509, "customerX509", , ``)

	cmd.Flags().NDSLDAPVar(&opts.ldap, "ldap", , ``)

	cmd.Flags().ArraySliceVar(&opts.links, "links", nil, `List of one or more Uniform Resource Locators (URLs) that point to API sub-resources, related API resources, or both. RFC 5988 outlines these relationships.`)


	_ = cmd.MarkFlagRequired("groupId")
	return cmd
}
type verifyLDAPConfigurationOpts struct {
	cli.GlobalOpts
	cli.OutputOpts
	client *admin.APIClient
	groupId string
	
}

func (opts *verifyLDAPConfigurationOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *verifyLDAPConfigurationOpts) Run(ctx context.Context) error {
	params := &admin.VerifyLDAPConfigurationApiParams{
		GroupId: opts.groupId,
		
	}
	resp, _, err := opts.client.LDAPConfigurationApi.VerifyLDAPConfigurationWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return opts.Print(resp)
}

func verifyLDAPConfigurationBuilder() *cobra.Command {
	const template = "<<some template>>"

	opts := verifyLDAPConfigurationOpts{}
	cmd := &cobra.Command{
		Use: "verifyLDAPConfiguration",
		Short: "Verify the LDAP Configuration in One Project",
		Annotations: map[string]string{
			"output":      template,
		},
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
				opts.InitOutput(cmd.OutOrStdout(), template),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)
	

	cmd.Flags().StringVar(&opts.authzQueryTemplate, "authzQueryTemplate", "&quot;{USER}?memberOf?base&quot;", `Lightweight Directory Access Protocol (LDAP) query template that MongoDB Cloud applies to create an LDAP query to return the LDAP groups associated with the authenticated MongoDB user. MongoDB Cloud uses this parameter only for user authorization.

Use the &#x60;{USER}&#x60; placeholder in the Uniform Resource Locator (URL) to substitute the authenticated username. The query relates to the host specified with the hostname. Format this query per [RFC 4515](https://tools.ietf.org/search/rfc4515) and [RFC 4516](https://datatracker.ietf.org/doc/html/rfc4516).`)

	cmd.Flags().StringVar(&opts.bindPassword, "bindPassword", "", `Password that MongoDB Cloud uses to authenticate the **bindUsername**.`)

	cmd.Flags().StringVar(&opts.bindUsername, "bindUsername", "", `Full Distinguished Name (DN) of the Lightweight Directory Access Protocol (LDAP) user that MongoDB Cloud uses to connect to the LDAP host. LDAP distinguished names must be formatted according to RFC 2253.`)

	cmd.Flags().StringVar(&opts.caCertificate, "caCertificate", "", `Certificate Authority (CA) certificate that MongoDB Cloud uses to verify the identity of the Lightweight Directory Access Protocol (LDAP) host. MongoDB Cloud allows self-signed certificates. To delete an assigned value, pass an empty string: &#x60;&quot;caCertificate&quot;: &quot;&quot;&#x60;.`)

	cmd.Flags().StringVar(&opts.hostname, "hostname", "", `Human-readable label that identifies the hostname or Internet Protocol (IP) address of the Lightweight Directory Access Protocol (LDAP) host. This host must have access to the internet or have a Virtual Private Cloud (VPC) peering connection to your cluster.`)

	cmd.Flags().ArraySliceVar(&opts.links, "links", nil, `List of one or more Uniform Resource Locators (URLs) that point to API sub-resources, related API resources, or both. RFC 5988 outlines these relationships.`)

	cmd.Flags().IntVar(&opts.port, "port", 636, `IANA port to which the Lightweight Directory Access Protocol (LDAP) host listens for client connections.`)


	_ = cmd.MarkFlagRequired("groupId")
	return cmd
}

func lDAPConfigurationBuilder() *cobra.Command {
	cmd := &cobra.Command{
		Use:     "lDAPConfiguration",
		Short:   `Returns, edits, verifies, and removes LDAP configurations. An LDAP configuration defines settings for MongoDB Cloud to connect to your LDAP server over TLS for user authentication and authorization. Your LDAP server must be visible to the internet or connected to your MongoDB Cloud cluster with VPC Peering. Also, your LDAP server must use TLS. You must have the MongoDB Cloud admin user privilege to use these endpoints. Also, to configure user authentication and authorization with LDAPS, your cluster must run MongoDB 3.6 or higher. Groups for which you have configured LDAPS can&#39;t create a cluster using a version of MongoDB 3.6 or lower.`,
	}
	cmd.AddCommand(
		deleteLDAPConfigurationBuilder(),
		getLDAPConfigurationBuilder(),
		getLDAPConfigurationStatusBuilder(),
		saveLDAPConfigurationBuilder(),
		verifyLDAPConfigurationBuilder(),
	)
	return cmd
}

