// Copyright 2023 MongoDB Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package generated

import (
	"context"

	"github.com/mongodb/mongodb-atlas-cli/internal/cli"
	"github.com/spf13/cobra"
	"go.mongodb.org/atlas-sdk/v20230201008/admin"
)

type createProjectOpts struct {
	cli.GlobalOpts
	cli.OutputOpts
	client *admin.APIClient

	projectOwnerId string
}

func (opts *createProjectOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *createProjectOpts) Run(ctx context.Context) error {
	params := &admin.CreateProjectApiParams{

		ProjectOwnerId: &opts.projectOwnerId,
	}
	resp, _, err := opts.client.ProjectsApi.CreateProjectWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return opts.Print(resp)
}

func createProjectBuilder() *cobra.Command {
	const template = "<<some template>>"

	opts := createProjectOpts{}
	cmd := &cobra.Command{
		Use:   "createProject",
		Short: "Create One Project",
		Annotations: map[string]string{
			"output": template,
		},
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
				opts.InitOutput(cmd.OutOrStdout(), template),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context())
		},
	}

	cmd.Flags().StringVar(&opts.projectOwnerId, "projectOwnerId", "", `Unique 24-hexadecimal digit string that identifies the MongoDB Cloud user to whom to grant the Project Owner role on the specified project. If you set this parameter, it overrides the default value of the oldest Organization Owner. `)

	cmd.Flags().Int64Var(&opts.clusterCount, "clusterCount", 00, `Quantity of MongoDB Cloud clusters deployed in this project.`)

	cmd.Flags().StringVar(&opts.created, "created", "", `Date and time when MongoDB Cloud created this project. This parameter expresses its value in the ISO 8601 timestamp format in UTC.`)

	cmd.Flags().StringVar(&opts.id, "id", "", `Unique 24-hexadecimal digit string that identifies the MongoDB Cloud project.`)

	cmd.Flags().ArraySliceVar(&opts.links, "links", nil, `List of one or more Uniform Resource Locators (URLs) that point to API sub-resources, related API resources, or both. RFC 5988 outlines these relationships.`)

	cmd.Flags().StringVar(&opts.name, "name", "", `Human-readable label that identifies the project included in the MongoDB Cloud organization.`)

	cmd.Flags().StringVar(&opts.orgId, "orgId", "", `Unique 24-hexadecimal digit string that identifies the MongoDB Cloud organization to which the project belongs.`)

	cmd.Flags().StringVar(&opts.regionUsageRestrictions, "regionUsageRestrictions", "&quot;NONE&quot;", `Region usage restrictions that designate the project&#39;s AWS region.`)

	cmd.Flags().BoolVar(&opts.withDefaultAlertsSettings, "withDefaultAlertsSettings", false, `Flag that indicates whether to create the project with default alert settings.`)

	return cmd
}

type createProjectInvitationOpts struct {
	cli.GlobalOpts
	cli.OutputOpts
	client  *admin.APIClient
	groupId string
}

func (opts *createProjectInvitationOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *createProjectInvitationOpts) Run(ctx context.Context) error {
	params := &admin.CreateProjectInvitationApiParams{
		GroupId: opts.groupId,
	}
	resp, _, err := opts.client.ProjectsApi.CreateProjectInvitationWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return opts.Print(resp)
}

func createProjectInvitationBuilder() *cobra.Command {
	const template = "<<some template>>"

	opts := createProjectInvitationOpts{}
	cmd := &cobra.Command{
		Use:   "createProjectInvitation",
		Short: "Invite One MongoDB Cloud User to Join One Project",
		Annotations: map[string]string{
			"output": template,
		},
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
				opts.InitOutput(cmd.OutOrStdout(), template),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)

	cmd.Flags().SetSliceVar(&opts.roles, "roles", nil, `One or more organization or project level roles to assign to the MongoDB Cloud user.`)

	cmd.Flags().StringVar(&opts.username, "username", "", `Email address of the MongoDB Cloud user invited to the specified project.`)

	_ = cmd.MarkFlagRequired("groupId")
	return cmd
}

type deleteProjectOpts struct {
	cli.GlobalOpts
	cli.OutputOpts
	client  *admin.APIClient
	groupId string
}

func (opts *deleteProjectOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *deleteProjectOpts) Run(ctx context.Context) error {
	params := &admin.DeleteProjectApiParams{
		GroupId: opts.groupId,
	}
	resp, _, err := opts.client.ProjectsApi.DeleteProjectWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return opts.Print(resp)
}

func deleteProjectBuilder() *cobra.Command {
	const template = "<<some template>>"

	opts := deleteProjectOpts{}
	cmd := &cobra.Command{
		Use:   "deleteProject",
		Short: "Remove One Project",
		Annotations: map[string]string{
			"output": template,
		},
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
				opts.InitOutput(cmd.OutOrStdout(), template),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)

	_ = cmd.MarkFlagRequired("groupId")
	return cmd
}

type deleteProjectInvitationOpts struct {
	cli.GlobalOpts
	cli.OutputOpts
	client       *admin.APIClient
	groupId      string
	invitationId string
}

func (opts *deleteProjectInvitationOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *deleteProjectInvitationOpts) Run(ctx context.Context) error {
	params := &admin.DeleteProjectInvitationApiParams{
		GroupId:      opts.groupId,
		InvitationId: opts.invitationId,
	}
	resp, _, err := opts.client.ProjectsApi.DeleteProjectInvitationWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return opts.Print(resp)
}

func deleteProjectInvitationBuilder() *cobra.Command {
	const template = "<<some template>>"

	opts := deleteProjectInvitationOpts{}
	cmd := &cobra.Command{
		Use:   "deleteProjectInvitation",
		Short: "Cancel One Project Invitation",
		Annotations: map[string]string{
			"output": template,
		},
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
				opts.InitOutput(cmd.OutOrStdout(), template),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)
	cmd.Flags().StringVar(&opts.invitationId, "invitationId", "", `Unique 24-hexadecimal digit string that identifies the invitation.`)

	_ = cmd.MarkFlagRequired("groupId")
	_ = cmd.MarkFlagRequired("invitationId")
	return cmd
}

type deleteProjectLimitOpts struct {
	cli.GlobalOpts
	cli.OutputOpts
	client    *admin.APIClient
	limitName string
	groupId   string
}

func (opts *deleteProjectLimitOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *deleteProjectLimitOpts) Run(ctx context.Context) error {
	params := &admin.DeleteProjectLimitApiParams{
		LimitName: opts.limitName,
		GroupId:   opts.groupId,
	}
	resp, _, err := opts.client.ProjectsApi.DeleteProjectLimitWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return opts.Print(resp)
}

func deleteProjectLimitBuilder() *cobra.Command {
	const template = "<<some template>>"

	opts := deleteProjectLimitOpts{}
	cmd := &cobra.Command{
		Use:   "deleteProjectLimit",
		Short: "Remove One Project Limit",
		Annotations: map[string]string{
			"output": template,
		},
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
				opts.InitOutput(cmd.OutOrStdout(), template),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context())
		},
	}
	cmd.Flags().StringVar(&opts.limitName, "limitName", "", `Human-readable label that identifies this project limit.

| Limit Name | Description | Default | API Override Limit |
| --- | --- | --- | --- |
| atlas.project.deployment.clusters | Limit on the number of clusters in this project | 25 | 90 |
| atlas.project.deployment.nodesPerPrivateLinkRegion | Limit on the number of nodes per Private Link region in this project | 50 | 90 |
| atlas.project.security.databaseAccess.customRoles | Limit on the number of custom roles in this project | 100 | 1400 |
| atlas.project.security.databaseAccess.users | Limit on the number of database users in this project | 100 | 900 |
| atlas.project.security.networkAccess.crossRegionEntries | Limit on the number of cross-region network access entries in this project | 40 | 220 |
| atlas.project.security.networkAccess.entries | Limit on the number of network access entries in this project | 200 | 20 |
| dataFederation.bytesProcessed.query | Limit on the number of bytes processed during a single Data Federation query | N/A | N/A |
| dataFederation.bytesProcessed.daily | Limit on the number of bytes processed across all Data Federation tenants for the current day | N/A | N/A |
| dataFederation.bytesProcessed.weekly | Limit on the number of bytes processed across all Data Federation tenants for the current week | N/A | N/A |
| dataFederation.bytesProcessed.monthly | Limit on the number of bytes processed across all Data Federation tenants for the current month | N/A | N/A |
`)
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)

	_ = cmd.MarkFlagRequired("limitName")
	_ = cmd.MarkFlagRequired("groupId")
	return cmd
}

type getProjectOpts struct {
	cli.GlobalOpts
	cli.OutputOpts
	client  *admin.APIClient
	groupId string
}

func (opts *getProjectOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *getProjectOpts) Run(ctx context.Context) error {
	params := &admin.GetProjectApiParams{
		GroupId: opts.groupId,
	}
	resp, _, err := opts.client.ProjectsApi.GetProjectWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return opts.Print(resp)
}

func getProjectBuilder() *cobra.Command {
	const template = "<<some template>>"

	opts := getProjectOpts{}
	cmd := &cobra.Command{
		Use:   "getProject",
		Short: "Return One Project",
		Annotations: map[string]string{
			"output": template,
		},
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
				opts.InitOutput(cmd.OutOrStdout(), template),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)

	_ = cmd.MarkFlagRequired("groupId")
	return cmd
}

type getProjectByNameOpts struct {
	cli.GlobalOpts
	cli.OutputOpts
	client    *admin.APIClient
	groupName string
}

func (opts *getProjectByNameOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *getProjectByNameOpts) Run(ctx context.Context) error {
	params := &admin.GetProjectByNameApiParams{
		GroupName: opts.groupName,
	}
	resp, _, err := opts.client.ProjectsApi.GetProjectByNameWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return opts.Print(resp)
}

func getProjectByNameBuilder() *cobra.Command {
	const template = "<<some template>>"

	opts := getProjectByNameOpts{}
	cmd := &cobra.Command{
		Use:   "getProjectByName",
		Short: "Return One Project using Its Name",
		Annotations: map[string]string{
			"output": template,
		},
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
				opts.InitOutput(cmd.OutOrStdout(), template),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context())
		},
	}
	cmd.Flags().StringVar(&opts.groupName, "groupName", "", `Human-readable label that identifies this project.`)

	_ = cmd.MarkFlagRequired("groupName")
	return cmd
}

type getProjectInvitationOpts struct {
	cli.GlobalOpts
	cli.OutputOpts
	client       *admin.APIClient
	groupId      string
	invitationId string
}

func (opts *getProjectInvitationOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *getProjectInvitationOpts) Run(ctx context.Context) error {
	params := &admin.GetProjectInvitationApiParams{
		GroupId:      opts.groupId,
		InvitationId: opts.invitationId,
	}
	resp, _, err := opts.client.ProjectsApi.GetProjectInvitationWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return opts.Print(resp)
}

func getProjectInvitationBuilder() *cobra.Command {
	const template = "<<some template>>"

	opts := getProjectInvitationOpts{}
	cmd := &cobra.Command{
		Use:   "getProjectInvitation",
		Short: "Return One Project Invitation",
		Annotations: map[string]string{
			"output": template,
		},
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
				opts.InitOutput(cmd.OutOrStdout(), template),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)
	cmd.Flags().StringVar(&opts.invitationId, "invitationId", "", `Unique 24-hexadecimal digit string that identifies the invitation.`)

	_ = cmd.MarkFlagRequired("groupId")
	_ = cmd.MarkFlagRequired("invitationId")
	return cmd
}

type getProjectLimitOpts struct {
	cli.GlobalOpts
	cli.OutputOpts
	client    *admin.APIClient
	limitName string
	groupId   string
}

func (opts *getProjectLimitOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *getProjectLimitOpts) Run(ctx context.Context) error {
	params := &admin.GetProjectLimitApiParams{
		LimitName: opts.limitName,
		GroupId:   opts.groupId,
	}
	resp, _, err := opts.client.ProjectsApi.GetProjectLimitWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return opts.Print(resp)
}

func getProjectLimitBuilder() *cobra.Command {
	const template = "<<some template>>"

	opts := getProjectLimitOpts{}
	cmd := &cobra.Command{
		Use:   "getProjectLimit",
		Short: "Return One Limit for One Project",
		Annotations: map[string]string{
			"output": template,
		},
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
				opts.InitOutput(cmd.OutOrStdout(), template),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context())
		},
	}
	cmd.Flags().StringVar(&opts.limitName, "limitName", "", `Human-readable label that identifies this project limit.

| Limit Name | Description | Default | API Override Limit |
| --- | --- | --- | --- |
| atlas.project.deployment.clusters | Limit on the number of clusters in this project | 25 | 90 |
| atlas.project.deployment.nodesPerPrivateLinkRegion | Limit on the number of nodes per Private Link region in this project | 50 | 90 |
| atlas.project.security.databaseAccess.customRoles | Limit on the number of custom roles in this project | 100 | 1400 |
| atlas.project.security.databaseAccess.users | Limit on the number of database users in this project | 100 | 900 |
| atlas.project.security.networkAccess.crossRegionEntries | Limit on the number of cross-region network access entries in this project | 40 | 220 |
| atlas.project.security.networkAccess.entries | Limit on the number of network access entries in this project | 200 | 20 |
| dataFederation.bytesProcessed.query | Limit on the number of bytes processed during a single Data Federation query | N/A | N/A |
| dataFederation.bytesProcessed.daily | Limit on the number of bytes processed across all Data Federation tenants for the current day | N/A | N/A |
| dataFederation.bytesProcessed.weekly | Limit on the number of bytes processed across all Data Federation tenants for the current week | N/A | N/A |
| dataFederation.bytesProcessed.monthly | Limit on the number of bytes processed across all Data Federation tenants for the current month | N/A | N/A |
`)
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)

	_ = cmd.MarkFlagRequired("limitName")
	_ = cmd.MarkFlagRequired("groupId")
	return cmd
}

type getProjectSettingsOpts struct {
	cli.GlobalOpts
	cli.OutputOpts
	client  *admin.APIClient
	groupId string
}

func (opts *getProjectSettingsOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *getProjectSettingsOpts) Run(ctx context.Context) error {
	params := &admin.GetProjectSettingsApiParams{
		GroupId: opts.groupId,
	}
	resp, _, err := opts.client.ProjectsApi.GetProjectSettingsWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return opts.Print(resp)
}

func getProjectSettingsBuilder() *cobra.Command {
	const template = "<<some template>>"

	opts := getProjectSettingsOpts{}
	cmd := &cobra.Command{
		Use:   "getProjectSettings",
		Short: "Return One Project Settings",
		Annotations: map[string]string{
			"output": template,
		},
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
				opts.InitOutput(cmd.OutOrStdout(), template),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)

	_ = cmd.MarkFlagRequired("groupId")
	return cmd
}

type listProjectInvitationsOpts struct {
	cli.GlobalOpts
	cli.OutputOpts
	client   *admin.APIClient
	groupId  string
	username string
}

func (opts *listProjectInvitationsOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *listProjectInvitationsOpts) Run(ctx context.Context) error {
	params := &admin.ListProjectInvitationsApiParams{
		GroupId:  opts.groupId,
		Username: &opts.username,
	}
	resp, _, err := opts.client.ProjectsApi.ListProjectInvitationsWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return opts.Print(resp)
}

func listProjectInvitationsBuilder() *cobra.Command {
	const template = "<<some template>>"

	opts := listProjectInvitationsOpts{}
	cmd := &cobra.Command{
		Use:   "listProjectInvitations",
		Short: "Return All Project Invitations",
		Annotations: map[string]string{
			"output": template,
		},
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
				opts.InitOutput(cmd.OutOrStdout(), template),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)
	cmd.Flags().StringVar(&opts.username, "username", "", `Email address of the user account invited to this project.`)

	_ = cmd.MarkFlagRequired("groupId")
	return cmd
}

type listProjectLimitsOpts struct {
	cli.GlobalOpts
	cli.OutputOpts
	client  *admin.APIClient
	groupId string
}

func (opts *listProjectLimitsOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *listProjectLimitsOpts) Run(ctx context.Context) error {
	params := &admin.ListProjectLimitsApiParams{
		GroupId: opts.groupId,
	}
	resp, _, err := opts.client.ProjectsApi.ListProjectLimitsWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return opts.Print(resp)
}

func listProjectLimitsBuilder() *cobra.Command {
	const template = "<<some template>>"

	opts := listProjectLimitsOpts{}
	cmd := &cobra.Command{
		Use:   "listProjectLimits",
		Short: "Return All Limits for One Project",
		Annotations: map[string]string{
			"output": template,
		},
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
				opts.InitOutput(cmd.OutOrStdout(), template),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)

	_ = cmd.MarkFlagRequired("groupId")
	return cmd
}

type listProjectUsersOpts struct {
	cli.GlobalOpts
	cli.OutputOpts
	client          *admin.APIClient
	groupId         string
	includeCount    bool
	itemsPerPage    int
	pageNum         int
	flattenTeams    bool
	includeOrgUsers bool
}

func (opts *listProjectUsersOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *listProjectUsersOpts) Run(ctx context.Context) error {
	params := &admin.ListProjectUsersApiParams{
		GroupId:         opts.groupId,
		IncludeCount:    &opts.includeCount,
		ItemsPerPage:    &opts.itemsPerPage,
		PageNum:         &opts.pageNum,
		FlattenTeams:    &opts.flattenTeams,
		IncludeOrgUsers: &opts.includeOrgUsers,
	}
	resp, _, err := opts.client.ProjectsApi.ListProjectUsersWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return opts.Print(resp)
}

func listProjectUsersBuilder() *cobra.Command {
	const template = "<<some template>>"

	opts := listProjectUsersOpts{}
	cmd := &cobra.Command{
		Use:   "listProjectUsers",
		Short: "Return All Users in One Project",
		Annotations: map[string]string{
			"output": template,
		},
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
				opts.InitOutput(cmd.OutOrStdout(), template),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)
	cmd.Flags().BoolVar(&opts.includeCount, "includeCount", true, `Flag that indicates whether the response returns the total number of items (**totalCount**) in the response.`)
	cmd.Flags().IntVar(&opts.itemsPerPage, "itemsPerPage", 100, `Number of items that the response returns per page.`)
	cmd.Flags().IntVar(&opts.pageNum, "pageNum", 1, `Number of the page that displays the current set of the total objects that the response returns.`)
	cmd.Flags().BoolVar(&opts.flattenTeams, "flattenTeams", false, `Flag that indicates whether the returned list should include users who belong to a team with a role in this project. You might not have assigned the individual users a role in this project. If &#x60;&quot;flattenTeams&quot; : false&#x60;, this resource returns only users with a role in the project.  If &#x60;&quot;flattenTeams&quot; : true&#x60;, this resource returns both users with roles in the project and users who belong to teams with roles in the project.`)
	cmd.Flags().BoolVar(&opts.includeOrgUsers, "includeOrgUsers", false, `Flag that indicates whether the returned list should include users with implicit access to the project, the Organization Owner or Organization Read Only role. You might not have assigned the individual users a role in this project. If &#x60;&quot;includeOrgUsers&quot;: false&#x60;, this resource returns only users with a role in the project. If &#x60;&quot;includeOrgUsers&quot;: true&#x60;, this resource returns both users with roles in the project and users who have implicit access to the project through their organization role.`)

	_ = cmd.MarkFlagRequired("groupId")
	return cmd
}

type listProjectsOpts struct {
	cli.GlobalOpts
	cli.OutputOpts
	client       *admin.APIClient
	includeCount bool
	itemsPerPage int
	pageNum      int
}

func (opts *listProjectsOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *listProjectsOpts) Run(ctx context.Context) error {
	params := &admin.ListProjectsApiParams{
		IncludeCount: &opts.includeCount,
		ItemsPerPage: &opts.itemsPerPage,
		PageNum:      &opts.pageNum,
	}
	resp, _, err := opts.client.ProjectsApi.ListProjectsWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return opts.Print(resp)
}

func listProjectsBuilder() *cobra.Command {
	const template = "<<some template>>"

	opts := listProjectsOpts{}
	cmd := &cobra.Command{
		Use:   "listProjects",
		Short: "Return All Projects",
		Annotations: map[string]string{
			"output": template,
		},
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
				opts.InitOutput(cmd.OutOrStdout(), template),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context())
		},
	}
	cmd.Flags().BoolVar(&opts.includeCount, "includeCount", true, `Flag that indicates whether the response returns the total number of items (**totalCount**) in the response.`)
	cmd.Flags().IntVar(&opts.itemsPerPage, "itemsPerPage", 100, `Number of items that the response returns per page.`)
	cmd.Flags().IntVar(&opts.pageNum, "pageNum", 1, `Number of the page that displays the current set of the total objects that the response returns.`)

	return cmd
}

type removeProjectUserOpts struct {
	cli.GlobalOpts
	cli.OutputOpts
	client  *admin.APIClient
	groupId string
	userId  string
}

func (opts *removeProjectUserOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *removeProjectUserOpts) Run(ctx context.Context) error {
	params := &admin.RemoveProjectUserApiParams{
		GroupId: opts.groupId,
		UserId:  opts.userId,
	}
	_, err := opts.client.ProjectsApi.RemoveProjectUserWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return opts.Print(nil)
}

func removeProjectUserBuilder() *cobra.Command {
	const template = "<<some template>>"

	opts := removeProjectUserOpts{}
	cmd := &cobra.Command{
		Use:   "removeProjectUser",
		Short: "Remove One User from One Project",
		Annotations: map[string]string{
			"output": template,
		},
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
				opts.InitOutput(cmd.OutOrStdout(), template),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)
	cmd.Flags().StringVar(&opts.userId, "userId", "", `Unique 24-hexadecimal string that identifies MongoDB Cloud user you want to remove from the specified project. To return a application user&#39;s ID using their application username, use the Get All application users in One Project endpoint.`)

	_ = cmd.MarkFlagRequired("groupId")
	_ = cmd.MarkFlagRequired("userId")
	return cmd
}

type setProjectLimitOpts struct {
	cli.GlobalOpts
	cli.OutputOpts
	client    *admin.APIClient
	limitName string
	groupId   string
}

func (opts *setProjectLimitOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *setProjectLimitOpts) Run(ctx context.Context) error {
	params := &admin.SetProjectLimitApiParams{
		LimitName: opts.limitName,
		GroupId:   opts.groupId,
	}
	resp, _, err := opts.client.ProjectsApi.SetProjectLimitWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return opts.Print(resp)
}

func setProjectLimitBuilder() *cobra.Command {
	const template = "<<some template>>"

	opts := setProjectLimitOpts{}
	cmd := &cobra.Command{
		Use:   "setProjectLimit",
		Short: "Set One Project Limit",
		Annotations: map[string]string{
			"output": template,
		},
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
				opts.InitOutput(cmd.OutOrStdout(), template),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context())
		},
	}
	cmd.Flags().StringVar(&opts.limitName, "limitName", "", `Human-readable label that identifies this project limit.

| Limit Name | Description | Default | API Override Limit |
| --- | --- | --- | --- |
| atlas.project.deployment.clusters | Limit on the number of clusters in this project | 25 | 90 |
| atlas.project.deployment.nodesPerPrivateLinkRegion | Limit on the number of nodes per Private Link region in this project | 50 | 90 |
| atlas.project.security.databaseAccess.customRoles | Limit on the number of custom roles in this project | 100 | 1400 |
| atlas.project.security.databaseAccess.users | Limit on the number of database users in this project | 100 | 900 |
| atlas.project.security.networkAccess.crossRegionEntries | Limit on the number of cross-region network access entries in this project | 40 | 220 |
| atlas.project.security.networkAccess.entries | Limit on the number of network access entries in this project | 200 | 20 |
| dataFederation.bytesProcessed.query | Limit on the number of bytes processed during a single Data Federation query | N/A | N/A |
| dataFederation.bytesProcessed.daily | Limit on the number of bytes processed across all Data Federation tenants for the current day | N/A | N/A |
| dataFederation.bytesProcessed.weekly | Limit on the number of bytes processed across all Data Federation tenants for the current week | N/A | N/A |
| dataFederation.bytesProcessed.monthly | Limit on the number of bytes processed across all Data Federation tenants for the current month | N/A | N/A |
`)
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)

	_ = cmd.MarkFlagRequired("limitName")
	_ = cmd.MarkFlagRequired("groupId")
	return cmd
}

type updateProjectOpts struct {
	cli.GlobalOpts
	cli.OutputOpts
	client  *admin.APIClient
	groupId string
}

func (opts *updateProjectOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *updateProjectOpts) Run(ctx context.Context) error {
	params := &admin.UpdateProjectApiParams{
		GroupId: opts.groupId,
	}
	resp, _, err := opts.client.ProjectsApi.UpdateProjectWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return opts.Print(resp)
}

func updateProjectBuilder() *cobra.Command {
	const template = "<<some template>>"

	opts := updateProjectOpts{}
	cmd := &cobra.Command{
		Use:   "updateProject",
		Short: "Update One Project Name",
		Annotations: map[string]string{
			"output": template,
		},
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
				opts.InitOutput(cmd.OutOrStdout(), template),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)

	cmd.Flags().StringVar(&opts.name, "name", "", `Human-readable label that identifies the project included in the MongoDB Cloud organization.`)

	_ = cmd.MarkFlagRequired("groupId")
	return cmd
}

type updateProjectInvitationOpts struct {
	cli.GlobalOpts
	cli.OutputOpts
	client  *admin.APIClient
	groupId string
}

func (opts *updateProjectInvitationOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *updateProjectInvitationOpts) Run(ctx context.Context) error {
	params := &admin.UpdateProjectInvitationApiParams{
		GroupId: opts.groupId,
	}
	resp, _, err := opts.client.ProjectsApi.UpdateProjectInvitationWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return opts.Print(resp)
}

func updateProjectInvitationBuilder() *cobra.Command {
	const template = "<<some template>>"

	opts := updateProjectInvitationOpts{}
	cmd := &cobra.Command{
		Use:   "updateProjectInvitation",
		Short: "Update One Project Invitation",
		Annotations: map[string]string{
			"output": template,
		},
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
				opts.InitOutput(cmd.OutOrStdout(), template),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)

	cmd.Flags().SetSliceVar(&opts.roles, "roles", nil, `One or more organization or project level roles to assign to the MongoDB Cloud user.`)

	cmd.Flags().StringVar(&opts.username, "username", "", `Email address of the MongoDB Cloud user invited to the specified project.`)

	_ = cmd.MarkFlagRequired("groupId")
	return cmd
}

type updateProjectInvitationByIdOpts struct {
	cli.GlobalOpts
	cli.OutputOpts
	client       *admin.APIClient
	groupId      string
	invitationId string
}

func (opts *updateProjectInvitationByIdOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *updateProjectInvitationByIdOpts) Run(ctx context.Context) error {
	params := &admin.UpdateProjectInvitationByIdApiParams{
		GroupId:      opts.groupId,
		InvitationId: opts.invitationId,
	}
	resp, _, err := opts.client.ProjectsApi.UpdateProjectInvitationByIdWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return opts.Print(resp)
}

func updateProjectInvitationByIdBuilder() *cobra.Command {
	const template = "<<some template>>"

	opts := updateProjectInvitationByIdOpts{}
	cmd := &cobra.Command{
		Use:   "updateProjectInvitationById",
		Short: "Update One Project Invitation by Invitation ID",
		Annotations: map[string]string{
			"output": template,
		},
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
				opts.InitOutput(cmd.OutOrStdout(), template),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)
	cmd.Flags().StringVar(&opts.invitationId, "invitationId", "", `Unique 24-hexadecimal digit string that identifies the invitation.`)

	cmd.Flags().SetSliceVar(&opts.roles, "roles", nil, `One or more organization or project level roles to assign to the MongoDB Cloud user.`)

	_ = cmd.MarkFlagRequired("groupId")
	_ = cmd.MarkFlagRequired("invitationId")
	return cmd
}

type updateProjectSettingsOpts struct {
	cli.GlobalOpts
	cli.OutputOpts
	client  *admin.APIClient
	groupId string
}

func (opts *updateProjectSettingsOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *updateProjectSettingsOpts) Run(ctx context.Context) error {
	params := &admin.UpdateProjectSettingsApiParams{
		GroupId: opts.groupId,
	}
	resp, _, err := opts.client.ProjectsApi.UpdateProjectSettingsWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return opts.Print(resp)
}

func updateProjectSettingsBuilder() *cobra.Command {
	const template = "<<some template>>"

	opts := updateProjectSettingsOpts{}
	cmd := &cobra.Command{
		Use:   "updateProjectSettings",
		Short: "Update One Project Settings",
		Annotations: map[string]string{
			"output": template,
		},
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
				opts.InitOutput(cmd.OutOrStdout(), template),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)

	cmd.Flags().BoolVar(&opts.isCollectDatabaseSpecificsStatisticsEnabled, "isCollectDatabaseSpecificsStatisticsEnabled", false, `Flag that indicates whether to collect database-specific metrics  for the specified project.`)

	cmd.Flags().BoolVar(&opts.isDataExplorerEnabled, "isDataExplorerEnabled", false, `Flag that indicates whether to enable the Data Explorer for the specified project.`)

	cmd.Flags().BoolVar(&opts.isExtendedStorageSizesEnabled, "isExtendedStorageSizesEnabled", false, `Flag that indicates whether to enable extended storage sizes  for the specified project.`)

	cmd.Flags().BoolVar(&opts.isPerformanceAdvisorEnabled, "isPerformanceAdvisorEnabled", false, `Flag that indicates whether to enable the Performance Advisor and Profiler  for the specified project.`)

	cmd.Flags().BoolVar(&opts.isRealtimePerformancePanelEnabled, "isRealtimePerformancePanelEnabled", false, `Flag that indicates whether to enable the Real Time Performance Panel for the specified project.`)

	cmd.Flags().BoolVar(&opts.isSchemaAdvisorEnabled, "isSchemaAdvisorEnabled", false, `Flag that indicates whether to enable the Schema Advisor for the specified project.`)

	_ = cmd.MarkFlagRequired("groupId")
	return cmd
}

func projectsBuilder() *cobra.Command {
	cmd := &cobra.Command{
		Use:   "projects",
		Short: `Returns, adds, and edits collections of clusters and users in MongoDB Cloud.`,
	}
	cmd.AddCommand(
		createProjectBuilder(),
		createProjectInvitationBuilder(),
		deleteProjectBuilder(),
		deleteProjectInvitationBuilder(),
		deleteProjectLimitBuilder(),
		getProjectBuilder(),
		getProjectByNameBuilder(),
		getProjectInvitationBuilder(),
		getProjectLimitBuilder(),
		getProjectSettingsBuilder(),
		listProjectInvitationsBuilder(),
		listProjectLimitsBuilder(),
		listProjectUsersBuilder(),
		listProjectsBuilder(),
		removeProjectUserBuilder(),
		setProjectLimitBuilder(),
		updateProjectBuilder(),
		updateProjectInvitationBuilder(),
		updateProjectInvitationByIdBuilder(),
		updateProjectSettingsBuilder(),
	)
	return cmd
}
