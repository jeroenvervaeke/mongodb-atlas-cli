// Copyright 2023 MongoDB Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package generated

import (
	"context"

	"github.com/mongodb/mongodb-atlas-cli/internal/cli"
	"github.com/spf13/cobra"
	"go.mongodb.org/atlas-sdk/v20230201008/admin"
)

type deferMaintenanceWindowOpts struct {
	cli.GlobalOpts
	cli.OutputOpts
	client  *admin.APIClient
	groupId string
}

func (opts *deferMaintenanceWindowOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *deferMaintenanceWindowOpts) Run(ctx context.Context) error {
	params := &admin.DeferMaintenanceWindowApiParams{
		GroupId: opts.groupId,
	}
	_, err := opts.client.MaintenanceWindowsApi.DeferMaintenanceWindowWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return opts.Print(nil)
}

func deferMaintenanceWindowBuilder() *cobra.Command {
	const template = "<<some template>>"

	opts := deferMaintenanceWindowOpts{}
	cmd := &cobra.Command{
		Use:   "deferMaintenanceWindow",
		Short: "Defer One Maintenance Window for One Project",
		Annotations: map[string]string{
			"output": template,
		},
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
				opts.InitOutput(cmd.OutOrStdout(), template),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)

	_ = cmd.MarkFlagRequired("groupId")
	return cmd
}

type getMaintenanceWindowOpts struct {
	cli.GlobalOpts
	cli.OutputOpts
	client  *admin.APIClient
	groupId string
}

func (opts *getMaintenanceWindowOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *getMaintenanceWindowOpts) Run(ctx context.Context) error {
	params := &admin.GetMaintenanceWindowApiParams{
		GroupId: opts.groupId,
	}
	resp, _, err := opts.client.MaintenanceWindowsApi.GetMaintenanceWindowWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return opts.Print(resp)
}

func getMaintenanceWindowBuilder() *cobra.Command {
	const template = "<<some template>>"

	opts := getMaintenanceWindowOpts{}
	cmd := &cobra.Command{
		Use:   "getMaintenanceWindow",
		Short: "Return One Maintenance Window for One Project",
		Annotations: map[string]string{
			"output": template,
		},
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
				opts.InitOutput(cmd.OutOrStdout(), template),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)

	_ = cmd.MarkFlagRequired("groupId")
	return cmd
}

type resetMaintenanceWindowOpts struct {
	cli.GlobalOpts
	cli.OutputOpts
	client  *admin.APIClient
	groupId string
}

func (opts *resetMaintenanceWindowOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *resetMaintenanceWindowOpts) Run(ctx context.Context) error {
	params := &admin.ResetMaintenanceWindowApiParams{
		GroupId: opts.groupId,
	}
	resp, _, err := opts.client.MaintenanceWindowsApi.ResetMaintenanceWindowWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return opts.Print(resp)
}

func resetMaintenanceWindowBuilder() *cobra.Command {
	const template = "<<some template>>"

	opts := resetMaintenanceWindowOpts{}
	cmd := &cobra.Command{
		Use:   "resetMaintenanceWindow",
		Short: "Reset One Maintenance Window for One Project",
		Annotations: map[string]string{
			"output": template,
		},
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
				opts.InitOutput(cmd.OutOrStdout(), template),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)

	_ = cmd.MarkFlagRequired("groupId")
	return cmd
}

type toggleMaintenanceAutoDeferOpts struct {
	cli.GlobalOpts
	cli.OutputOpts
	client  *admin.APIClient
	groupId string
}

func (opts *toggleMaintenanceAutoDeferOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *toggleMaintenanceAutoDeferOpts) Run(ctx context.Context) error {
	params := &admin.ToggleMaintenanceAutoDeferApiParams{
		GroupId: opts.groupId,
	}
	_, err := opts.client.MaintenanceWindowsApi.ToggleMaintenanceAutoDeferWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return opts.Print(nil)
}

func toggleMaintenanceAutoDeferBuilder() *cobra.Command {
	const template = "<<some template>>"

	opts := toggleMaintenanceAutoDeferOpts{}
	cmd := &cobra.Command{
		Use:   "toggleMaintenanceAutoDefer",
		Short: "Toggle Automatic Deferral of Maintenance for One Project",
		Annotations: map[string]string{
			"output": template,
		},
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
				opts.InitOutput(cmd.OutOrStdout(), template),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)

	_ = cmd.MarkFlagRequired("groupId")
	return cmd
}

type updateMaintenanceWindowOpts struct {
	cli.GlobalOpts
	cli.OutputOpts
	client  *admin.APIClient
	groupId string
}

func (opts *updateMaintenanceWindowOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *updateMaintenanceWindowOpts) Run(ctx context.Context) error {
	params := &admin.UpdateMaintenanceWindowApiParams{
		GroupId: opts.groupId,
	}
	resp, _, err := opts.client.MaintenanceWindowsApi.UpdateMaintenanceWindowWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return opts.Print(resp)
}

func updateMaintenanceWindowBuilder() *cobra.Command {
	const template = "<<some template>>"

	opts := updateMaintenanceWindowOpts{}
	cmd := &cobra.Command{
		Use:   "updateMaintenanceWindow",
		Short: "Update Maintenance Window for One Project",
		Annotations: map[string]string{
			"output": template,
		},
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
				opts.InitOutput(cmd.OutOrStdout(), template),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)

	cmd.Flags().BoolVar(&opts.autoDeferOnceEnabled, "autoDeferOnceEnabled", false, `Flag that indicates whether MongoDB Cloud should defer all maintenance windows for one week after you enable them.`)

	cmd.Flags().IntVar(&opts.dayOfWeek, "dayOfWeek", 000, `One-based integer that represents the day of the week that the maintenance window starts.

| Value | Day of Week |
|---|---|
| &#x60;1&#x60; | Sunday |
| &#x60;2&#x60; | Monday |
| &#x60;3&#x60; | Tuesday |
| &#x60;4&#x60; | Wednesday |
| &#x60;5&#x60; | Thursday |
| &#x60;6&#x60; | Friday |
| &#x60;7&#x60; | Saturday |
`)

	cmd.Flags().IntVar(&opts.hourOfDay, "hourOfDay", 000, `Zero-based integer that represents the hour of the of the day that the maintenance window starts according to a 24-hour clock. Use &#x60;0&#x60; for midnight and &#x60;12&#x60; for noon.`)

	cmd.Flags().BoolVar(&opts.startASAP, "startASAP", false, `Flag that indicates whether MongoDB Cloud starts the maintenance window immediately upon receiving this request. To start the maintenance window immediately for your project, MongoDB Cloud must have maintenance scheduled and you must set a maintenance window. This flag resets to &#x60;false&#x60; after MongoDB Cloud completes maintenance.`)

	_ = cmd.MarkFlagRequired("groupId")
	return cmd
}

func maintenanceWindowsBuilder() *cobra.Command {
	cmd := &cobra.Command{
		Use:   "maintenanceWindows",
		Short: `Returns, edits, and removes maintenance windows. The maintenance procedure that MongoDB Cloud performs requires at least one replica set election during the maintenance window per replica set. You can defer a scheduled maintenance event for a project up to two times. Deferred maintenance events occur during your preferred maintenance window exactly one week after the previously scheduled date and time.`,
	}
	cmd.AddCommand(
		deferMaintenanceWindowBuilder(),
		getMaintenanceWindowBuilder(),
		resetMaintenanceWindowBuilder(),
		toggleMaintenanceAutoDeferBuilder(),
		updateMaintenanceWindowBuilder(),
	)
	return cmd
}
