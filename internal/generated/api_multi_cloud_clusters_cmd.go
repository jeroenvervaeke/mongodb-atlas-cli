// Copyright 2023 MongoDB Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package generated

import (
	"context"
	"os"
	"time"

	"github.com/spf13/cobra"
	"go.mongodb.org/atlas-sdk/v20230201008/admin"
	"github.com/mongodb/mongodb-atlas-cli/internal/cli"
)

type createClusterOpts struct {
	cli.GlobalOpts
	cli.OutputOpts
	client *admin.APIClient
	groupId string
	
}

func (opts *createClusterOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *createClusterOpts) Run(ctx context.Context) error {
	params := &admin.CreateClusterApiParams{
		GroupId: opts.groupId,
		
	}
	resp, _, err := opts.client.MultiCloudClustersApi.CreateClusterWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return opts.Print(resp)
}

func createClusterBuilder() *cobra.Command {
	const template = "<<some template>>"

	opts := createClusterOpts{}
	cmd := &cobra.Command{
		Use: "createCluster",
		Short: "Create One Multi-Cloud Cluster from One Project",
		Annotations: map[string]string{
			"output":      template,
		},
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
				opts.InitOutput(cmd.OutOrStdout(), template),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)
	

	cmd.Flags().BoolVar(&opts.backupEnabled, "backupEnabled", false, `Flag that indicates whether the cluster can perform backups. If set to &#x60;true&#x60;, the cluster can perform backups. You must set this value to &#x60;true&#x60; for NVMe clusters. Backup uses [Cloud Backups](https://docs.atlas.mongodb.com/backup/cloud-backup/overview/) for dedicated clusters and [Shared Cluster Backups](https://docs.atlas.mongodb.com/backup/shared-tier/overview/) for tenant clusters. If set to &#x60;false&#x60;, the cluster doesn&#39;t use backups.`)

	cmd.Flags().BiConnectorVar(&opts.biConnector, "biConnector", , ``)

	cmd.Flags().StringVar(&opts.clusterType, "clusterType", "", `Configuration of nodes that comprise the cluster.`)

	cmd.Flags().ClusterDescriptionConnectionStringsVar(&opts.connectionStrings, "connectionStrings", , ``)

	cmd.Flags().StringVar(&opts.createDate, "createDate", "", `Date and time when MongoDB Cloud created this cluster. This parameter expresses its value in ISO 8601 format in UTC.`)

	cmd.Flags().Float64Var(&opts.diskSizeGB, "diskSizeGB", 00, `Storage capacity that the host&#39;s root volume possesses expressed in gigabytes. Increase this number to add capacity. MongoDB Cloud requires this parameter if you set **replicationSpecs**. If you specify a disk size below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier.`)

	cmd.Flags().StringVar(&opts.encryptionAtRestProvider, "encryptionAtRestProvider", "", `Cloud service provider that manages your customer keys to provide an additional layer of encryption at rest for the cluster. To enable customer key management for encryption at rest, the cluster **replicationSpecs[n].regionConfigs[m].{type}Specs.instanceSize** setting must be &#x60;M10&#x60; or higher and &#x60;&quot;backupEnabled&quot; : false&#x60; or omitted entirely.`)

	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal character string that identifies the project.`)

	cmd.Flags().StringVar(&opts.id, "id", "", `Unique 24-hexadecimal digit string that identifies the replication object for a zone in a Global Cluster. If you include existing zones in the request, you must specify this parameter. If you add a new zone to an existing Global Cluster, you may specify this parameter. The request deletes any existing zones in a Global Cluster that you exclude from the request.`)

	cmd.Flags().ArraySliceVar(&opts.labels, "labels", nil, `Collection of key-value pairs between 1 to 255 characters in length that tag and categorize the cluster. The MongoDB Cloud console doesn&#39;t display your labels.`)

	cmd.Flags().ArraySliceVar(&opts.links, "links", nil, `List of one or more Uniform Resource Locators (URLs) that point to API sub-resources, related API resources, or both. RFC 5988 outlines these relationships.`)

	cmd.Flags().StringVar(&opts.mongoDBMajorVersion, "mongoDBMajorVersion", "&quot;6.0&quot;", `Major MongoDB version of the cluster. MongoDB Cloud deploys the cluster with the latest stable release of the specified version.`)

	cmd.Flags().StringVar(&opts.mongoDBVersion, "mongoDBVersion", "", `Version of MongoDB that the cluster runs.`)

	cmd.Flags().StringVar(&opts.name, "name", "", `Human-readable label that identifies the advanced cluster.`)

	cmd.Flags().BoolVar(&opts.paused, "paused", false, `Flag that indicates whether the cluster is paused.`)

	cmd.Flags().BoolVar(&opts.pitEnabled, "pitEnabled", false, `Flag that indicates whether the cluster uses continuous cloud backups.`)

	cmd.Flags().ArraySliceVar(&opts.replicationSpecs, "replicationSpecs", nil, `List of settings that configure your cluster regions. For Global Clusters, each object in the array represents a zone where your clusters nodes deploy. For non-Global sharded clusters and replica sets, this array has one object representing where your clusters nodes deploy.`)

	cmd.Flags().StringVar(&opts.rootCertType, "rootCertType", "&quot;ISRGROOTX1&quot;", `Root Certificate Authority that MongoDB Cloud cluster uses. MongoDB Cloud supports Internet Security Research Group.`)

	cmd.Flags().StringVar(&opts.stateName, "stateName", "", `Human-readable label that indicates the current operating condition of this cluster.`)

	cmd.Flags().ArraySliceVar(&opts.tags, "tags", nil, `Collection of key-value pairs between 1 to 255 characters in length that tag and categorize the cluster.`)

	cmd.Flags().BoolVar(&opts.terminationProtectionEnabled, "terminationProtectionEnabled", false, `Flag that indicates whether termination protection is enabled on the cluster. If set to &#x60;true&#x60;, MongoDB Cloud won&#39;t delete the cluster. If set to &#x60;false&#x60;, MongoDB Cloud will delete the cluster.`)

	cmd.Flags().StringVar(&opts.versionReleaseSystem, "versionReleaseSystem", "&quot;LTS&quot;", `Method by which the cluster maintains the MongoDB versions. If value is &#x60;CONTINUOUS&#x60;, you must not specify **mongoDBMajorVersion**.`)


	_ = cmd.MarkFlagRequired("groupId")
	return cmd
}
type deleteClusterOpts struct {
	cli.GlobalOpts
	cli.OutputOpts
	client *admin.APIClient
	groupId string
	clusterName string
	retainBackups bool
}

func (opts *deleteClusterOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *deleteClusterOpts) Run(ctx context.Context) error {
	params := &admin.DeleteClusterApiParams{
		GroupId: opts.groupId,
		ClusterName: opts.clusterName,
		RetainBackups: &opts.retainBackups,
	}
	_, err := opts.client.MultiCloudClustersApi.DeleteClusterWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return opts.Print(nil)
}

func deleteClusterBuilder() *cobra.Command {
	const template = "<<some template>>"

	opts := deleteClusterOpts{}
	cmd := &cobra.Command{
		Use: "deleteCluster",
		Short: "Remove One Multi-Cloud Cluster from One Project",
		Annotations: map[string]string{
			"output":      template,
		},
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
				opts.InitOutput(cmd.OutOrStdout(), template),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)
	cmd.Flags().StringVar(&opts.clusterName, "clusterName", "", `Human-readable label that identifies the cluster.`)
	cmd.Flags().BoolVar(&opts.retainBackups, "retainBackups", false, `Flag that indicates whether to retain backup snapshots for the deleted dedicated cluster.`)


	_ = cmd.MarkFlagRequired("groupId")
	_ = cmd.MarkFlagRequired("clusterName")
	return cmd
}
type getClusterOpts struct {
	cli.GlobalOpts
	cli.OutputOpts
	client *admin.APIClient
	groupId string
	clusterName string
}

func (opts *getClusterOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *getClusterOpts) Run(ctx context.Context) error {
	params := &admin.GetClusterApiParams{
		GroupId: opts.groupId,
		ClusterName: opts.clusterName,
	}
	resp, _, err := opts.client.MultiCloudClustersApi.GetClusterWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return opts.Print(resp)
}

func getClusterBuilder() *cobra.Command {
	const template = "<<some template>>"

	opts := getClusterOpts{}
	cmd := &cobra.Command{
		Use: "getCluster",
		Short: "Return One Multi-Cloud Cluster from One Project",
		Annotations: map[string]string{
			"output":      template,
		},
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
				opts.InitOutput(cmd.OutOrStdout(), template),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)
	cmd.Flags().StringVar(&opts.clusterName, "clusterName", "", `Human-readable label that identifies this advanced cluster.`)


	_ = cmd.MarkFlagRequired("groupId")
	_ = cmd.MarkFlagRequired("clusterName")
	return cmd
}
type listClustersOpts struct {
	cli.GlobalOpts
	cli.OutputOpts
	client *admin.APIClient
	groupId string
	includeCount bool
	itemsPerPage int
	pageNum int
}

func (opts *listClustersOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *listClustersOpts) Run(ctx context.Context) error {
	params := &admin.ListClustersApiParams{
		GroupId: opts.groupId,
		IncludeCount: &opts.includeCount,
		ItemsPerPage: &opts.itemsPerPage,
		PageNum: &opts.pageNum,
	}
	resp, _, err := opts.client.MultiCloudClustersApi.ListClustersWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return opts.Print(resp)
}

func listClustersBuilder() *cobra.Command {
	const template = "<<some template>>"

	opts := listClustersOpts{}
	cmd := &cobra.Command{
		Use: "listClusters",
		Short: "Return All Multi-Cloud Clusters from One Project",
		Annotations: map[string]string{
			"output":      template,
		},
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
				opts.InitOutput(cmd.OutOrStdout(), template),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)
	cmd.Flags().BoolVar(&opts.includeCount, "includeCount", true, `Flag that indicates whether the response returns the total number of items (**totalCount**) in the response.`)
	cmd.Flags().IntVar(&opts.itemsPerPage, "itemsPerPage", 100, `Number of items that the response returns per page.`)
	cmd.Flags().IntVar(&opts.pageNum, "pageNum", 1, `Number of the page that displays the current set of the total objects that the response returns.`)


	_ = cmd.MarkFlagRequired("groupId")
	return cmd
}
type testFailoverOpts struct {
	cli.GlobalOpts
	cli.OutputOpts
	client *admin.APIClient
	groupId string
	clusterName string
}

func (opts *testFailoverOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *testFailoverOpts) Run(ctx context.Context) error {
	params := &admin.TestFailoverApiParams{
		GroupId: opts.groupId,
		ClusterName: opts.clusterName,
	}
	_, err := opts.client.MultiCloudClustersApi.TestFailoverWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return opts.Print(nil)
}

func testFailoverBuilder() *cobra.Command {
	const template = "<<some template>>"

	opts := testFailoverOpts{}
	cmd := &cobra.Command{
		Use: "testFailover",
		Short: "Test Failover for One Multi-Cloud Cluster",
		Annotations: map[string]string{
			"output":      template,
		},
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
				opts.InitOutput(cmd.OutOrStdout(), template),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)
	cmd.Flags().StringVar(&opts.clusterName, "clusterName", "", `Human-readable label that identifies the cluster.`)


	_ = cmd.MarkFlagRequired("groupId")
	_ = cmd.MarkFlagRequired("clusterName")
	return cmd
}
type updateClusterOpts struct {
	cli.GlobalOpts
	cli.OutputOpts
	client *admin.APIClient
	groupId string
	clusterName string
	
}

func (opts *updateClusterOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *updateClusterOpts) Run(ctx context.Context) error {
	params := &admin.UpdateClusterApiParams{
		GroupId: opts.groupId,
		ClusterName: opts.clusterName,
		
	}
	resp, _, err := opts.client.MultiCloudClustersApi.UpdateClusterWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return opts.Print(resp)
}

func updateClusterBuilder() *cobra.Command {
	const template = "<<some template>>"

	opts := updateClusterOpts{}
	cmd := &cobra.Command{
		Use: "updateCluster",
		Short: "Modify One Multi-Cloud Cluster from One Project",
		Annotations: map[string]string{
			"output":      template,
		},
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
				opts.InitOutput(cmd.OutOrStdout(), template),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)
	cmd.Flags().StringVar(&opts.clusterName, "clusterName", "", `Human-readable label that identifies the advanced cluster to modify.`)
	

	cmd.Flags().BoolVar(&opts.backupEnabled, "backupEnabled", false, `Flag that indicates whether the cluster can perform backups. If set to &#x60;true&#x60;, the cluster can perform backups. You must set this value to &#x60;true&#x60; for NVMe clusters. Backup uses [Cloud Backups](https://docs.atlas.mongodb.com/backup/cloud-backup/overview/) for dedicated clusters and [Shared Cluster Backups](https://docs.atlas.mongodb.com/backup/shared-tier/overview/) for tenant clusters. If set to &#x60;false&#x60;, the cluster doesn&#39;t use backups.`)

	cmd.Flags().BiConnectorVar(&opts.biConnector, "biConnector", , ``)

	cmd.Flags().StringVar(&opts.clusterType, "clusterType", "", `Configuration of nodes that comprise the cluster.`)

	cmd.Flags().ClusterDescriptionConnectionStringsVar(&opts.connectionStrings, "connectionStrings", , ``)

	cmd.Flags().StringVar(&opts.createDate, "createDate", "", `Date and time when MongoDB Cloud created this cluster. This parameter expresses its value in ISO 8601 format in UTC.`)

	cmd.Flags().Float64Var(&opts.diskSizeGB, "diskSizeGB", 00, `Storage capacity that the host&#39;s root volume possesses expressed in gigabytes. Increase this number to add capacity. MongoDB Cloud requires this parameter if you set **replicationSpecs**. If you specify a disk size below the minimum (10 GB), this parameter defaults to the minimum disk size value. Storage charge calculations depend on whether you choose the default value or a custom value.  The maximum value for disk storage cannot exceed 50 times the maximum RAM for the selected cluster. If you require more storage space, consider upgrading your cluster to a higher tier.`)

	cmd.Flags().StringVar(&opts.encryptionAtRestProvider, "encryptionAtRestProvider", "", `Cloud service provider that manages your customer keys to provide an additional layer of encryption at rest for the cluster. To enable customer key management for encryption at rest, the cluster **replicationSpecs[n].regionConfigs[m].{type}Specs.instanceSize** setting must be &#x60;M10&#x60; or higher and &#x60;&quot;backupEnabled&quot; : false&#x60; or omitted entirely.`)

	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal character string that identifies the project.`)

	cmd.Flags().StringVar(&opts.id, "id", "", `Unique 24-hexadecimal digit string that identifies the replication object for a zone in a Global Cluster. If you include existing zones in the request, you must specify this parameter. If you add a new zone to an existing Global Cluster, you may specify this parameter. The request deletes any existing zones in a Global Cluster that you exclude from the request.`)

	cmd.Flags().ArraySliceVar(&opts.labels, "labels", nil, `Collection of key-value pairs between 1 to 255 characters in length that tag and categorize the cluster. The MongoDB Cloud console doesn&#39;t display your labels.`)

	cmd.Flags().ArraySliceVar(&opts.links, "links", nil, `List of one or more Uniform Resource Locators (URLs) that point to API sub-resources, related API resources, or both. RFC 5988 outlines these relationships.`)

	cmd.Flags().StringVar(&opts.mongoDBMajorVersion, "mongoDBMajorVersion", "&quot;6.0&quot;", `Major MongoDB version of the cluster. MongoDB Cloud deploys the cluster with the latest stable release of the specified version.`)

	cmd.Flags().StringVar(&opts.mongoDBVersion, "mongoDBVersion", "", `Version of MongoDB that the cluster runs.`)

	cmd.Flags().StringVar(&opts.name, "name", "", `Human-readable label that identifies the advanced cluster.`)

	cmd.Flags().BoolVar(&opts.paused, "paused", false, `Flag that indicates whether the cluster is paused.`)

	cmd.Flags().BoolVar(&opts.pitEnabled, "pitEnabled", false, `Flag that indicates whether the cluster uses continuous cloud backups.`)

	cmd.Flags().ArraySliceVar(&opts.replicationSpecs, "replicationSpecs", nil, `List of settings that configure your cluster regions. For Global Clusters, each object in the array represents a zone where your clusters nodes deploy. For non-Global sharded clusters and replica sets, this array has one object representing where your clusters nodes deploy.`)

	cmd.Flags().StringVar(&opts.rootCertType, "rootCertType", "&quot;ISRGROOTX1&quot;", `Root Certificate Authority that MongoDB Cloud cluster uses. MongoDB Cloud supports Internet Security Research Group.`)

	cmd.Flags().StringVar(&opts.stateName, "stateName", "", `Human-readable label that indicates the current operating condition of this cluster.`)

	cmd.Flags().ArraySliceVar(&opts.tags, "tags", nil, `Collection of key-value pairs between 1 to 255 characters in length that tag and categorize the cluster.`)

	cmd.Flags().BoolVar(&opts.terminationProtectionEnabled, "terminationProtectionEnabled", false, `Flag that indicates whether termination protection is enabled on the cluster. If set to &#x60;true&#x60;, MongoDB Cloud won&#39;t delete the cluster. If set to &#x60;false&#x60;, MongoDB Cloud will delete the cluster.`)

	cmd.Flags().StringVar(&opts.versionReleaseSystem, "versionReleaseSystem", "&quot;LTS&quot;", `Method by which the cluster maintains the MongoDB versions. If value is &#x60;CONTINUOUS&#x60;, you must not specify **mongoDBMajorVersion**.`)


	_ = cmd.MarkFlagRequired("groupId")
	_ = cmd.MarkFlagRequired("clusterName")
	return cmd
}

func multiCloudClustersBuilder() *cobra.Command {
	cmd := &cobra.Command{
		Use:     "multiCloudClusters",
		Short:   `Returns, adds, edits, or removes multi-cloud clusters. Changes to cluster configurations can affect costs.

The total number of nodes in clusters spanning across regions has a specific constraint on a per-project basis. MongoDB Cloud limits the total number of nodes in other regions in one project to a total of 40. This total excludes Google Cloud regions communicating with each other, shared-tier clusters, or serverless clusters. The total number of nodes between any two regions must meet this constraint. For example, if a project has nodes in clusters spread across three regions: 30 nodes in Region A, 10 nodes in Region B, and 5 nodes in Region C, you can add only 5 more nodes to Region C because if you exclude Region C, Region A + Region B &#x3D; 40. If you exclude Region B, Region A + Region C &#x3D; 35, &lt;&#x3D; 40. If you exclude Region A, Region B + Region C &#x3D; 15, &lt;&#x3D; 40. Each combination of regions with the added 5 nodes still meets the per-project constraint. Region A + B &#x3D; 40. Region A + C &#x3D; 40. Region B + C &#x3D; 20. You can&#39;t create a multi-region cluster in a project if it has one or more clusters spanning 40 or more nodes in other regions. Each project supports up to 25 database deployments.

If your MongoDB Cloud project contains a custom role that uses actions introduced in a specific MongoDB version, you must delete that role before you create clusters with an earlier MongoDB version. MongoDB Cloud clusters created after July 2020 use TLS version 1.2 by default. When you create a cluster, MongoDB Cloud creates a network container in the project for the cloud provider to which you deploy the cluster if one doesn&#39;t already exist.`,
	}
	cmd.AddCommand(
		createClusterBuilder(),
		deleteClusterBuilder(),
		getClusterBuilder(),
		listClustersBuilder(),
		testFailoverBuilder(),
		updateClusterBuilder(),
	)
	return cmd
}

