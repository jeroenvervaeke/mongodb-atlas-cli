// Copyright 2024 MongoDB Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"context"
	"encoding/hex"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"strings"
	"text/template"
	"time"

	"github.com/mongodb/mongodb-atlas-cli/atlascli/internal/config"
	"github.com/spf13/cobra"
	"go.mongodb.org/atlas-sdk/v20231115012/admin"
)

type getAtlasProcessOpts struct {
	client    *admin.APIClient
	groupId   string
	processId string
	format    string
	tmpl      *template.Template
	resp      *admin.ApiHostViewAtlas
}

func (opts *getAtlasProcessOpts) preRun() (err error) {
	if opts.client, err = newClientWithAuth(config.UserAgent, config.Default()); err != nil {
		return err
	}

	if opts.groupId == "" {
		opts.groupId = config.ProjectID()
	}
	if opts.groupId == "" {
		return errors.New(`required flag(s) "projectId" not set`)
	}
	b, errDecode := hex.DecodeString(opts.groupId)
	if errDecode != nil || len(b) != 12 {
		return fmt.Errorf("the provided value '%s' is not a valid ID", opts.groupId)
	}

	if opts.format != "" {
		if opts.tmpl, err = template.New("").Parse(strings.ReplaceAll(opts.format, "\\n", "\n") + "\n"); err != nil {
			return err
		}
	}

	return nil
}

func (opts *getAtlasProcessOpts) run(ctx context.Context, _ io.Reader) error {

	params := &admin.GetAtlasProcessApiParams{
		GroupId:   opts.groupId,
		ProcessId: opts.processId,
	}

	var err error
	opts.resp, _, err = opts.client.MonitoringAndLogsApi.GetAtlasProcessWithParams(ctx, params).Execute()
	return err
}

func (opts *getAtlasProcessOpts) postRun(_ context.Context, w io.Writer) error {

	prettyJSON, errJson := json.MarshalIndent(opts.resp, "", " ")
	if errJson != nil {
		return errJson
	}

	if opts.format == "" {
		_, err := fmt.Fprintln(w, string(prettyJSON))
		return err
	}

	var parsedJSON interface{}
	if err := json.Unmarshal([]byte(prettyJSON), &parsedJSON); err != nil {
		return err
	}

	return opts.tmpl.Execute(w, parsedJSON)
}

func getAtlasProcessBuilder() *cobra.Command {
	opts := getAtlasProcessOpts{}
	cmd := &cobra.Command{
		Use:   "getAtlasProcess",
		Short: "Return One MongoDB Process by ID",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.preRun()
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.run(cmd.Context(), cmd.InOrStdin())
		},
		PostRunE: func(cmd *cobra.Command, args []string) error {
			return opts.postRun(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "projectId", "", `Unique 24-hexadecimal digit string that identifies your project.`)
	cmd.Flags().StringVar(&opts.processId, "processId", "", `Combination of hostname and Internet Assigned Numbers Authority (IANA) port that serves the MongoDB process. The host must be the hostname, fully qualified domain name (FQDN), or Internet Protocol address (IPv4 or IPv6) of the host that runs the MongoDB process (&#x60;mongod&#x60; or &#x60;mongos&#x60;). The port must be the IANA port on which the MongoDB process listens for requests.`)

	_ = cmd.MarkFlagRequired("processId")
	cmd.Flags().StringVar(&opts.format, "format", "", "Format of the output")
	return cmd
}

type getDatabaseOpts struct {
	client       *admin.APIClient
	groupId      string
	databaseName string
	processId    string
	format       string
	tmpl         *template.Template
	resp         *admin.MesurementsDatabase
}

func (opts *getDatabaseOpts) preRun() (err error) {
	if opts.client, err = newClientWithAuth(config.UserAgent, config.Default()); err != nil {
		return err
	}

	if opts.groupId == "" {
		opts.groupId = config.ProjectID()
	}
	if opts.groupId == "" {
		return errors.New(`required flag(s) "projectId" not set`)
	}
	b, errDecode := hex.DecodeString(opts.groupId)
	if errDecode != nil || len(b) != 12 {
		return fmt.Errorf("the provided value '%s' is not a valid ID", opts.groupId)
	}

	if opts.format != "" {
		if opts.tmpl, err = template.New("").Parse(strings.ReplaceAll(opts.format, "\\n", "\n") + "\n"); err != nil {
			return err
		}
	}

	return nil
}

func (opts *getDatabaseOpts) run(ctx context.Context, _ io.Reader) error {

	params := &admin.GetDatabaseApiParams{
		GroupId:      opts.groupId,
		DatabaseName: opts.databaseName,
		ProcessId:    opts.processId,
	}

	var err error
	opts.resp, _, err = opts.client.MonitoringAndLogsApi.GetDatabaseWithParams(ctx, params).Execute()
	return err
}

func (opts *getDatabaseOpts) postRun(_ context.Context, w io.Writer) error {

	prettyJSON, errJson := json.MarshalIndent(opts.resp, "", " ")
	if errJson != nil {
		return errJson
	}

	if opts.format == "" {
		_, err := fmt.Fprintln(w, string(prettyJSON))
		return err
	}

	var parsedJSON interface{}
	if err := json.Unmarshal([]byte(prettyJSON), &parsedJSON); err != nil {
		return err
	}

	return opts.tmpl.Execute(w, parsedJSON)
}

func getDatabaseBuilder() *cobra.Command {
	opts := getDatabaseOpts{}
	cmd := &cobra.Command{
		Use:   "getDatabase",
		Short: "Return One Database for a MongoDB Process",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.preRun()
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.run(cmd.Context(), cmd.InOrStdin())
		},
		PostRunE: func(cmd *cobra.Command, args []string) error {
			return opts.postRun(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "projectId", "", `Unique 24-hexadecimal digit string that identifies your project.`)
	cmd.Flags().StringVar(&opts.databaseName, "databaseName", "", `Human-readable label that identifies the database that the specified MongoDB process serves.`)
	cmd.Flags().StringVar(&opts.processId, "processId", "", `Combination of hostname and Internet Assigned Numbers Authority (IANA) port that serves the MongoDB process. The host must be the hostname, fully qualified domain name (FQDN), or Internet Protocol address (IPv4 or IPv6) of the host that runs the MongoDB process (&#x60;mongod&#x60; or &#x60;mongos&#x60;). The port must be the IANA port on which the MongoDB process listens for requests.`)

	_ = cmd.MarkFlagRequired("databaseName")
	_ = cmd.MarkFlagRequired("processId")
	cmd.Flags().StringVar(&opts.format, "format", "", "Format of the output")
	return cmd
}

type getDatabaseMeasurementsOpts struct {
	client       *admin.APIClient
	groupId      string
	databaseName string
	processId    string
	granularity  string
	m            []string
	period       string
	start        string
	end          string
	format       string
	tmpl         *template.Template
	resp         *admin.ApiMeasurementsGeneralViewAtlas
}

func (opts *getDatabaseMeasurementsOpts) preRun() (err error) {
	if opts.client, err = newClientWithAuth(config.UserAgent, config.Default()); err != nil {
		return err
	}

	if opts.groupId == "" {
		opts.groupId = config.ProjectID()
	}
	if opts.groupId == "" {
		return errors.New(`required flag(s) "projectId" not set`)
	}
	b, errDecode := hex.DecodeString(opts.groupId)
	if errDecode != nil || len(b) != 12 {
		return fmt.Errorf("the provided value '%s' is not a valid ID", opts.groupId)
	}

	if opts.format != "" {
		if opts.tmpl, err = template.New("").Parse(strings.ReplaceAll(opts.format, "\\n", "\n") + "\n"); err != nil {
			return err
		}
	}

	return nil
}

func (opts *getDatabaseMeasurementsOpts) run(ctx context.Context, _ io.Reader) error {

	var start *time.Time
	var errStart error
	if opts.start != "" {
		*start, errStart = time.Parse(time.RFC3339, opts.start)
		if errStart != nil {
			return errStart
		}
	}

	var end *time.Time
	var errEnd error
	if opts.end != "" {
		*end, errEnd = time.Parse(time.RFC3339, opts.end)
		if errEnd != nil {
			return errEnd
		}
	}

	params := &admin.GetDatabaseMeasurementsApiParams{
		GroupId:      opts.groupId,
		DatabaseName: opts.databaseName,
		ProcessId:    opts.processId,
		Granularity:  &opts.granularity,
		M:            &opts.m,
		Period:       &opts.period,
		Start:        start,
		End:          end,
	}

	var err error
	opts.resp, _, err = opts.client.MonitoringAndLogsApi.GetDatabaseMeasurementsWithParams(ctx, params).Execute()
	return err
}

func (opts *getDatabaseMeasurementsOpts) postRun(_ context.Context, w io.Writer) error {

	prettyJSON, errJson := json.MarshalIndent(opts.resp, "", " ")
	if errJson != nil {
		return errJson
	}

	if opts.format == "" {
		_, err := fmt.Fprintln(w, string(prettyJSON))
		return err
	}

	var parsedJSON interface{}
	if err := json.Unmarshal([]byte(prettyJSON), &parsedJSON); err != nil {
		return err
	}

	return opts.tmpl.Execute(w, parsedJSON)
}

func getDatabaseMeasurementsBuilder() *cobra.Command {
	opts := getDatabaseMeasurementsOpts{}
	cmd := &cobra.Command{
		Use:   "getDatabaseMeasurements",
		Short: "Return Measurements of One Database for One MongoDB Process",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.preRun()
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.run(cmd.Context(), cmd.InOrStdin())
		},
		PostRunE: func(cmd *cobra.Command, args []string) error {
			return opts.postRun(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "projectId", "", `Unique 24-hexadecimal digit string that identifies your project.`)
	cmd.Flags().StringVar(&opts.databaseName, "databaseName", "", `Human-readable label that identifies the database that the specified MongoDB process serves.`)
	cmd.Flags().StringVar(&opts.processId, "processId", "", `Combination of hostname and Internet Assigned Numbers Authority (IANA) port that serves the MongoDB process. The host must be the hostname, fully qualified domain name (FQDN), or Internet Protocol address (IPv4 or IPv6) of the host that runs the MongoDB process (&#x60;mongod&#x60; or &#x60;mongos&#x60;). The port must be the IANA port on which the MongoDB process listens for requests.`)
	cmd.Flags().StringVar(&opts.granularity, "granularity", "", `Duration that specifies the interval at which Atlas reports the metrics. This parameter expresses its value in the ISO 8601 duration format in UTC.`)
	cmd.Flags().StringSliceVar(&opts.m, "m", nil, `One or more types of measurement to request for this MongoDB process. If omitted, the resource returns all measurements. To specify multiple values for &#x60;m&#x60;, repeat the &#x60;m&#x60; parameter for each value. Specify measurements that apply to the specified host. MongoDB Cloud returns an error if you specified any invalid measurements.`)
	cmd.Flags().StringVar(&opts.period, "period", "", `Duration over which Atlas reports the metrics. This parameter expresses its value in the ISO 8601 duration format in UTC. Include this parameter when you do not set **start** and **end**.`)
	cmd.Flags().StringVar(&opts.start, "start", "", `Date and time when MongoDB Cloud begins reporting the metrics. This parameter expresses its value in the ISO 8601 timestamp format in UTC. Include this parameter when you do not set **period**.`)
	cmd.Flags().StringVar(&opts.end, "end", "", `Date and time when MongoDB Cloud stops reporting the metrics. This parameter expresses its value in the ISO 8601 timestamp format in UTC. Include this parameter when you do not set **period**.`)

	_ = cmd.MarkFlagRequired("databaseName")
	_ = cmd.MarkFlagRequired("processId")
	_ = cmd.MarkFlagRequired("granularity")
	cmd.Flags().StringVar(&opts.format, "format", "", "Format of the output")
	return cmd
}

type getDiskMeasurementsOpts struct {
	client        *admin.APIClient
	groupId       string
	partitionName string
	processId     string
	granularity   string
	m             []string
	period        string
	start         string
	end           string
	format        string
	tmpl          *template.Template
	resp          *admin.ApiMeasurementsGeneralViewAtlas
}

func (opts *getDiskMeasurementsOpts) preRun() (err error) {
	if opts.client, err = newClientWithAuth(config.UserAgent, config.Default()); err != nil {
		return err
	}

	if opts.groupId == "" {
		opts.groupId = config.ProjectID()
	}
	if opts.groupId == "" {
		return errors.New(`required flag(s) "projectId" not set`)
	}
	b, errDecode := hex.DecodeString(opts.groupId)
	if errDecode != nil || len(b) != 12 {
		return fmt.Errorf("the provided value '%s' is not a valid ID", opts.groupId)
	}

	if opts.format != "" {
		if opts.tmpl, err = template.New("").Parse(strings.ReplaceAll(opts.format, "\\n", "\n") + "\n"); err != nil {
			return err
		}
	}

	return nil
}

func (opts *getDiskMeasurementsOpts) run(ctx context.Context, _ io.Reader) error {

	var start *time.Time
	var errStart error
	if opts.start != "" {
		*start, errStart = time.Parse(time.RFC3339, opts.start)
		if errStart != nil {
			return errStart
		}
	}

	var end *time.Time
	var errEnd error
	if opts.end != "" {
		*end, errEnd = time.Parse(time.RFC3339, opts.end)
		if errEnd != nil {
			return errEnd
		}
	}

	params := &admin.GetDiskMeasurementsApiParams{
		GroupId:       opts.groupId,
		PartitionName: opts.partitionName,
		ProcessId:     opts.processId,
		Granularity:   &opts.granularity,
		M:             &opts.m,
		Period:        &opts.period,
		Start:         start,
		End:           end,
	}

	var err error
	opts.resp, _, err = opts.client.MonitoringAndLogsApi.GetDiskMeasurementsWithParams(ctx, params).Execute()
	return err
}

func (opts *getDiskMeasurementsOpts) postRun(_ context.Context, w io.Writer) error {

	prettyJSON, errJson := json.MarshalIndent(opts.resp, "", " ")
	if errJson != nil {
		return errJson
	}

	if opts.format == "" {
		_, err := fmt.Fprintln(w, string(prettyJSON))
		return err
	}

	var parsedJSON interface{}
	if err := json.Unmarshal([]byte(prettyJSON), &parsedJSON); err != nil {
		return err
	}

	return opts.tmpl.Execute(w, parsedJSON)
}

func getDiskMeasurementsBuilder() *cobra.Command {
	opts := getDiskMeasurementsOpts{}
	cmd := &cobra.Command{
		Use:   "getDiskMeasurements",
		Short: "Return Measurements of One Disk for One MongoDB Process",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.preRun()
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.run(cmd.Context(), cmd.InOrStdin())
		},
		PostRunE: func(cmd *cobra.Command, args []string) error {
			return opts.postRun(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "projectId", "", `Unique 24-hexadecimal digit string that identifies your project.`)
	cmd.Flags().StringVar(&opts.partitionName, "partitionName", "", `Human-readable label of the disk or partition to which the measurements apply.`)
	cmd.Flags().StringVar(&opts.processId, "processId", "", `Combination of hostname and Internet Assigned Numbers Authority (IANA) port that serves the MongoDB process. The host must be the hostname, fully qualified domain name (FQDN), or Internet Protocol address (IPv4 or IPv6) of the host that runs the MongoDB process (&#x60;mongod&#x60; or &#x60;mongos&#x60;). The port must be the IANA port on which the MongoDB process listens for requests.`)
	cmd.Flags().StringVar(&opts.granularity, "granularity", "", `Duration that specifies the interval at which Atlas reports the metrics. This parameter expresses its value in the ISO 8601 duration format in UTC.`)
	cmd.Flags().StringSliceVar(&opts.m, "m", nil, `One or more types of measurement to request for this MongoDB process. If omitted, the resource returns all measurements. To specify multiple values for &#x60;m&#x60;, repeat the &#x60;m&#x60; parameter for each value. Specify measurements that apply to the specified host. MongoDB Cloud returns an error if you specified any invalid measurements.`)
	cmd.Flags().StringVar(&opts.period, "period", "", `Duration over which Atlas reports the metrics. This parameter expresses its value in the ISO 8601 duration format in UTC. Include this parameter when you do not set **start** and **end**.`)
	cmd.Flags().StringVar(&opts.start, "start", "", `Date and time when MongoDB Cloud begins reporting the metrics. This parameter expresses its value in the ISO 8601 timestamp format in UTC. Include this parameter when you do not set **period**.`)
	cmd.Flags().StringVar(&opts.end, "end", "", `Date and time when MongoDB Cloud stops reporting the metrics. This parameter expresses its value in the ISO 8601 timestamp format in UTC. Include this parameter when you do not set **period**.`)

	_ = cmd.MarkFlagRequired("partitionName")
	_ = cmd.MarkFlagRequired("processId")
	_ = cmd.MarkFlagRequired("granularity")
	cmd.Flags().StringVar(&opts.format, "format", "", "Format of the output")
	return cmd
}

type getHostLogsOpts struct {
	client    *admin.APIClient
	groupId   string
	hostName  string
	logName   string
	endDate   int64
	startDate int64
	format    string
	tmpl      *template.Template
	resp      io.ReadCloser
}

func (opts *getHostLogsOpts) preRun() (err error) {
	if opts.client, err = newClientWithAuth(config.UserAgent, config.Default()); err != nil {
		return err
	}

	if opts.groupId == "" {
		opts.groupId = config.ProjectID()
	}
	if opts.groupId == "" {
		return errors.New(`required flag(s) "projectId" not set`)
	}
	b, errDecode := hex.DecodeString(opts.groupId)
	if errDecode != nil || len(b) != 12 {
		return fmt.Errorf("the provided value '%s' is not a valid ID", opts.groupId)
	}

	if opts.format != "" {
		if opts.tmpl, err = template.New("").Parse(strings.ReplaceAll(opts.format, "\\n", "\n") + "\n"); err != nil {
			return err
		}
	}

	return nil
}

func (opts *getHostLogsOpts) run(ctx context.Context, _ io.Reader) error {

	params := &admin.GetHostLogsApiParams{
		GroupId:   opts.groupId,
		HostName:  opts.hostName,
		LogName:   opts.logName,
		EndDate:   &opts.endDate,
		StartDate: &opts.startDate,
	}

	var err error
	opts.resp, _, err = opts.client.MonitoringAndLogsApi.GetHostLogsWithParams(ctx, params).Execute()
	return err
}

func (opts *getHostLogsOpts) postRun(_ context.Context, w io.Writer) error {

	prettyJSON, errJson := json.MarshalIndent(opts.resp, "", " ")
	if errJson != nil {
		return errJson
	}

	if opts.format == "" {
		_, err := fmt.Fprintln(w, string(prettyJSON))
		return err
	}

	var parsedJSON interface{}
	if err := json.Unmarshal([]byte(prettyJSON), &parsedJSON); err != nil {
		return err
	}

	return opts.tmpl.Execute(w, parsedJSON)
}

func getHostLogsBuilder() *cobra.Command {
	opts := getHostLogsOpts{}
	cmd := &cobra.Command{
		Use:   "getHostLogs",
		Short: "Download Logs for One Cluster Host in One Project",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.preRun()
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.run(cmd.Context(), cmd.InOrStdin())
		},
		PostRunE: func(cmd *cobra.Command, args []string) error {
			return opts.postRun(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "projectId", "", `Unique 24-hexadecimal digit string that identifies your project.`)
	cmd.Flags().StringVar(&opts.hostName, "hostName", "", `Human-readable label that identifies the host that stores the log files that you want to download.`)
	cmd.Flags().StringVar(&opts.logName, "logName", "", `Human-readable label that identifies the log file that you want to return. To return audit logs, enable *Database Auditing* for the specified project.`)
	cmd.Flags().Int64Var(&opts.endDate, "endDate", 0, `Date and time when the period specifies the inclusive ending point for the range of log messages to retrieve. This parameter expresses its value in the number of seconds that have elapsed since the UNIX epoch.`)
	cmd.Flags().Int64Var(&opts.startDate, "startDate", 0, `Date and time when the period specifies the inclusive starting point for the range of log messages to retrieve. This parameter expresses its value in the number of seconds that have elapsed since the UNIX epoch.`)

	_ = cmd.MarkFlagRequired("hostName")
	_ = cmd.MarkFlagRequired("logName")
	cmd.Flags().StringVar(&opts.format, "format", "", "Format of the output")
	return cmd
}

type getHostMeasurementsOpts struct {
	client      *admin.APIClient
	groupId     string
	processId   string
	granularity string
	m           []string
	period      string
	start       string
	end         string
	format      string
	tmpl        *template.Template
	resp        *admin.ApiMeasurementsGeneralViewAtlas
}

func (opts *getHostMeasurementsOpts) preRun() (err error) {
	if opts.client, err = newClientWithAuth(config.UserAgent, config.Default()); err != nil {
		return err
	}

	if opts.groupId == "" {
		opts.groupId = config.ProjectID()
	}
	if opts.groupId == "" {
		return errors.New(`required flag(s) "projectId" not set`)
	}
	b, errDecode := hex.DecodeString(opts.groupId)
	if errDecode != nil || len(b) != 12 {
		return fmt.Errorf("the provided value '%s' is not a valid ID", opts.groupId)
	}

	if opts.format != "" {
		if opts.tmpl, err = template.New("").Parse(strings.ReplaceAll(opts.format, "\\n", "\n") + "\n"); err != nil {
			return err
		}
	}

	return nil
}

func (opts *getHostMeasurementsOpts) run(ctx context.Context, _ io.Reader) error {

	var start *time.Time
	var errStart error
	if opts.start != "" {
		*start, errStart = time.Parse(time.RFC3339, opts.start)
		if errStart != nil {
			return errStart
		}
	}

	var end *time.Time
	var errEnd error
	if opts.end != "" {
		*end, errEnd = time.Parse(time.RFC3339, opts.end)
		if errEnd != nil {
			return errEnd
		}
	}

	params := &admin.GetHostMeasurementsApiParams{
		GroupId:     opts.groupId,
		ProcessId:   opts.processId,
		Granularity: &opts.granularity,
		M:           &opts.m,
		Period:      &opts.period,
		Start:       start,
		End:         end,
	}

	var err error
	opts.resp, _, err = opts.client.MonitoringAndLogsApi.GetHostMeasurementsWithParams(ctx, params).Execute()
	return err
}

func (opts *getHostMeasurementsOpts) postRun(_ context.Context, w io.Writer) error {

	prettyJSON, errJson := json.MarshalIndent(opts.resp, "", " ")
	if errJson != nil {
		return errJson
	}

	if opts.format == "" {
		_, err := fmt.Fprintln(w, string(prettyJSON))
		return err
	}

	var parsedJSON interface{}
	if err := json.Unmarshal([]byte(prettyJSON), &parsedJSON); err != nil {
		return err
	}

	return opts.tmpl.Execute(w, parsedJSON)
}

func getHostMeasurementsBuilder() *cobra.Command {
	opts := getHostMeasurementsOpts{}
	cmd := &cobra.Command{
		Use:   "getHostMeasurements",
		Short: "Return Measurements for One MongoDB Process",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.preRun()
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.run(cmd.Context(), cmd.InOrStdin())
		},
		PostRunE: func(cmd *cobra.Command, args []string) error {
			return opts.postRun(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "projectId", "", `Unique 24-hexadecimal digit string that identifies your project.`)
	cmd.Flags().StringVar(&opts.processId, "processId", "", `Combination of hostname and Internet Assigned Numbers Authority (IANA) port that serves the MongoDB process. The host must be the hostname, fully qualified domain name (FQDN), or Internet Protocol address (IPv4 or IPv6) of the host that runs the MongoDB process (&#x60;mongod&#x60; or &#x60;mongos&#x60;). The port must be the IANA port on which the MongoDB process listens for requests.`)
	cmd.Flags().StringVar(&opts.granularity, "granularity", "", `Duration that specifies the interval at which Atlas reports the metrics. This parameter expresses its value in the ISO 8601 duration format in UTC.`)
	cmd.Flags().StringSliceVar(&opts.m, "m", nil, `One or more types of measurement to request for this MongoDB process. If omitted, the resource returns all measurements. To specify multiple values for &#x60;m&#x60;, repeat the &#x60;m&#x60; parameter for each value. Specify measurements that apply to the specified host. MongoDB Cloud returns an error if you specified any invalid measurements.`)
	cmd.Flags().StringVar(&opts.period, "period", "", `Duration over which Atlas reports the metrics. This parameter expresses its value in the ISO 8601 duration format in UTC. Include this parameter when you do not set **start** and **end**.`)
	cmd.Flags().StringVar(&opts.start, "start", "", `Date and time when MongoDB Cloud begins reporting the metrics. This parameter expresses its value in the ISO 8601 timestamp format in UTC. Include this parameter when you do not set **period**.`)
	cmd.Flags().StringVar(&opts.end, "end", "", `Date and time when MongoDB Cloud stops reporting the metrics. This parameter expresses its value in the ISO 8601 timestamp format in UTC. Include this parameter when you do not set **period**.`)

	_ = cmd.MarkFlagRequired("processId")
	_ = cmd.MarkFlagRequired("granularity")
	cmd.Flags().StringVar(&opts.format, "format", "", "Format of the output")
	return cmd
}

type getIndexMetricsOpts struct {
	client         *admin.APIClient
	processId      string
	indexName      string
	databaseName   string
	collectionName string
	groupId        string
	granularity    string
	metrics        []string
	period         string
	start          string
	end            string
	format         string
	tmpl           *template.Template
	resp           *admin.MeasurementsIndexes
}

func (opts *getIndexMetricsOpts) preRun() (err error) {
	if opts.client, err = newClientWithAuth(config.UserAgent, config.Default()); err != nil {
		return err
	}

	if opts.groupId == "" {
		opts.groupId = config.ProjectID()
	}
	if opts.groupId == "" {
		return errors.New(`required flag(s) "projectId" not set`)
	}
	b, errDecode := hex.DecodeString(opts.groupId)
	if errDecode != nil || len(b) != 12 {
		return fmt.Errorf("the provided value '%s' is not a valid ID", opts.groupId)
	}

	if opts.format != "" {
		if opts.tmpl, err = template.New("").Parse(strings.ReplaceAll(opts.format, "\\n", "\n") + "\n"); err != nil {
			return err
		}
	}

	return nil
}

func (opts *getIndexMetricsOpts) run(ctx context.Context, _ io.Reader) error {

	var start *time.Time
	var errStart error
	if opts.start != "" {
		*start, errStart = time.Parse(time.RFC3339, opts.start)
		if errStart != nil {
			return errStart
		}
	}

	var end *time.Time
	var errEnd error
	if opts.end != "" {
		*end, errEnd = time.Parse(time.RFC3339, opts.end)
		if errEnd != nil {
			return errEnd
		}
	}

	params := &admin.GetIndexMetricsApiParams{
		ProcessId:      opts.processId,
		IndexName:      opts.indexName,
		DatabaseName:   opts.databaseName,
		CollectionName: opts.collectionName,
		GroupId:        opts.groupId,
		Granularity:    &opts.granularity,
		Metrics:        &opts.metrics,
		Period:         &opts.period,
		Start:          start,
		End:            end,
	}

	var err error
	opts.resp, _, err = opts.client.MonitoringAndLogsApi.GetIndexMetricsWithParams(ctx, params).Execute()
	return err
}

func (opts *getIndexMetricsOpts) postRun(_ context.Context, w io.Writer) error {

	prettyJSON, errJson := json.MarshalIndent(opts.resp, "", " ")
	if errJson != nil {
		return errJson
	}

	if opts.format == "" {
		_, err := fmt.Fprintln(w, string(prettyJSON))
		return err
	}

	var parsedJSON interface{}
	if err := json.Unmarshal([]byte(prettyJSON), &parsedJSON); err != nil {
		return err
	}

	return opts.tmpl.Execute(w, parsedJSON)
}

func getIndexMetricsBuilder() *cobra.Command {
	opts := getIndexMetricsOpts{}
	cmd := &cobra.Command{
		Use:   "getIndexMetrics",
		Short: "Return Atlas Search Metrics for One Index in One Specified Namespace",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.preRun()
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.run(cmd.Context(), cmd.InOrStdin())
		},
		PostRunE: func(cmd *cobra.Command, args []string) error {
			return opts.postRun(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.processId, "processId", "", `Combination of hostname and IANA port that serves the MongoDB process. The host must be the hostname, fully qualified domain name (FQDN), or Internet Protocol address (IPv4 or IPv6) of the host that runs the MongoDB process (mongod or mongos). The port must be the IANA port on which the MongoDB process listens for requests.`)
	cmd.Flags().StringVar(&opts.indexName, "indexName", "", `Human-readable label that identifies the index.`)
	cmd.Flags().StringVar(&opts.databaseName, "databaseName", "", `Human-readable label that identifies the database.`)
	cmd.Flags().StringVar(&opts.collectionName, "collectionName", "", `Human-readable label that identifies the collection.`)
	cmd.Flags().StringVar(&opts.groupId, "projectId", "", `Unique 24-hexadecimal digit string that identifies your project.`)
	cmd.Flags().StringVar(&opts.granularity, "granularity", "", `Duration that specifies the interval at which Atlas reports the metrics. This parameter expresses its value in the ISO 8601 duration format in UTC.`)
	cmd.Flags().StringSliceVar(&opts.metrics, "metrics", nil, `List that contains the measurements that MongoDB Atlas reports for the associated data series.`)
	cmd.Flags().StringVar(&opts.period, "period", "", `Duration over which Atlas reports the metrics. This parameter expresses its value in the ISO 8601 duration format in UTC. Include this parameter when you do not set **start** and **end**.`)
	cmd.Flags().StringVar(&opts.start, "start", "", `Date and time when MongoDB Cloud begins reporting the metrics. This parameter expresses its value in the ISO 8601 timestamp format in UTC. Include this parameter when you do not set **period**.`)
	cmd.Flags().StringVar(&opts.end, "end", "", `Date and time when MongoDB Cloud stops reporting the metrics. This parameter expresses its value in the ISO 8601 timestamp format in UTC. Include this parameter when you do not set **period**.`)

	_ = cmd.MarkFlagRequired("processId")
	_ = cmd.MarkFlagRequired("indexName")
	_ = cmd.MarkFlagRequired("databaseName")
	_ = cmd.MarkFlagRequired("collectionName")
	_ = cmd.MarkFlagRequired("granularity")
	_ = cmd.MarkFlagRequired("metrics")
	cmd.Flags().StringVar(&opts.format, "format", "", "Format of the output")
	return cmd
}

type getMeasurementsOpts struct {
	client      *admin.APIClient
	processId   string
	groupId     string
	granularity string
	metrics     []string
	period      string
	start       string
	end         string
	format      string
	tmpl        *template.Template
	resp        *admin.MeasurementsNonIndex
}

func (opts *getMeasurementsOpts) preRun() (err error) {
	if opts.client, err = newClientWithAuth(config.UserAgent, config.Default()); err != nil {
		return err
	}

	if opts.groupId == "" {
		opts.groupId = config.ProjectID()
	}
	if opts.groupId == "" {
		return errors.New(`required flag(s) "projectId" not set`)
	}
	b, errDecode := hex.DecodeString(opts.groupId)
	if errDecode != nil || len(b) != 12 {
		return fmt.Errorf("the provided value '%s' is not a valid ID", opts.groupId)
	}

	if opts.format != "" {
		if opts.tmpl, err = template.New("").Parse(strings.ReplaceAll(opts.format, "\\n", "\n") + "\n"); err != nil {
			return err
		}
	}

	return nil
}

func (opts *getMeasurementsOpts) run(ctx context.Context, _ io.Reader) error {

	var start *time.Time
	var errStart error
	if opts.start != "" {
		*start, errStart = time.Parse(time.RFC3339, opts.start)
		if errStart != nil {
			return errStart
		}
	}

	var end *time.Time
	var errEnd error
	if opts.end != "" {
		*end, errEnd = time.Parse(time.RFC3339, opts.end)
		if errEnd != nil {
			return errEnd
		}
	}

	params := &admin.GetMeasurementsApiParams{
		ProcessId:   opts.processId,
		GroupId:     opts.groupId,
		Granularity: &opts.granularity,
		Metrics:     &opts.metrics,
		Period:      &opts.period,
		Start:       start,
		End:         end,
	}

	var err error
	opts.resp, _, err = opts.client.MonitoringAndLogsApi.GetMeasurementsWithParams(ctx, params).Execute()
	return err
}

func (opts *getMeasurementsOpts) postRun(_ context.Context, w io.Writer) error {

	prettyJSON, errJson := json.MarshalIndent(opts.resp, "", " ")
	if errJson != nil {
		return errJson
	}

	if opts.format == "" {
		_, err := fmt.Fprintln(w, string(prettyJSON))
		return err
	}

	var parsedJSON interface{}
	if err := json.Unmarshal([]byte(prettyJSON), &parsedJSON); err != nil {
		return err
	}

	return opts.tmpl.Execute(w, parsedJSON)
}

func getMeasurementsBuilder() *cobra.Command {
	opts := getMeasurementsOpts{}
	cmd := &cobra.Command{
		Use:   "getMeasurements",
		Short: "Return Atlas Search Hardware and Status Metrics",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.preRun()
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.run(cmd.Context(), cmd.InOrStdin())
		},
		PostRunE: func(cmd *cobra.Command, args []string) error {
			return opts.postRun(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.processId, "processId", "", `Combination of hostname and IANA port that serves the MongoDB process. The host must be the hostname, fully qualified domain name (FQDN), or Internet Protocol address (IPv4 or IPv6) of the host that runs the MongoDB process (mongod or mongos). The port must be the IANA port on which the MongoDB process listens for requests.`)
	cmd.Flags().StringVar(&opts.groupId, "projectId", "", `Unique 24-hexadecimal digit string that identifies your project.`)
	cmd.Flags().StringVar(&opts.granularity, "granularity", "", `Duration that specifies the interval at which Atlas reports the metrics. This parameter expresses its value in the ISO 8601 duration format in UTC.`)
	cmd.Flags().StringSliceVar(&opts.metrics, "metrics", nil, `List that contains the metrics that you want MongoDB Atlas to report for the associated data series. If you don&#39;t set this parameter, this resource returns all hardware and status metrics for the associated data series.`)
	cmd.Flags().StringVar(&opts.period, "period", "", `Duration over which Atlas reports the metrics. This parameter expresses its value in the ISO 8601 duration format in UTC. Include this parameter when you do not set **start** and **end**.`)
	cmd.Flags().StringVar(&opts.start, "start", "", `Date and time when MongoDB Cloud begins reporting the metrics. This parameter expresses its value in the ISO 8601 timestamp format in UTC. Include this parameter when you do not set **period**.`)
	cmd.Flags().StringVar(&opts.end, "end", "", `Date and time when MongoDB Cloud stops reporting the metrics. This parameter expresses its value in the ISO 8601 timestamp format in UTC. Include this parameter when you do not set **period**.`)

	_ = cmd.MarkFlagRequired("processId")
	_ = cmd.MarkFlagRequired("granularity")
	_ = cmd.MarkFlagRequired("metrics")
	cmd.Flags().StringVar(&opts.format, "format", "", "Format of the output")
	return cmd
}

type listAtlasProcessesOpts struct {
	client       *admin.APIClient
	groupId      string
	includeCount bool
	itemsPerPage int
	pageNum      int
	format       string
	tmpl         *template.Template
	resp         *admin.PaginatedHostViewAtlas
}

func (opts *listAtlasProcessesOpts) preRun() (err error) {
	if opts.client, err = newClientWithAuth(config.UserAgent, config.Default()); err != nil {
		return err
	}

	if opts.groupId == "" {
		opts.groupId = config.ProjectID()
	}
	if opts.groupId == "" {
		return errors.New(`required flag(s) "projectId" not set`)
	}
	b, errDecode := hex.DecodeString(opts.groupId)
	if errDecode != nil || len(b) != 12 {
		return fmt.Errorf("the provided value '%s' is not a valid ID", opts.groupId)
	}

	if opts.format != "" {
		if opts.tmpl, err = template.New("").Parse(strings.ReplaceAll(opts.format, "\\n", "\n") + "\n"); err != nil {
			return err
		}
	}

	return nil
}

func (opts *listAtlasProcessesOpts) run(ctx context.Context, _ io.Reader) error {

	params := &admin.ListAtlasProcessesApiParams{
		GroupId:      opts.groupId,
		IncludeCount: &opts.includeCount,
		ItemsPerPage: &opts.itemsPerPage,
		PageNum:      &opts.pageNum,
	}

	var err error
	opts.resp, _, err = opts.client.MonitoringAndLogsApi.ListAtlasProcessesWithParams(ctx, params).Execute()
	return err
}

func (opts *listAtlasProcessesOpts) postRun(_ context.Context, w io.Writer) error {

	prettyJSON, errJson := json.MarshalIndent(opts.resp, "", " ")
	if errJson != nil {
		return errJson
	}

	if opts.format == "" {
		_, err := fmt.Fprintln(w, string(prettyJSON))
		return err
	}

	var parsedJSON interface{}
	if err := json.Unmarshal([]byte(prettyJSON), &parsedJSON); err != nil {
		return err
	}

	return opts.tmpl.Execute(w, parsedJSON)
}

func listAtlasProcessesBuilder() *cobra.Command {
	opts := listAtlasProcessesOpts{}
	cmd := &cobra.Command{
		Use:   "listAtlasProcesses",
		Short: "Return All MongoDB Processes in One Project",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.preRun()
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.run(cmd.Context(), cmd.InOrStdin())
		},
		PostRunE: func(cmd *cobra.Command, args []string) error {
			return opts.postRun(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "projectId", "", `Unique 24-hexadecimal digit string that identifies your project.`)
	cmd.Flags().BoolVar(&opts.includeCount, "includeCount", true, `Flag that indicates whether the response returns the total number of items (**totalCount**) in the response.`)
	cmd.Flags().IntVar(&opts.itemsPerPage, "itemsPerPage", 100, `Number of items that the response returns per page.`)
	cmd.Flags().IntVar(&opts.pageNum, "pageNum", 1, `Number of the page that displays the current set of the total objects that the response returns.`)

	cmd.Flags().StringVar(&opts.format, "format", "", "Format of the output")
	return cmd
}

type listDatabasesOpts struct {
	client       *admin.APIClient
	groupId      string
	processId    string
	includeCount bool
	itemsPerPage int
	pageNum      int
	format       string
	tmpl         *template.Template
	resp         *admin.PaginatedDatabase
}

func (opts *listDatabasesOpts) preRun() (err error) {
	if opts.client, err = newClientWithAuth(config.UserAgent, config.Default()); err != nil {
		return err
	}

	if opts.groupId == "" {
		opts.groupId = config.ProjectID()
	}
	if opts.groupId == "" {
		return errors.New(`required flag(s) "projectId" not set`)
	}
	b, errDecode := hex.DecodeString(opts.groupId)
	if errDecode != nil || len(b) != 12 {
		return fmt.Errorf("the provided value '%s' is not a valid ID", opts.groupId)
	}

	if opts.format != "" {
		if opts.tmpl, err = template.New("").Parse(strings.ReplaceAll(opts.format, "\\n", "\n") + "\n"); err != nil {
			return err
		}
	}

	return nil
}

func (opts *listDatabasesOpts) run(ctx context.Context, _ io.Reader) error {

	params := &admin.ListDatabasesApiParams{
		GroupId:      opts.groupId,
		ProcessId:    opts.processId,
		IncludeCount: &opts.includeCount,
		ItemsPerPage: &opts.itemsPerPage,
		PageNum:      &opts.pageNum,
	}

	var err error
	opts.resp, _, err = opts.client.MonitoringAndLogsApi.ListDatabasesWithParams(ctx, params).Execute()
	return err
}

func (opts *listDatabasesOpts) postRun(_ context.Context, w io.Writer) error {

	prettyJSON, errJson := json.MarshalIndent(opts.resp, "", " ")
	if errJson != nil {
		return errJson
	}

	if opts.format == "" {
		_, err := fmt.Fprintln(w, string(prettyJSON))
		return err
	}

	var parsedJSON interface{}
	if err := json.Unmarshal([]byte(prettyJSON), &parsedJSON); err != nil {
		return err
	}

	return opts.tmpl.Execute(w, parsedJSON)
}

func listDatabasesBuilder() *cobra.Command {
	opts := listDatabasesOpts{}
	cmd := &cobra.Command{
		Use:   "listDatabases",
		Short: "Return Available Databases for One MongoDB Process",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.preRun()
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.run(cmd.Context(), cmd.InOrStdin())
		},
		PostRunE: func(cmd *cobra.Command, args []string) error {
			return opts.postRun(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "projectId", "", `Unique 24-hexadecimal digit string that identifies your project.`)
	cmd.Flags().StringVar(&opts.processId, "processId", "", `Combination of hostname and Internet Assigned Numbers Authority (IANA) port that serves the MongoDB process. The host must be the hostname, fully qualified domain name (FQDN), or Internet Protocol address (IPv4 or IPv6) of the host that runs the MongoDB process (&#x60;mongod&#x60;). The port must be the IANA port on which the MongoDB process listens for requests.`)
	cmd.Flags().BoolVar(&opts.includeCount, "includeCount", true, `Flag that indicates whether the response returns the total number of items (**totalCount**) in the response.`)
	cmd.Flags().IntVar(&opts.itemsPerPage, "itemsPerPage", 100, `Number of items that the response returns per page.`)
	cmd.Flags().IntVar(&opts.pageNum, "pageNum", 1, `Number of the page that displays the current set of the total objects that the response returns.`)

	_ = cmd.MarkFlagRequired("processId")
	cmd.Flags().StringVar(&opts.format, "format", "", "Format of the output")
	return cmd
}

type listDiskMeasurementsOpts struct {
	client        *admin.APIClient
	partitionName string
	groupId       string
	processId     string
	format        string
	tmpl          *template.Template
	resp          *admin.MeasurementDiskPartition
}

func (opts *listDiskMeasurementsOpts) preRun() (err error) {
	if opts.client, err = newClientWithAuth(config.UserAgent, config.Default()); err != nil {
		return err
	}

	if opts.groupId == "" {
		opts.groupId = config.ProjectID()
	}
	if opts.groupId == "" {
		return errors.New(`required flag(s) "projectId" not set`)
	}
	b, errDecode := hex.DecodeString(opts.groupId)
	if errDecode != nil || len(b) != 12 {
		return fmt.Errorf("the provided value '%s' is not a valid ID", opts.groupId)
	}

	if opts.format != "" {
		if opts.tmpl, err = template.New("").Parse(strings.ReplaceAll(opts.format, "\\n", "\n") + "\n"); err != nil {
			return err
		}
	}

	return nil
}

func (opts *listDiskMeasurementsOpts) run(ctx context.Context, _ io.Reader) error {

	params := &admin.ListDiskMeasurementsApiParams{
		PartitionName: opts.partitionName,
		GroupId:       opts.groupId,
		ProcessId:     opts.processId,
	}

	var err error
	opts.resp, _, err = opts.client.MonitoringAndLogsApi.ListDiskMeasurementsWithParams(ctx, params).Execute()
	return err
}

func (opts *listDiskMeasurementsOpts) postRun(_ context.Context, w io.Writer) error {

	prettyJSON, errJson := json.MarshalIndent(opts.resp, "", " ")
	if errJson != nil {
		return errJson
	}

	if opts.format == "" {
		_, err := fmt.Fprintln(w, string(prettyJSON))
		return err
	}

	var parsedJSON interface{}
	if err := json.Unmarshal([]byte(prettyJSON), &parsedJSON); err != nil {
		return err
	}

	return opts.tmpl.Execute(w, parsedJSON)
}

func listDiskMeasurementsBuilder() *cobra.Command {
	opts := listDiskMeasurementsOpts{}
	cmd := &cobra.Command{
		Use:   "listDiskMeasurements",
		Short: "Return Measurements of One Disk",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.preRun()
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.run(cmd.Context(), cmd.InOrStdin())
		},
		PostRunE: func(cmd *cobra.Command, args []string) error {
			return opts.postRun(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.partitionName, "partitionName", "", `Human-readable label of the disk or partition to which the measurements apply.`)
	cmd.Flags().StringVar(&opts.groupId, "projectId", "", `Unique 24-hexadecimal digit string that identifies your project.`)
	cmd.Flags().StringVar(&opts.processId, "processId", "", `Combination of hostname and Internet Assigned Numbers Authority (IANA) port that serves the MongoDB process. The host must be the hostname, fully qualified domain name (FQDN), or Internet Protocol address (IPv4 or IPv6) of the host that runs the MongoDB process (&#x60;mongod&#x60; or &#x60;mongos&#x60;). The port must be the IANA port on which the MongoDB process listens for requests.`)

	_ = cmd.MarkFlagRequired("partitionName")
	_ = cmd.MarkFlagRequired("processId")
	cmd.Flags().StringVar(&opts.format, "format", "", "Format of the output")
	return cmd
}

type listDiskPartitionsOpts struct {
	client       *admin.APIClient
	groupId      string
	processId    string
	includeCount bool
	itemsPerPage int
	pageNum      int
	format       string
	tmpl         *template.Template
	resp         *admin.PaginatedDiskPartition
}

func (opts *listDiskPartitionsOpts) preRun() (err error) {
	if opts.client, err = newClientWithAuth(config.UserAgent, config.Default()); err != nil {
		return err
	}

	if opts.groupId == "" {
		opts.groupId = config.ProjectID()
	}
	if opts.groupId == "" {
		return errors.New(`required flag(s) "projectId" not set`)
	}
	b, errDecode := hex.DecodeString(opts.groupId)
	if errDecode != nil || len(b) != 12 {
		return fmt.Errorf("the provided value '%s' is not a valid ID", opts.groupId)
	}

	if opts.format != "" {
		if opts.tmpl, err = template.New("").Parse(strings.ReplaceAll(opts.format, "\\n", "\n") + "\n"); err != nil {
			return err
		}
	}

	return nil
}

func (opts *listDiskPartitionsOpts) run(ctx context.Context, _ io.Reader) error {

	params := &admin.ListDiskPartitionsApiParams{
		GroupId:      opts.groupId,
		ProcessId:    opts.processId,
		IncludeCount: &opts.includeCount,
		ItemsPerPage: &opts.itemsPerPage,
		PageNum:      &opts.pageNum,
	}

	var err error
	opts.resp, _, err = opts.client.MonitoringAndLogsApi.ListDiskPartitionsWithParams(ctx, params).Execute()
	return err
}

func (opts *listDiskPartitionsOpts) postRun(_ context.Context, w io.Writer) error {

	prettyJSON, errJson := json.MarshalIndent(opts.resp, "", " ")
	if errJson != nil {
		return errJson
	}

	if opts.format == "" {
		_, err := fmt.Fprintln(w, string(prettyJSON))
		return err
	}

	var parsedJSON interface{}
	if err := json.Unmarshal([]byte(prettyJSON), &parsedJSON); err != nil {
		return err
	}

	return opts.tmpl.Execute(w, parsedJSON)
}

func listDiskPartitionsBuilder() *cobra.Command {
	opts := listDiskPartitionsOpts{}
	cmd := &cobra.Command{
		Use:   "listDiskPartitions",
		Short: "Return Available Disks for One MongoDB Process",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.preRun()
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.run(cmd.Context(), cmd.InOrStdin())
		},
		PostRunE: func(cmd *cobra.Command, args []string) error {
			return opts.postRun(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "projectId", "", `Unique 24-hexadecimal digit string that identifies your project.`)
	cmd.Flags().StringVar(&opts.processId, "processId", "", `Combination of hostname and Internet Assigned Numbers Authority (IANA) port that serves the MongoDB process. The host must be the hostname, fully qualified domain name (FQDN), or Internet Protocol address (IPv4 or IPv6) of the host that runs the MongoDB process (&#x60;mongod&#x60; or &#x60;mongos&#x60;). The port must be the IANA port on which the MongoDB process listens for requests.`)
	cmd.Flags().BoolVar(&opts.includeCount, "includeCount", true, `Flag that indicates whether the response returns the total number of items (**totalCount**) in the response.`)
	cmd.Flags().IntVar(&opts.itemsPerPage, "itemsPerPage", 100, `Number of items that the response returns per page.`)
	cmd.Flags().IntVar(&opts.pageNum, "pageNum", 1, `Number of the page that displays the current set of the total objects that the response returns.`)

	_ = cmd.MarkFlagRequired("processId")
	cmd.Flags().StringVar(&opts.format, "format", "", "Format of the output")
	return cmd
}

type listIndexMetricsOpts struct {
	client         *admin.APIClient
	processId      string
	databaseName   string
	collectionName string
	groupId        string
	granularity    string
	metrics        []string
	period         string
	start          string
	end            string
	format         string
	tmpl           *template.Template
	resp           *admin.MeasurementsIndexes
}

func (opts *listIndexMetricsOpts) preRun() (err error) {
	if opts.client, err = newClientWithAuth(config.UserAgent, config.Default()); err != nil {
		return err
	}

	if opts.groupId == "" {
		opts.groupId = config.ProjectID()
	}
	if opts.groupId == "" {
		return errors.New(`required flag(s) "projectId" not set`)
	}
	b, errDecode := hex.DecodeString(opts.groupId)
	if errDecode != nil || len(b) != 12 {
		return fmt.Errorf("the provided value '%s' is not a valid ID", opts.groupId)
	}

	if opts.format != "" {
		if opts.tmpl, err = template.New("").Parse(strings.ReplaceAll(opts.format, "\\n", "\n") + "\n"); err != nil {
			return err
		}
	}

	return nil
}

func (opts *listIndexMetricsOpts) run(ctx context.Context, _ io.Reader) error {

	var start *time.Time
	var errStart error
	if opts.start != "" {
		*start, errStart = time.Parse(time.RFC3339, opts.start)
		if errStart != nil {
			return errStart
		}
	}

	var end *time.Time
	var errEnd error
	if opts.end != "" {
		*end, errEnd = time.Parse(time.RFC3339, opts.end)
		if errEnd != nil {
			return errEnd
		}
	}

	params := &admin.ListIndexMetricsApiParams{
		ProcessId:      opts.processId,
		DatabaseName:   opts.databaseName,
		CollectionName: opts.collectionName,
		GroupId:        opts.groupId,
		Granularity:    &opts.granularity,
		Metrics:        &opts.metrics,
		Period:         &opts.period,
		Start:          start,
		End:            end,
	}

	var err error
	opts.resp, _, err = opts.client.MonitoringAndLogsApi.ListIndexMetricsWithParams(ctx, params).Execute()
	return err
}

func (opts *listIndexMetricsOpts) postRun(_ context.Context, w io.Writer) error {

	prettyJSON, errJson := json.MarshalIndent(opts.resp, "", " ")
	if errJson != nil {
		return errJson
	}

	if opts.format == "" {
		_, err := fmt.Fprintln(w, string(prettyJSON))
		return err
	}

	var parsedJSON interface{}
	if err := json.Unmarshal([]byte(prettyJSON), &parsedJSON); err != nil {
		return err
	}

	return opts.tmpl.Execute(w, parsedJSON)
}

func listIndexMetricsBuilder() *cobra.Command {
	opts := listIndexMetricsOpts{}
	cmd := &cobra.Command{
		Use:   "listIndexMetrics",
		Short: "Return All Atlas Search Index Metrics for One Namespace",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.preRun()
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.run(cmd.Context(), cmd.InOrStdin())
		},
		PostRunE: func(cmd *cobra.Command, args []string) error {
			return opts.postRun(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.processId, "processId", "", `Combination of hostname and IANA port that serves the MongoDB process. The host must be the hostname, fully qualified domain name (FQDN), or Internet Protocol address (IPv4 or IPv6) of the host that runs the MongoDB process (mongod or mongos). The port must be the IANA port on which the MongoDB process listens for requests.`)
	cmd.Flags().StringVar(&opts.databaseName, "databaseName", "", `Human-readable label that identifies the database.`)
	cmd.Flags().StringVar(&opts.collectionName, "collectionName", "", `Human-readable label that identifies the collection.`)
	cmd.Flags().StringVar(&opts.groupId, "projectId", "", `Unique 24-hexadecimal digit string that identifies your project.`)
	cmd.Flags().StringVar(&opts.granularity, "granularity", "", `Duration that specifies the interval at which Atlas reports the metrics. This parameter expresses its value in the ISO 8601 duration format in UTC.`)
	cmd.Flags().StringSliceVar(&opts.metrics, "metrics", nil, `List that contains the measurements that MongoDB Atlas reports for the associated data series.`)
	cmd.Flags().StringVar(&opts.period, "period", "", `Duration over which Atlas reports the metrics. This parameter expresses its value in the ISO 8601 duration format in UTC. Include this parameter when you do not set **start** and **end**.`)
	cmd.Flags().StringVar(&opts.start, "start", "", `Date and time when MongoDB Cloud begins reporting the metrics. This parameter expresses its value in the ISO 8601 timestamp format in UTC. Include this parameter when you do not set **period**.`)
	cmd.Flags().StringVar(&opts.end, "end", "", `Date and time when MongoDB Cloud stops reporting the metrics. This parameter expresses its value in the ISO 8601 timestamp format in UTC. Include this parameter when you do not set **period**.`)

	_ = cmd.MarkFlagRequired("processId")
	_ = cmd.MarkFlagRequired("databaseName")
	_ = cmd.MarkFlagRequired("collectionName")
	_ = cmd.MarkFlagRequired("granularity")
	_ = cmd.MarkFlagRequired("metrics")
	cmd.Flags().StringVar(&opts.format, "format", "", "Format of the output")
	return cmd
}

type listMetricTypesOpts struct {
	client    *admin.APIClient
	processId string
	groupId   string
	format    string
	tmpl      *template.Template
	resp      *admin.CloudSearchMetrics
}

func (opts *listMetricTypesOpts) preRun() (err error) {
	if opts.client, err = newClientWithAuth(config.UserAgent, config.Default()); err != nil {
		return err
	}

	if opts.groupId == "" {
		opts.groupId = config.ProjectID()
	}
	if opts.groupId == "" {
		return errors.New(`required flag(s) "projectId" not set`)
	}
	b, errDecode := hex.DecodeString(opts.groupId)
	if errDecode != nil || len(b) != 12 {
		return fmt.Errorf("the provided value '%s' is not a valid ID", opts.groupId)
	}

	if opts.format != "" {
		if opts.tmpl, err = template.New("").Parse(strings.ReplaceAll(opts.format, "\\n", "\n") + "\n"); err != nil {
			return err
		}
	}

	return nil
}

func (opts *listMetricTypesOpts) run(ctx context.Context, _ io.Reader) error {

	params := &admin.ListMetricTypesApiParams{
		ProcessId: opts.processId,
		GroupId:   opts.groupId,
	}

	var err error
	opts.resp, _, err = opts.client.MonitoringAndLogsApi.ListMetricTypesWithParams(ctx, params).Execute()
	return err
}

func (opts *listMetricTypesOpts) postRun(_ context.Context, w io.Writer) error {

	prettyJSON, errJson := json.MarshalIndent(opts.resp, "", " ")
	if errJson != nil {
		return errJson
	}

	if opts.format == "" {
		_, err := fmt.Fprintln(w, string(prettyJSON))
		return err
	}

	var parsedJSON interface{}
	if err := json.Unmarshal([]byte(prettyJSON), &parsedJSON); err != nil {
		return err
	}

	return opts.tmpl.Execute(w, parsedJSON)
}

func listMetricTypesBuilder() *cobra.Command {
	opts := listMetricTypesOpts{}
	cmd := &cobra.Command{
		Use:   "listMetricTypes",
		Short: "Return All Atlas Search Metric Types for One Process",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.preRun()
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.run(cmd.Context(), cmd.InOrStdin())
		},
		PostRunE: func(cmd *cobra.Command, args []string) error {
			return opts.postRun(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.processId, "processId", "", `Combination of hostname and IANA port that serves the MongoDB process. The host must be the hostname, fully qualified domain name (FQDN), or Internet Protocol address (IPv4 or IPv6) of the host that runs the MongoDB process (mongod or mongos). The port must be the IANA port on which the MongoDB process listens for requests.`)
	cmd.Flags().StringVar(&opts.groupId, "projectId", "", `Unique 24-hexadecimal digit string that identifies your project.`)

	_ = cmd.MarkFlagRequired("processId")
	cmd.Flags().StringVar(&opts.format, "format", "", "Format of the output")
	return cmd
}

func monitoringAndLogsBuilder() *cobra.Command {
	cmd := &cobra.Command{
		Use:   "monitoringAndLogs",
		Short: `Returns database deployment monitoring and logging data.`,
	}
	cmd.AddCommand(
		getAtlasProcessBuilder(),
		getDatabaseBuilder(),
		getDatabaseMeasurementsBuilder(),
		getDiskMeasurementsBuilder(),
		getHostLogsBuilder(),
		getHostMeasurementsBuilder(),
		getIndexMetricsBuilder(),
		getMeasurementsBuilder(),
		listAtlasProcessesBuilder(),
		listDatabasesBuilder(),
		listDiskMeasurementsBuilder(),
		listDiskPartitionsBuilder(),
		listIndexMetricsBuilder(),
		listMetricTypesBuilder(),
	)
	return cmd
}
