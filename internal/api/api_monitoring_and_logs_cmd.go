// Copyright 2023 MongoDB Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"context"
	"io"

	"github.com/mongodb/mongodb-atlas-cli/internal/cli"
	"github.com/mongodb/mongodb-atlas-cli/internal/flag"
	"github.com/mongodb/mongodb-atlas-cli/internal/jsonwriter"
	"github.com/mongodb/mongodb-atlas-cli/internal/usage"
	"github.com/spf13/cobra"
	"go.mongodb.org/atlas-sdk/v20230201008/admin"
)

type getAtlasProcessOpts struct {
	cli.GlobalOpts
	cli.OutputOpts
	client    *admin.APIClient
	groupId   string
	processId string
}

func (opts *getAtlasProcessOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *getAtlasProcessOpts) Run(ctx context.Context, w io.Writer) error {
	params := &admin.GetAtlasProcessApiParams{
		GroupId:   opts.groupId,
		ProcessId: opts.processId,
	}
	resp, _, err := opts.client.MonitoringAndLogsApi.GetAtlasProcessWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return jsonwriter.Print(w, resp)
}

func getAtlasProcessBuilder() *cobra.Command {
	opts := getAtlasProcessOpts{}
	cmd := &cobra.Command{
		Use:   "getAtlasProcess",
		Short: "Return One MongoDB Process by ID",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)
	cmd.Flags().StringVar(&opts.processId, "processId", "", `Combination of hostname and Internet Assigned Numbers Authority (IANA) port that serves the MongoDB process. The host must be the hostname, fully qualified domain name (FQDN), or Internet Protocol address (IPv4 or IPv6) of the host that runs the MongoDB process (&#x60;mongod&#x60; or &#x60;mongos&#x60;). The port must be the IANA port on which the MongoDB process listens for requests.`)

	cmd.Flags().StringVarP(&opts.Output, flag.Output, flag.OutputShort, "", usage.FormatOut)
	_ = cmd.RegisterFlagCompletionFunc(flag.Output, opts.AutoCompleteOutputFlag())

	_ = cmd.MarkFlagRequired("groupId")
	_ = cmd.MarkFlagRequired("processId")
	return cmd
}

type getDatabaseOpts struct {
	cli.GlobalOpts
	cli.OutputOpts
	client       *admin.APIClient
	groupId      string
	databaseName string
	processId    string
}

func (opts *getDatabaseOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *getDatabaseOpts) Run(ctx context.Context, w io.Writer) error {
	params := &admin.GetDatabaseApiParams{
		GroupId:      opts.groupId,
		DatabaseName: opts.databaseName,
		ProcessId:    opts.processId,
	}
	resp, _, err := opts.client.MonitoringAndLogsApi.GetDatabaseWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return jsonwriter.Print(w, resp)
}

func getDatabaseBuilder() *cobra.Command {
	opts := getDatabaseOpts{}
	cmd := &cobra.Command{
		Use:   "getDatabase",
		Short: "Return One Database for a MongoDB Process",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)
	cmd.Flags().StringVar(&opts.databaseName, "databaseName", "", `Human-readable label that identifies the database that the specified MongoDB process serves.`)
	cmd.Flags().StringVar(&opts.processId, "processId", "", `Combination of hostname and Internet Assigned Numbers Authority (IANA) port that serves the MongoDB process. The host must be the hostname, fully qualified domain name (FQDN), or Internet Protocol address (IPv4 or IPv6) of the host that runs the MongoDB process (&#x60;mongod&#x60; or &#x60;mongos&#x60;). The port must be the IANA port on which the MongoDB process listens for requests.`)

	cmd.Flags().StringVarP(&opts.Output, flag.Output, flag.OutputShort, "", usage.FormatOut)
	_ = cmd.RegisterFlagCompletionFunc(flag.Output, opts.AutoCompleteOutputFlag())

	_ = cmd.MarkFlagRequired("groupId")
	_ = cmd.MarkFlagRequired("databaseName")
	_ = cmd.MarkFlagRequired("processId")
	return cmd
}

type getDatabaseMeasurementsOpts struct {
	cli.GlobalOpts
	cli.OutputOpts
	client       *admin.APIClient
	groupId      string
	databaseName string
	processId    string
	granularity  string
	m            []string
	period       string
	start        string
	end          string
}

func (opts *getDatabaseMeasurementsOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *getDatabaseMeasurementsOpts) Run(ctx context.Context, w io.Writer) error {
	params := &admin.GetDatabaseMeasurementsApiParams{
		GroupId:      opts.groupId,
		DatabaseName: opts.databaseName,
		ProcessId:    opts.processId,
		Granularity:  &opts.granularity,
		M:            &opts.m,
		Period:       &opts.period,
		Start:        convertTime(&opts.start),
		End:          convertTime(&opts.end),
	}
	resp, _, err := opts.client.MonitoringAndLogsApi.GetDatabaseMeasurementsWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return jsonwriter.Print(w, resp)
}

func getDatabaseMeasurementsBuilder() *cobra.Command {
	opts := getDatabaseMeasurementsOpts{}
	cmd := &cobra.Command{
		Use:   "getDatabaseMeasurements",
		Short: "Return Measurements of One Database for One MongoDB Process",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)
	cmd.Flags().StringVar(&opts.databaseName, "databaseName", "", `Human-readable label that identifies the database that the specified MongoDB process serves.`)
	cmd.Flags().StringVar(&opts.processId, "processId", "", `Combination of hostname and Internet Assigned Numbers Authority (IANA) port that serves the MongoDB process. The host must be the hostname, fully qualified domain name (FQDN), or Internet Protocol address (IPv4 or IPv6) of the host that runs the MongoDB process (&#x60;mongod&#x60; or &#x60;mongos&#x60;). The port must be the IANA port on which the MongoDB process listens for requests.`)
	cmd.Flags().StringVar(&opts.granularity, "granularity", "", `Duration that specifies the interval at which Atlas reports the metrics. This parameter expresses its value in the ISO 8601 duration format in UTC.`)
	cmd.Flags().StringSliceVar(&opts.m, "m", nil, `One or more types of measurement to request for this MongoDB process. If omitted, the resource returns all measurements. To specify multiple values for &#x60;m&#x60;, repeat the &#x60;m&#x60; parameter for each value. Specify measurements that apply to the specified host. MongoDB Cloud returns an error if you specified any invalid measurements.`)
	cmd.Flags().StringVar(&opts.period, "period", "", `Duration over which Atlas reports the metrics. This parameter expresses its value in the ISO 8601 duration format in UTC. Include this parameter when you do not set **start** and **end**.`)
	cmd.Flags().StringVar(&opts.start, "start", "", `Date and time when MongoDB Cloud begins reporting the metrics. This parameter expresses its value in the ISO 8601 timestamp format in UTC. Include this parameter when you do not set **period**.`)
	cmd.Flags().StringVar(&opts.end, "end", "", `Date and time when MongoDB Cloud stops reporting the metrics. This parameter expresses its value in the ISO 8601 timestamp format in UTC. Include this parameter when you do not set **period**.`)

	cmd.Flags().StringVarP(&opts.Output, flag.Output, flag.OutputShort, "", usage.FormatOut)
	_ = cmd.RegisterFlagCompletionFunc(flag.Output, opts.AutoCompleteOutputFlag())

	_ = cmd.MarkFlagRequired("groupId")
	_ = cmd.MarkFlagRequired("databaseName")
	_ = cmd.MarkFlagRequired("processId")
	_ = cmd.MarkFlagRequired("granularity")
	return cmd
}

type getDiskMeasurementsOpts struct {
	cli.GlobalOpts
	cli.OutputOpts
	client        *admin.APIClient
	groupId       string
	partitionName string
	processId     string
	granularity   string
	m             []string
	period        string
	start         string
	end           string
}

func (opts *getDiskMeasurementsOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *getDiskMeasurementsOpts) Run(ctx context.Context, w io.Writer) error {
	params := &admin.GetDiskMeasurementsApiParams{
		GroupId:       opts.groupId,
		PartitionName: opts.partitionName,
		ProcessId:     opts.processId,
		Granularity:   &opts.granularity,
		M:             &opts.m,
		Period:        &opts.period,
		Start:         convertTime(&opts.start),
		End:           convertTime(&opts.end),
	}
	resp, _, err := opts.client.MonitoringAndLogsApi.GetDiskMeasurementsWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return jsonwriter.Print(w, resp)
}

func getDiskMeasurementsBuilder() *cobra.Command {
	opts := getDiskMeasurementsOpts{}
	cmd := &cobra.Command{
		Use:   "getDiskMeasurements",
		Short: "Return Measurements of One Disk for One MongoDB Process",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)
	cmd.Flags().StringVar(&opts.partitionName, "partitionName", "", `Human-readable label of the disk or partition to which the measurements apply.`)
	cmd.Flags().StringVar(&opts.processId, "processId", "", `Combination of hostname and Internet Assigned Numbers Authority (IANA) port that serves the MongoDB process. The host must be the hostname, fully qualified domain name (FQDN), or Internet Protocol address (IPv4 or IPv6) of the host that runs the MongoDB process (&#x60;mongod&#x60; or &#x60;mongos&#x60;). The port must be the IANA port on which the MongoDB process listens for requests.`)
	cmd.Flags().StringVar(&opts.granularity, "granularity", "", `Duration that specifies the interval at which Atlas reports the metrics. This parameter expresses its value in the ISO 8601 duration format in UTC.`)
	cmd.Flags().StringSliceVar(&opts.m, "m", nil, `One or more types of measurement to request for this MongoDB process. If omitted, the resource returns all measurements. To specify multiple values for &#x60;m&#x60;, repeat the &#x60;m&#x60; parameter for each value. Specify measurements that apply to the specified host. MongoDB Cloud returns an error if you specified any invalid measurements.`)
	cmd.Flags().StringVar(&opts.period, "period", "", `Duration over which Atlas reports the metrics. This parameter expresses its value in the ISO 8601 duration format in UTC. Include this parameter when you do not set **start** and **end**.`)
	cmd.Flags().StringVar(&opts.start, "start", "", `Date and time when MongoDB Cloud begins reporting the metrics. This parameter expresses its value in the ISO 8601 timestamp format in UTC. Include this parameter when you do not set **period**.`)
	cmd.Flags().StringVar(&opts.end, "end", "", `Date and time when MongoDB Cloud stops reporting the metrics. This parameter expresses its value in the ISO 8601 timestamp format in UTC. Include this parameter when you do not set **period**.`)

	cmd.Flags().StringVarP(&opts.Output, flag.Output, flag.OutputShort, "", usage.FormatOut)
	_ = cmd.RegisterFlagCompletionFunc(flag.Output, opts.AutoCompleteOutputFlag())

	_ = cmd.MarkFlagRequired("groupId")
	_ = cmd.MarkFlagRequired("partitionName")
	_ = cmd.MarkFlagRequired("processId")
	_ = cmd.MarkFlagRequired("granularity")
	return cmd
}

type getHostLogsOpts struct {
	cli.GlobalOpts
	cli.OutputOpts
	client    *admin.APIClient
	groupId   string
	hostName  string
	logName   string
	endDate   int64
	startDate int64
}

func (opts *getHostLogsOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *getHostLogsOpts) Run(ctx context.Context, w io.Writer) error {
	params := &admin.GetHostLogsApiParams{
		GroupId:   opts.groupId,
		HostName:  opts.hostName,
		LogName:   opts.logName,
		EndDate:   &opts.endDate,
		StartDate: &opts.startDate,
	}
	resp, _, err := opts.client.MonitoringAndLogsApi.GetHostLogsWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return jsonwriter.Print(w, resp)
}

func getHostLogsBuilder() *cobra.Command {
	opts := getHostLogsOpts{}
	cmd := &cobra.Command{
		Use:   "getHostLogs",
		Short: "Download Logs for One Multi-Cloud Cluster Host in One Project",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)
	cmd.Flags().StringVar(&opts.hostName, "hostName", "", `Fully qualified domain name or IP address of the MongoDB host that stores the log files that you want to download.`)
	cmd.Flags().StringVar(&opts.logName, "logName", "", `Human-readable label of the log file that you want to return. You can return audit logs only if you enable Database Auditing for the specified project.`)
	cmd.Flags().Int64Var(&opts.endDate, "endDate", 0, `Date and time when the period specifies the inclusive ending point for the range of log messages to retrieve. This parameter expresses its value in the number of seconds that have elapsed since the UNIX epoch.`)
	cmd.Flags().Int64Var(&opts.startDate, "startDate", 0, `Date and time when the period specifies the inclusive starting point for the range of log messages to retrieve. This parameter expresses its value in the number of seconds that have elapsed since the UNIX epoch.`)

	cmd.Flags().StringVarP(&opts.Output, flag.Output, flag.OutputShort, "", usage.FormatOut)
	_ = cmd.RegisterFlagCompletionFunc(flag.Output, opts.AutoCompleteOutputFlag())

	_ = cmd.MarkFlagRequired("groupId")
	_ = cmd.MarkFlagRequired("hostName")
	_ = cmd.MarkFlagRequired("logName")
	return cmd
}

type getHostMeasurementsOpts struct {
	cli.GlobalOpts
	cli.OutputOpts
	client      *admin.APIClient
	groupId     string
	processId   string
	granularity string
	m           []string
	period      string
	start       string
	end         string
}

func (opts *getHostMeasurementsOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *getHostMeasurementsOpts) Run(ctx context.Context, w io.Writer) error {
	params := &admin.GetHostMeasurementsApiParams{
		GroupId:     opts.groupId,
		ProcessId:   opts.processId,
		Granularity: &opts.granularity,
		M:           &opts.m,
		Period:      &opts.period,
		Start:       convertTime(&opts.start),
		End:         convertTime(&opts.end),
	}
	resp, _, err := opts.client.MonitoringAndLogsApi.GetHostMeasurementsWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return jsonwriter.Print(w, resp)
}

func getHostMeasurementsBuilder() *cobra.Command {
	opts := getHostMeasurementsOpts{}
	cmd := &cobra.Command{
		Use:   "getHostMeasurements",
		Short: "Return Measurements for One MongoDB Process",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)
	cmd.Flags().StringVar(&opts.processId, "processId", "", `Combination of hostname and Internet Assigned Numbers Authority (IANA) port that serves the MongoDB process. The host must be the hostname, fully qualified domain name (FQDN), or Internet Protocol address (IPv4 or IPv6) of the host that runs the MongoDB process (&#x60;mongod&#x60; or &#x60;mongos&#x60;). The port must be the IANA port on which the MongoDB process listens for requests.`)
	cmd.Flags().StringVar(&opts.granularity, "granularity", "", `Duration that specifies the interval at which Atlas reports the metrics. This parameter expresses its value in the ISO 8601 duration format in UTC.`)
	cmd.Flags().StringSliceVar(&opts.m, "m", nil, `One or more types of measurement to request for this MongoDB process. If omitted, the resource returns all measurements. To specify multiple values for &#x60;m&#x60;, repeat the &#x60;m&#x60; parameter for each value. Specify measurements that apply to the specified host. MongoDB Cloud returns an error if you specified any invalid measurements.`)
	cmd.Flags().StringVar(&opts.period, "period", "", `Duration over which Atlas reports the metrics. This parameter expresses its value in the ISO 8601 duration format in UTC. Include this parameter when you do not set **start** and **end**.`)
	cmd.Flags().StringVar(&opts.start, "start", "", `Date and time when MongoDB Cloud begins reporting the metrics. This parameter expresses its value in the ISO 8601 timestamp format in UTC. Include this parameter when you do not set **period**.`)
	cmd.Flags().StringVar(&opts.end, "end", "", `Date and time when MongoDB Cloud stops reporting the metrics. This parameter expresses its value in the ISO 8601 timestamp format in UTC. Include this parameter when you do not set **period**.`)

	cmd.Flags().StringVarP(&opts.Output, flag.Output, flag.OutputShort, "", usage.FormatOut)
	_ = cmd.RegisterFlagCompletionFunc(flag.Output, opts.AutoCompleteOutputFlag())

	_ = cmd.MarkFlagRequired("groupId")
	_ = cmd.MarkFlagRequired("processId")
	_ = cmd.MarkFlagRequired("granularity")
	return cmd
}

type getIndexMetricsOpts struct {
	cli.GlobalOpts
	cli.OutputOpts
	client         *admin.APIClient
	processId      string
	indexName      string
	databaseName   string
	collectionName string
	groupId        string
	granularity    string
	metrics        []string
	period         string
	start          string
	end            string
}

func (opts *getIndexMetricsOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *getIndexMetricsOpts) Run(ctx context.Context, w io.Writer) error {
	params := &admin.GetIndexMetricsApiParams{
		ProcessId:      opts.processId,
		IndexName:      opts.indexName,
		DatabaseName:   opts.databaseName,
		CollectionName: opts.collectionName,
		GroupId:        opts.groupId,
		Granularity:    &opts.granularity,
		Metrics:        &opts.metrics,
		Period:         &opts.period,
		Start:          convertTime(&opts.start),
		End:            convertTime(&opts.end),
	}
	resp, _, err := opts.client.MonitoringAndLogsApi.GetIndexMetricsWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return jsonwriter.Print(w, resp)
}

func getIndexMetricsBuilder() *cobra.Command {
	opts := getIndexMetricsOpts{}
	cmd := &cobra.Command{
		Use:   "getIndexMetrics",
		Short: "Return Atlas Search Metrics for One Index in One Specified Namespace",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.processId, "processId", "", `Combination of hostname and IANA port that serves the MongoDB process. The host must be the hostname, fully qualified domain name (FQDN), or Internet Protocol address (IPv4 or IPv6) of the host that runs the MongoDB process (mongod or mongos). The port must be the IANA port on which the MongoDB process listens for requests.`)
	cmd.Flags().StringVar(&opts.indexName, "indexName", "", `Human-readable label that identifies the index.`)
	cmd.Flags().StringVar(&opts.databaseName, "databaseName", "", `Human-readable label that identifies the database.`)
	cmd.Flags().StringVar(&opts.collectionName, "collectionName", "", `Human-readable label that identifies the collection.`)
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)
	cmd.Flags().StringVar(&opts.granularity, "granularity", "", `Duration that specifies the interval at which Atlas reports the metrics. This parameter expresses its value in the ISO 8601 duration format in UTC.`)
	cmd.Flags().StringSliceVar(&opts.metrics, "metrics", nil, `List that contains the measurements that MongoDB Atlas reports for the associated data series.`)
	cmd.Flags().StringVar(&opts.period, "period", "", `Duration over which Atlas reports the metrics. This parameter expresses its value in the ISO 8601 duration format in UTC. Include this parameter when you do not set **start** and **end**.`)
	cmd.Flags().StringVar(&opts.start, "start", "", `Date and time when MongoDB Cloud begins reporting the metrics. This parameter expresses its value in the ISO 8601 timestamp format in UTC. Include this parameter when you do not set **period**.`)
	cmd.Flags().StringVar(&opts.end, "end", "", `Date and time when MongoDB Cloud stops reporting the metrics. This parameter expresses its value in the ISO 8601 timestamp format in UTC. Include this parameter when you do not set **period**.`)

	cmd.Flags().StringVarP(&opts.Output, flag.Output, flag.OutputShort, "", usage.FormatOut)
	_ = cmd.RegisterFlagCompletionFunc(flag.Output, opts.AutoCompleteOutputFlag())

	_ = cmd.MarkFlagRequired("processId")
	_ = cmd.MarkFlagRequired("indexName")
	_ = cmd.MarkFlagRequired("databaseName")
	_ = cmd.MarkFlagRequired("collectionName")
	_ = cmd.MarkFlagRequired("groupId")
	_ = cmd.MarkFlagRequired("granularity")
	_ = cmd.MarkFlagRequired("metrics")
	return cmd
}

type getMeasurementsOpts struct {
	cli.GlobalOpts
	cli.OutputOpts
	client      *admin.APIClient
	processId   string
	groupId     string
	granularity string
	metrics     []string
	period      string
	start       string
	end         string
}

func (opts *getMeasurementsOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *getMeasurementsOpts) Run(ctx context.Context, w io.Writer) error {
	params := &admin.GetMeasurementsApiParams{
		ProcessId:   opts.processId,
		GroupId:     opts.groupId,
		Granularity: &opts.granularity,
		Metrics:     &opts.metrics,
		Period:      &opts.period,
		Start:       convertTime(&opts.start),
		End:         convertTime(&opts.end),
	}
	resp, _, err := opts.client.MonitoringAndLogsApi.GetMeasurementsWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return jsonwriter.Print(w, resp)
}

func getMeasurementsBuilder() *cobra.Command {
	opts := getMeasurementsOpts{}
	cmd := &cobra.Command{
		Use:   "getMeasurements",
		Short: "Return Atlas Search Hardware and Status Metrics",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.processId, "processId", "", `Combination of hostname and IANA port that serves the MongoDB process. The host must be the hostname, fully qualified domain name (FQDN), or Internet Protocol address (IPv4 or IPv6) of the host that runs the MongoDB process (mongod or mongos). The port must be the IANA port on which the MongoDB process listens for requests.`)
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)
	cmd.Flags().StringVar(&opts.granularity, "granularity", "", `Duration that specifies the interval at which Atlas reports the metrics. This parameter expresses its value in the ISO 8601 duration format in UTC.`)
	cmd.Flags().StringSliceVar(&opts.metrics, "metrics", nil, `List that contains the metrics that you want MongoDB Atlas to report for the associated data series. If you don&#39;t set this parameter, this resource returns all hardware and status metrics for the associated data series.`)
	cmd.Flags().StringVar(&opts.period, "period", "", `Duration over which Atlas reports the metrics. This parameter expresses its value in the ISO 8601 duration format in UTC. Include this parameter when you do not set **start** and **end**.`)
	cmd.Flags().StringVar(&opts.start, "start", "", `Date and time when MongoDB Cloud begins reporting the metrics. This parameter expresses its value in the ISO 8601 timestamp format in UTC. Include this parameter when you do not set **period**.`)
	cmd.Flags().StringVar(&opts.end, "end", "", `Date and time when MongoDB Cloud stops reporting the metrics. This parameter expresses its value in the ISO 8601 timestamp format in UTC. Include this parameter when you do not set **period**.`)

	cmd.Flags().StringVarP(&opts.Output, flag.Output, flag.OutputShort, "", usage.FormatOut)
	_ = cmd.RegisterFlagCompletionFunc(flag.Output, opts.AutoCompleteOutputFlag())

	_ = cmd.MarkFlagRequired("processId")
	_ = cmd.MarkFlagRequired("groupId")
	_ = cmd.MarkFlagRequired("granularity")
	_ = cmd.MarkFlagRequired("metrics")
	return cmd
}

type listAtlasProcessesOpts struct {
	cli.GlobalOpts
	cli.OutputOpts
	client       *admin.APIClient
	groupId      string
	includeCount bool
	itemsPerPage int
	pageNum      int
}

func (opts *listAtlasProcessesOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *listAtlasProcessesOpts) Run(ctx context.Context, w io.Writer) error {
	params := &admin.ListAtlasProcessesApiParams{
		GroupId:      opts.groupId,
		IncludeCount: &opts.includeCount,
		ItemsPerPage: &opts.itemsPerPage,
		PageNum:      &opts.pageNum,
	}
	resp, _, err := opts.client.MonitoringAndLogsApi.ListAtlasProcessesWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return jsonwriter.Print(w, resp)
}

func listAtlasProcessesBuilder() *cobra.Command {
	opts := listAtlasProcessesOpts{}
	cmd := &cobra.Command{
		Use:   "listAtlasProcesses",
		Short: "Return All MongoDB Processes in One Project",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)
	cmd.Flags().BoolVar(&opts.includeCount, "includeCount", true, `Flag that indicates whether the response returns the total number of items (**totalCount**) in the response.`)
	cmd.Flags().IntVar(&opts.itemsPerPage, "itemsPerPage", 100, `Number of items that the response returns per page.`)
	cmd.Flags().IntVar(&opts.pageNum, "pageNum", 1, `Number of the page that displays the current set of the total objects that the response returns.`)

	cmd.Flags().StringVarP(&opts.Output, flag.Output, flag.OutputShort, "", usage.FormatOut)
	_ = cmd.RegisterFlagCompletionFunc(flag.Output, opts.AutoCompleteOutputFlag())

	_ = cmd.MarkFlagRequired("groupId")
	return cmd
}

type listDatabasesOpts struct {
	cli.GlobalOpts
	cli.OutputOpts
	client       *admin.APIClient
	groupId      string
	processId    string
	includeCount bool
	itemsPerPage int
	pageNum      int
}

func (opts *listDatabasesOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *listDatabasesOpts) Run(ctx context.Context, w io.Writer) error {
	params := &admin.ListDatabasesApiParams{
		GroupId:      opts.groupId,
		ProcessId:    opts.processId,
		IncludeCount: &opts.includeCount,
		ItemsPerPage: &opts.itemsPerPage,
		PageNum:      &opts.pageNum,
	}
	resp, _, err := opts.client.MonitoringAndLogsApi.ListDatabasesWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return jsonwriter.Print(w, resp)
}

func listDatabasesBuilder() *cobra.Command {
	opts := listDatabasesOpts{}
	cmd := &cobra.Command{
		Use:   "listDatabases",
		Short: "Return Available Databases for One MongoDB Process",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)
	cmd.Flags().StringVar(&opts.processId, "processId", "", `Combination of hostname and Internet Assigned Numbers Authority (IANA) port that serves the MongoDB process. The host must be the hostname, fully qualified domain name (FQDN), or Internet Protocol address (IPv4 or IPv6) of the host that runs the MongoDB process (&#x60;mongod&#x60;). The port must be the IANA port on which the MongoDB process listens for requests.`)
	cmd.Flags().BoolVar(&opts.includeCount, "includeCount", true, `Flag that indicates whether the response returns the total number of items (**totalCount**) in the response.`)
	cmd.Flags().IntVar(&opts.itemsPerPage, "itemsPerPage", 100, `Number of items that the response returns per page.`)
	cmd.Flags().IntVar(&opts.pageNum, "pageNum", 1, `Number of the page that displays the current set of the total objects that the response returns.`)

	cmd.Flags().StringVarP(&opts.Output, flag.Output, flag.OutputShort, "", usage.FormatOut)
	_ = cmd.RegisterFlagCompletionFunc(flag.Output, opts.AutoCompleteOutputFlag())

	_ = cmd.MarkFlagRequired("groupId")
	_ = cmd.MarkFlagRequired("processId")
	return cmd
}

type listDiskMeasurementsOpts struct {
	cli.GlobalOpts
	cli.OutputOpts
	client        *admin.APIClient
	partitionName string
	groupId       string
	processId     string
}

func (opts *listDiskMeasurementsOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *listDiskMeasurementsOpts) Run(ctx context.Context, w io.Writer) error {
	params := &admin.ListDiskMeasurementsApiParams{
		PartitionName: opts.partitionName,
		GroupId:       opts.groupId,
		ProcessId:     opts.processId,
	}
	resp, _, err := opts.client.MonitoringAndLogsApi.ListDiskMeasurementsWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return jsonwriter.Print(w, resp)
}

func listDiskMeasurementsBuilder() *cobra.Command {
	opts := listDiskMeasurementsOpts{}
	cmd := &cobra.Command{
		Use:   "listDiskMeasurements",
		Short: "Return Measurements of One Disk",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.partitionName, "partitionName", "", `Human-readable label of the disk or partition to which the measurements apply.`)
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)
	cmd.Flags().StringVar(&opts.processId, "processId", "", `Combination of hostname and Internet Assigned Numbers Authority (IANA) port that serves the MongoDB process. The host must be the hostname, fully qualified domain name (FQDN), or Internet Protocol address (IPv4 or IPv6) of the host that runs the MongoDB process (&#x60;mongod&#x60; or &#x60;mongos&#x60;). The port must be the IANA port on which the MongoDB process listens for requests.`)

	cmd.Flags().StringVarP(&opts.Output, flag.Output, flag.OutputShort, "", usage.FormatOut)
	_ = cmd.RegisterFlagCompletionFunc(flag.Output, opts.AutoCompleteOutputFlag())

	_ = cmd.MarkFlagRequired("partitionName")
	_ = cmd.MarkFlagRequired("groupId")
	_ = cmd.MarkFlagRequired("processId")
	return cmd
}

type listDiskPartitionsOpts struct {
	cli.GlobalOpts
	cli.OutputOpts
	client       *admin.APIClient
	groupId      string
	processId    string
	includeCount bool
	itemsPerPage int
	pageNum      int
}

func (opts *listDiskPartitionsOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *listDiskPartitionsOpts) Run(ctx context.Context, w io.Writer) error {
	params := &admin.ListDiskPartitionsApiParams{
		GroupId:      opts.groupId,
		ProcessId:    opts.processId,
		IncludeCount: &opts.includeCount,
		ItemsPerPage: &opts.itemsPerPage,
		PageNum:      &opts.pageNum,
	}
	resp, _, err := opts.client.MonitoringAndLogsApi.ListDiskPartitionsWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return jsonwriter.Print(w, resp)
}

func listDiskPartitionsBuilder() *cobra.Command {
	opts := listDiskPartitionsOpts{}
	cmd := &cobra.Command{
		Use:   "listDiskPartitions",
		Short: "Return Available Disks for One MongoDB Process",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)
	cmd.Flags().StringVar(&opts.processId, "processId", "", `Combination of hostname and Internet Assigned Numbers Authority (IANA) port that serves the MongoDB process. The host must be the hostname, fully qualified domain name (FQDN), or Internet Protocol address (IPv4 or IPv6) of the host that runs the MongoDB process (&#x60;mongod&#x60; or &#x60;mongos&#x60;). The port must be the IANA port on which the MongoDB process listens for requests.`)
	cmd.Flags().BoolVar(&opts.includeCount, "includeCount", true, `Flag that indicates whether the response returns the total number of items (**totalCount**) in the response.`)
	cmd.Flags().IntVar(&opts.itemsPerPage, "itemsPerPage", 100, `Number of items that the response returns per page.`)
	cmd.Flags().IntVar(&opts.pageNum, "pageNum", 1, `Number of the page that displays the current set of the total objects that the response returns.`)

	cmd.Flags().StringVarP(&opts.Output, flag.Output, flag.OutputShort, "", usage.FormatOut)
	_ = cmd.RegisterFlagCompletionFunc(flag.Output, opts.AutoCompleteOutputFlag())

	_ = cmd.MarkFlagRequired("groupId")
	_ = cmd.MarkFlagRequired("processId")
	return cmd
}

type listIndexMetricsOpts struct {
	cli.GlobalOpts
	cli.OutputOpts
	client         *admin.APIClient
	processId      string
	databaseName   string
	collectionName string
	groupId        string
	granularity    string
	metrics        []string
	period         string
	start          string
	end            string
}

func (opts *listIndexMetricsOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *listIndexMetricsOpts) Run(ctx context.Context, w io.Writer) error {
	params := &admin.ListIndexMetricsApiParams{
		ProcessId:      opts.processId,
		DatabaseName:   opts.databaseName,
		CollectionName: opts.collectionName,
		GroupId:        opts.groupId,
		Granularity:    &opts.granularity,
		Metrics:        &opts.metrics,
		Period:         &opts.period,
		Start:          convertTime(&opts.start),
		End:            convertTime(&opts.end),
	}
	resp, _, err := opts.client.MonitoringAndLogsApi.ListIndexMetricsWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return jsonwriter.Print(w, resp)
}

func listIndexMetricsBuilder() *cobra.Command {
	opts := listIndexMetricsOpts{}
	cmd := &cobra.Command{
		Use:   "listIndexMetrics",
		Short: "Return All Atlas Search Index Metrics for One Namespace",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.processId, "processId", "", `Combination of hostname and IANA port that serves the MongoDB process. The host must be the hostname, fully qualified domain name (FQDN), or Internet Protocol address (IPv4 or IPv6) of the host that runs the MongoDB process (mongod or mongos). The port must be the IANA port on which the MongoDB process listens for requests.`)
	cmd.Flags().StringVar(&opts.databaseName, "databaseName", "", `Human-readable label that identifies the database.`)
	cmd.Flags().StringVar(&opts.collectionName, "collectionName", "", `Human-readable label that identifies the collection.`)
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)
	cmd.Flags().StringVar(&opts.granularity, "granularity", "", `Duration that specifies the interval at which Atlas reports the metrics. This parameter expresses its value in the ISO 8601 duration format in UTC.`)
	cmd.Flags().StringSliceVar(&opts.metrics, "metrics", nil, `List that contains the measurements that MongoDB Atlas reports for the associated data series.`)
	cmd.Flags().StringVar(&opts.period, "period", "", `Duration over which Atlas reports the metrics. This parameter expresses its value in the ISO 8601 duration format in UTC. Include this parameter when you do not set **start** and **end**.`)
	cmd.Flags().StringVar(&opts.start, "start", "", `Date and time when MongoDB Cloud begins reporting the metrics. This parameter expresses its value in the ISO 8601 timestamp format in UTC. Include this parameter when you do not set **period**.`)
	cmd.Flags().StringVar(&opts.end, "end", "", `Date and time when MongoDB Cloud stops reporting the metrics. This parameter expresses its value in the ISO 8601 timestamp format in UTC. Include this parameter when you do not set **period**.`)

	cmd.Flags().StringVarP(&opts.Output, flag.Output, flag.OutputShort, "", usage.FormatOut)
	_ = cmd.RegisterFlagCompletionFunc(flag.Output, opts.AutoCompleteOutputFlag())

	_ = cmd.MarkFlagRequired("processId")
	_ = cmd.MarkFlagRequired("databaseName")
	_ = cmd.MarkFlagRequired("collectionName")
	_ = cmd.MarkFlagRequired("groupId")
	_ = cmd.MarkFlagRequired("granularity")
	_ = cmd.MarkFlagRequired("metrics")
	return cmd
}

type listMetricTypesOpts struct {
	cli.GlobalOpts
	cli.OutputOpts
	client    *admin.APIClient
	processId string
	groupId   string
}

func (opts *listMetricTypesOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *listMetricTypesOpts) Run(ctx context.Context, w io.Writer) error {
	params := &admin.ListMetricTypesApiParams{
		ProcessId: opts.processId,
		GroupId:   opts.groupId,
	}
	resp, _, err := opts.client.MonitoringAndLogsApi.ListMetricTypesWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return jsonwriter.Print(w, resp)
}

func listMetricTypesBuilder() *cobra.Command {
	opts := listMetricTypesOpts{}
	cmd := &cobra.Command{
		Use:   "listMetricTypes",
		Short: "Return All Atlas Search Metric Types for One Process",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.processId, "processId", "", `Combination of hostname and IANA port that serves the MongoDB process. The host must be the hostname, fully qualified domain name (FQDN), or Internet Protocol address (IPv4 or IPv6) of the host that runs the MongoDB process (mongod or mongos). The port must be the IANA port on which the MongoDB process listens for requests.`)
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)

	cmd.Flags().StringVarP(&opts.Output, flag.Output, flag.OutputShort, "", usage.FormatOut)
	_ = cmd.RegisterFlagCompletionFunc(flag.Output, opts.AutoCompleteOutputFlag())

	_ = cmd.MarkFlagRequired("processId")
	_ = cmd.MarkFlagRequired("groupId")
	return cmd
}

func monitoringAndLogsBuilder() *cobra.Command {
	cmd := &cobra.Command{
		Use:   "monitoringAndLogs",
		Short: `Returns database deployment monitoring and logging data.`,
	}
	cmd.AddCommand(
		getAtlasProcessBuilder(),
		getDatabaseBuilder(),
		getDatabaseMeasurementsBuilder(),
		getDiskMeasurementsBuilder(),
		getHostLogsBuilder(),
		getHostMeasurementsBuilder(),
		getIndexMetricsBuilder(),
		getMeasurementsBuilder(),
		listAtlasProcessesBuilder(),
		listDatabasesBuilder(),
		listDiskMeasurementsBuilder(),
		listDiskPartitionsBuilder(),
		listIndexMetricsBuilder(),
		listMetricTypesBuilder(),
	)
	return cmd
}
