// Copyright 2024 MongoDB Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"context"
	"encoding/hex"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"strings"
	"text/template"
	"time"

	"github.com/mongodb/mongodb-atlas-cli/atlascli/internal/cli"
	"github.com/mongodb/mongodb-atlas-cli/atlascli/internal/config"
	"github.com/spf13/afero"
	"github.com/spf13/cobra"
	"go.mongodb.org/atlas-sdk/v20231115012/admin"
)

type getCollStatsLatencyNamespaceClusterMeasurementsOpts struct {
	client         *admin.APIClient
	groupId        string
	clusterName    string
	clusterView    string
	databaseName   string
	collectionName string
	metrics        []string
	start          string
	end            string
	period         string
	format         string
	tmpl           *template.Template
	resp           *admin.MeasurementsCollStatsLatencyCluster
}

func (opts *getCollStatsLatencyNamespaceClusterMeasurementsOpts) preRun() (err error) {
	if opts.client, err = newClientWithAuth(config.UserAgent, config.Default()); err != nil {
		return err
	}

	if opts.groupId == "" {
		opts.groupId = config.ProjectID()
	}
	if opts.groupId == "" {
		return errors.New(`required flag(s) "projectId" not set`)
	}
	b, errDecode := hex.DecodeString(opts.groupId)
	if errDecode != nil || len(b) != 12 {
		return fmt.Errorf("the provided value '%s' is not a valid ID", opts.groupId)
	}

	if opts.format != "" {
		if opts.tmpl, err = template.New("").Parse(strings.ReplaceAll(opts.format, "\\n", "\n") + "\n"); err != nil {
			return err
		}
	}

	return nil
}

func (opts *getCollStatsLatencyNamespaceClusterMeasurementsOpts) run(ctx context.Context, _ io.Reader) error {

	var start *time.Time
	var errStart error
	if opts.start != "" {
		*start, errStart = time.Parse(time.RFC3339, opts.start)
		if errStart != nil {
			return errStart
		}
	}

	var end *time.Time
	var errEnd error
	if opts.end != "" {
		*end, errEnd = time.Parse(time.RFC3339, opts.end)
		if errEnd != nil {
			return errEnd
		}
	}

	params := &admin.GetCollStatsLatencyNamespaceClusterMeasurementsApiParams{
		GroupId:        opts.groupId,
		ClusterName:    opts.clusterName,
		ClusterView:    opts.clusterView,
		DatabaseName:   opts.databaseName,
		CollectionName: opts.collectionName,
		Metrics:        &opts.metrics,
		Start:          start,
		End:            end,
		Period:         &opts.period,
	}

	var err error
	opts.resp, _, err = opts.client.CollectionLevelMetricsApi.GetCollStatsLatencyNamespaceClusterMeasurementsWithParams(ctx, params).Execute()
	return err
}

func (opts *getCollStatsLatencyNamespaceClusterMeasurementsOpts) postRun(_ context.Context, w io.Writer) error {

	prettyJSON, errJson := json.MarshalIndent(opts.resp, "", " ")
	if errJson != nil {
		return errJson
	}

	if opts.format == "" {
		_, err := fmt.Fprintln(w, string(prettyJSON))
		return err
	}

	var parsedJSON interface{}
	if err := json.Unmarshal([]byte(prettyJSON), &parsedJSON); err != nil {
		return err
	}

	return opts.tmpl.Execute(w, parsedJSON)
}

func getCollStatsLatencyNamespaceClusterMeasurementsBuilder() *cobra.Command {
	opts := getCollStatsLatencyNamespaceClusterMeasurementsOpts{}
	const use = "getCollStatsLatencyNamespaceClusterMeasurements"
	cmd := &cobra.Command{
		Use:     use,
		Short:   "Return Cluster-Level Query Latency",
		Aliases: cli.GenerateAliases(use),
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.preRun()
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.run(cmd.Context(), cmd.InOrStdin())
		},
		PostRunE: func(cmd *cobra.Command, args []string) error {
			return opts.postRun(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "projectId", "", `Unique 24-hexadecimal digit string that identifies your project.`)
	cmd.Flags().StringVar(&opts.clusterName, "clusterName", "", `Human-readable label that identifies the cluster to retrieve metrics for.`)
	cmd.Flags().StringVar(&opts.clusterView, "clusterView", "", `Human-readable label that identifies the cluster topology to retrieve metrics for.`)
	cmd.Flags().StringVar(&opts.databaseName, "databaseName", "", `Human-readable label that identifies the database.`)
	cmd.Flags().StringVar(&opts.collectionName, "collectionName", "", `Human-readable label that identifies the collection.`)
	cmd.Flags().StringSliceVar(&opts.metrics, "metrics", nil, `List that contains the metrics that you want to retrieve for the associated data series. If you don&#39;t set this parameter, this resource returns data series for all Coll Stats Latency metrics.`)
	cmd.Flags().StringVar(&opts.start, "start", "", `Date and time when MongoDB Cloud begins reporting the metrics. This parameter expresses its value in the ISO 8601 timestamp format in UTC. Include this parameter when you do not set **period**.`)
	cmd.Flags().StringVar(&opts.end, "end", "", `Date and time when MongoDB Cloud stops reporting the metrics. This parameter expresses its value in the ISO 8601 timestamp format in UTC. Include this parameter when you do not set **period**.`)
	cmd.Flags().StringVar(&opts.period, "period", "", `Duration over which Atlas reports the metrics. This parameter expresses its value in the ISO 8601 duration format in UTC. Include this parameter when you do not set **start** and **end**.`)

	_ = cmd.MarkFlagRequired("clusterName")
	_ = cmd.MarkFlagRequired("clusterView")
	_ = cmd.MarkFlagRequired("databaseName")
	_ = cmd.MarkFlagRequired("collectionName")
	cmd.Flags().StringVar(&opts.format, "format", "", "Format of the output")
	return cmd
}

type getCollStatsLatencyNamespaceHostMeasurementsOpts struct {
	client         *admin.APIClient
	groupId        string
	processId      string
	databaseName   string
	collectionName string
	metrics        []string
	start          string
	end            string
	period         string
	format         string
	tmpl           *template.Template
	resp           *admin.MeasurementsCollStatsLatencyHost
}

func (opts *getCollStatsLatencyNamespaceHostMeasurementsOpts) preRun() (err error) {
	if opts.client, err = newClientWithAuth(config.UserAgent, config.Default()); err != nil {
		return err
	}

	if opts.groupId == "" {
		opts.groupId = config.ProjectID()
	}
	if opts.groupId == "" {
		return errors.New(`required flag(s) "projectId" not set`)
	}
	b, errDecode := hex.DecodeString(opts.groupId)
	if errDecode != nil || len(b) != 12 {
		return fmt.Errorf("the provided value '%s' is not a valid ID", opts.groupId)
	}

	if opts.format != "" {
		if opts.tmpl, err = template.New("").Parse(strings.ReplaceAll(opts.format, "\\n", "\n") + "\n"); err != nil {
			return err
		}
	}

	return nil
}

func (opts *getCollStatsLatencyNamespaceHostMeasurementsOpts) run(ctx context.Context, _ io.Reader) error {

	var start *time.Time
	var errStart error
	if opts.start != "" {
		*start, errStart = time.Parse(time.RFC3339, opts.start)
		if errStart != nil {
			return errStart
		}
	}

	var end *time.Time
	var errEnd error
	if opts.end != "" {
		*end, errEnd = time.Parse(time.RFC3339, opts.end)
		if errEnd != nil {
			return errEnd
		}
	}

	params := &admin.GetCollStatsLatencyNamespaceHostMeasurementsApiParams{
		GroupId:        opts.groupId,
		ProcessId:      opts.processId,
		DatabaseName:   opts.databaseName,
		CollectionName: opts.collectionName,
		Metrics:        &opts.metrics,
		Start:          start,
		End:            end,
		Period:         &opts.period,
	}

	var err error
	opts.resp, _, err = opts.client.CollectionLevelMetricsApi.GetCollStatsLatencyNamespaceHostMeasurementsWithParams(ctx, params).Execute()
	return err
}

func (opts *getCollStatsLatencyNamespaceHostMeasurementsOpts) postRun(_ context.Context, w io.Writer) error {

	prettyJSON, errJson := json.MarshalIndent(opts.resp, "", " ")
	if errJson != nil {
		return errJson
	}

	if opts.format == "" {
		_, err := fmt.Fprintln(w, string(prettyJSON))
		return err
	}

	var parsedJSON interface{}
	if err := json.Unmarshal([]byte(prettyJSON), &parsedJSON); err != nil {
		return err
	}

	return opts.tmpl.Execute(w, parsedJSON)
}

func getCollStatsLatencyNamespaceHostMeasurementsBuilder() *cobra.Command {
	opts := getCollStatsLatencyNamespaceHostMeasurementsOpts{}
	const use = "getCollStatsLatencyNamespaceHostMeasurements"
	cmd := &cobra.Command{
		Use:     use,
		Short:   "Return Host-Level Query Latency",
		Aliases: cli.GenerateAliases(use),
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.preRun()
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.run(cmd.Context(), cmd.InOrStdin())
		},
		PostRunE: func(cmd *cobra.Command, args []string) error {
			return opts.postRun(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "projectId", "", `Unique 24-hexadecimal digit string that identifies your project.`)
	cmd.Flags().StringVar(&opts.processId, "processId", "", `Combination of hostname and IANA port that serves the MongoDB process. The host must be the hostname, fully qualified domain name (FQDN), or Internet Protocol address (IPv4 or IPv6) of the host that runs the MongoDB process (mongod or mongos). The port must be the IANA port on which the MongoDB process listens for requests.`)
	cmd.Flags().StringVar(&opts.databaseName, "databaseName", "", `Human-readable label that identifies the database.`)
	cmd.Flags().StringVar(&opts.collectionName, "collectionName", "", `Human-readable label that identifies the collection.`)
	cmd.Flags().StringSliceVar(&opts.metrics, "metrics", nil, `List that contains the metrics that you want to retrieve for the associated data series. If you don&#39;t set this parameter, this resource returns data series for all Coll Stats Latency metrics.`)
	cmd.Flags().StringVar(&opts.start, "start", "", `Date and time when MongoDB Cloud begins reporting the metrics. This parameter expresses its value in the ISO 8601 timestamp format in UTC. Include this parameter when you do not set **period**.`)
	cmd.Flags().StringVar(&opts.end, "end", "", `Date and time when MongoDB Cloud stops reporting the metrics. This parameter expresses its value in the ISO 8601 timestamp format in UTC. Include this parameter when you do not set **period**.`)
	cmd.Flags().StringVar(&opts.period, "period", "", `Duration over which Atlas reports the metrics. This parameter expresses its value in the ISO 8601 duration format in UTC. Include this parameter when you do not set **start** and **end**.`)

	_ = cmd.MarkFlagRequired("processId")
	_ = cmd.MarkFlagRequired("databaseName")
	_ = cmd.MarkFlagRequired("collectionName")
	cmd.Flags().StringVar(&opts.format, "format", "", "Format of the output")
	return cmd
}

type getCollStatsLatencyNamespaceMetricsOpts struct {
	client  *admin.APIClient
	groupId string
	format  string
	tmpl    *template.Template
	resp    map[string]interface{}
}

func (opts *getCollStatsLatencyNamespaceMetricsOpts) preRun() (err error) {
	if opts.client, err = newClientWithAuth(config.UserAgent, config.Default()); err != nil {
		return err
	}

	if opts.groupId == "" {
		opts.groupId = config.ProjectID()
	}
	if opts.groupId == "" {
		return errors.New(`required flag(s) "projectId" not set`)
	}
	b, errDecode := hex.DecodeString(opts.groupId)
	if errDecode != nil || len(b) != 12 {
		return fmt.Errorf("the provided value '%s' is not a valid ID", opts.groupId)
	}

	if opts.format != "" {
		if opts.tmpl, err = template.New("").Parse(strings.ReplaceAll(opts.format, "\\n", "\n") + "\n"); err != nil {
			return err
		}
	}

	return nil
}

func (opts *getCollStatsLatencyNamespaceMetricsOpts) run(ctx context.Context, _ io.Reader) error {

	params := &admin.GetCollStatsLatencyNamespaceMetricsApiParams{
		GroupId: opts.groupId,
	}

	var err error
	opts.resp, _, err = opts.client.CollectionLevelMetricsApi.GetCollStatsLatencyNamespaceMetricsWithParams(ctx, params).Execute()
	return err
}

func (opts *getCollStatsLatencyNamespaceMetricsOpts) postRun(_ context.Context, w io.Writer) error {

	prettyJSON, errJson := json.MarshalIndent(opts.resp, "", " ")
	if errJson != nil {
		return errJson
	}

	if opts.format == "" {
		_, err := fmt.Fprintln(w, string(prettyJSON))
		return err
	}

	var parsedJSON interface{}
	if err := json.Unmarshal([]byte(prettyJSON), &parsedJSON); err != nil {
		return err
	}

	return opts.tmpl.Execute(w, parsedJSON)
}

func getCollStatsLatencyNamespaceMetricsBuilder() *cobra.Command {
	opts := getCollStatsLatencyNamespaceMetricsOpts{}
	const use = "getCollStatsLatencyNamespaceMetrics"
	cmd := &cobra.Command{
		Use:     use,
		Short:   "Return all metric names",
		Aliases: cli.GenerateAliases(use),
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.preRun()
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.run(cmd.Context(), cmd.InOrStdin())
		},
		PostRunE: func(cmd *cobra.Command, args []string) error {
			return opts.postRun(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "projectId", "", `Unique 24-hexadecimal digit string that identifies your project.`)

	cmd.Flags().StringVar(&opts.format, "format", "", "Format of the output")
	return cmd
}

type getCollStatsLatencyNamespacesForClusterOpts struct {
	client      *admin.APIClient
	groupId     string
	clusterName string
	clusterView string
	start       string
	end         string
	period      string
	format      string
	tmpl        *template.Template
	resp        *admin.CollStatsRankedNamespaces
}

func (opts *getCollStatsLatencyNamespacesForClusterOpts) preRun() (err error) {
	if opts.client, err = newClientWithAuth(config.UserAgent, config.Default()); err != nil {
		return err
	}

	if opts.groupId == "" {
		opts.groupId = config.ProjectID()
	}
	if opts.groupId == "" {
		return errors.New(`required flag(s) "projectId" not set`)
	}
	b, errDecode := hex.DecodeString(opts.groupId)
	if errDecode != nil || len(b) != 12 {
		return fmt.Errorf("the provided value '%s' is not a valid ID", opts.groupId)
	}

	if opts.format != "" {
		if opts.tmpl, err = template.New("").Parse(strings.ReplaceAll(opts.format, "\\n", "\n") + "\n"); err != nil {
			return err
		}
	}

	return nil
}

func (opts *getCollStatsLatencyNamespacesForClusterOpts) run(ctx context.Context, _ io.Reader) error {

	var start *time.Time
	var errStart error
	if opts.start != "" {
		*start, errStart = time.Parse(time.RFC3339, opts.start)
		if errStart != nil {
			return errStart
		}
	}

	var end *time.Time
	var errEnd error
	if opts.end != "" {
		*end, errEnd = time.Parse(time.RFC3339, opts.end)
		if errEnd != nil {
			return errEnd
		}
	}

	params := &admin.GetCollStatsLatencyNamespacesForClusterApiParams{
		GroupId:     opts.groupId,
		ClusterName: opts.clusterName,
		ClusterView: opts.clusterView,
		Start:       start,
		End:         end,
		Period:      &opts.period,
	}

	var err error
	opts.resp, _, err = opts.client.CollectionLevelMetricsApi.GetCollStatsLatencyNamespacesForClusterWithParams(ctx, params).Execute()
	return err
}

func (opts *getCollStatsLatencyNamespacesForClusterOpts) postRun(_ context.Context, w io.Writer) error {

	prettyJSON, errJson := json.MarshalIndent(opts.resp, "", " ")
	if errJson != nil {
		return errJson
	}

	if opts.format == "" {
		_, err := fmt.Fprintln(w, string(prettyJSON))
		return err
	}

	var parsedJSON interface{}
	if err := json.Unmarshal([]byte(prettyJSON), &parsedJSON); err != nil {
		return err
	}

	return opts.tmpl.Execute(w, parsedJSON)
}

func getCollStatsLatencyNamespacesForClusterBuilder() *cobra.Command {
	opts := getCollStatsLatencyNamespacesForClusterOpts{}
	const use = "getCollStatsLatencyNamespacesForCluster"
	cmd := &cobra.Command{
		Use:     use,
		Short:   "Return Ranked Namespaces from a Cluster",
		Aliases: cli.GenerateAliases(use),
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.preRun()
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.run(cmd.Context(), cmd.InOrStdin())
		},
		PostRunE: func(cmd *cobra.Command, args []string) error {
			return opts.postRun(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "projectId", "", `Unique 24-hexadecimal digit string that identifies your project.`)
	cmd.Flags().StringVar(&opts.clusterName, "clusterName", "", `Human-readable label that identifies the cluster to pin namespaces to.`)
	cmd.Flags().StringVar(&opts.clusterView, "clusterView", "", `Human-readable label that identifies the cluster topology to retrieve metrics for.`)
	cmd.Flags().StringVar(&opts.start, "start", "", `Date and time when MongoDB Cloud begins reporting the metrics. This parameter expresses its value in the ISO 8601 timestamp format in UTC. Include this parameter when you do not set **period**.`)
	cmd.Flags().StringVar(&opts.end, "end", "", `Date and time when MongoDB Cloud stops reporting the metrics. This parameter expresses its value in the ISO 8601 timestamp format in UTC. Include this parameter when you do not set **period**.`)
	cmd.Flags().StringVar(&opts.period, "period", "", `Duration over which Atlas reports the metrics. This parameter expresses its value in the ISO 8601 duration format in UTC. Include this parameter when you do not set **start** and **end**.`)

	_ = cmd.MarkFlagRequired("clusterName")
	_ = cmd.MarkFlagRequired("clusterView")
	cmd.Flags().StringVar(&opts.format, "format", "", "Format of the output")
	return cmd
}

type getCollStatsLatencyNamespacesForHostOpts struct {
	client    *admin.APIClient
	groupId   string
	processId string
	start     string
	end       string
	period    string
	format    string
	tmpl      *template.Template
	resp      *admin.CollStatsRankedNamespaces
}

func (opts *getCollStatsLatencyNamespacesForHostOpts) preRun() (err error) {
	if opts.client, err = newClientWithAuth(config.UserAgent, config.Default()); err != nil {
		return err
	}

	if opts.groupId == "" {
		opts.groupId = config.ProjectID()
	}
	if opts.groupId == "" {
		return errors.New(`required flag(s) "projectId" not set`)
	}
	b, errDecode := hex.DecodeString(opts.groupId)
	if errDecode != nil || len(b) != 12 {
		return fmt.Errorf("the provided value '%s' is not a valid ID", opts.groupId)
	}

	if opts.format != "" {
		if opts.tmpl, err = template.New("").Parse(strings.ReplaceAll(opts.format, "\\n", "\n") + "\n"); err != nil {
			return err
		}
	}

	return nil
}

func (opts *getCollStatsLatencyNamespacesForHostOpts) run(ctx context.Context, _ io.Reader) error {

	var start *time.Time
	var errStart error
	if opts.start != "" {
		*start, errStart = time.Parse(time.RFC3339, opts.start)
		if errStart != nil {
			return errStart
		}
	}

	var end *time.Time
	var errEnd error
	if opts.end != "" {
		*end, errEnd = time.Parse(time.RFC3339, opts.end)
		if errEnd != nil {
			return errEnd
		}
	}

	params := &admin.GetCollStatsLatencyNamespacesForHostApiParams{
		GroupId:   opts.groupId,
		ProcessId: opts.processId,
		Start:     start,
		End:       end,
		Period:    &opts.period,
	}

	var err error
	opts.resp, _, err = opts.client.CollectionLevelMetricsApi.GetCollStatsLatencyNamespacesForHostWithParams(ctx, params).Execute()
	return err
}

func (opts *getCollStatsLatencyNamespacesForHostOpts) postRun(_ context.Context, w io.Writer) error {

	prettyJSON, errJson := json.MarshalIndent(opts.resp, "", " ")
	if errJson != nil {
		return errJson
	}

	if opts.format == "" {
		_, err := fmt.Fprintln(w, string(prettyJSON))
		return err
	}

	var parsedJSON interface{}
	if err := json.Unmarshal([]byte(prettyJSON), &parsedJSON); err != nil {
		return err
	}

	return opts.tmpl.Execute(w, parsedJSON)
}

func getCollStatsLatencyNamespacesForHostBuilder() *cobra.Command {
	opts := getCollStatsLatencyNamespacesForHostOpts{}
	const use = "getCollStatsLatencyNamespacesForHost"
	cmd := &cobra.Command{
		Use:     use,
		Short:   "Return Ranked Namespaces from a Host",
		Aliases: cli.GenerateAliases(use),
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.preRun()
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.run(cmd.Context(), cmd.InOrStdin())
		},
		PostRunE: func(cmd *cobra.Command, args []string) error {
			return opts.postRun(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "projectId", "", `Unique 24-hexadecimal digit string that identifies your project.`)
	cmd.Flags().StringVar(&opts.processId, "processId", "", `Combination of hostname and IANA port that serves the MongoDB process. The host must be the hostname, fully qualified domain name (FQDN), or Internet Protocol address (IPv4 or IPv6) of the host that runs the MongoDB process (mongod or mongos). The port must be the IANA port on which the MongoDB process listens for requests.`)
	cmd.Flags().StringVar(&opts.start, "start", "", `Date and time when MongoDB Cloud begins reporting the metrics. This parameter expresses its value in the ISO 8601 timestamp format in UTC. Include this parameter when you do not set **period**.`)
	cmd.Flags().StringVar(&opts.end, "end", "", `Date and time when MongoDB Cloud stops reporting the metrics. This parameter expresses its value in the ISO 8601 timestamp format in UTC. Include this parameter when you do not set **period**.`)
	cmd.Flags().StringVar(&opts.period, "period", "", `Duration over which Atlas reports the metrics. This parameter expresses its value in the ISO 8601 duration format in UTC. Include this parameter when you do not set **start** and **end**.`)

	_ = cmd.MarkFlagRequired("processId")
	cmd.Flags().StringVar(&opts.format, "format", "", "Format of the output")
	return cmd
}

type getPinnedNamespacesOpts struct {
	client      *admin.APIClient
	groupId     string
	clusterName string
	format      string
	tmpl        *template.Template
	resp        *admin.PinnedNamespaces
}

func (opts *getPinnedNamespacesOpts) preRun() (err error) {
	if opts.client, err = newClientWithAuth(config.UserAgent, config.Default()); err != nil {
		return err
	}

	if opts.groupId == "" {
		opts.groupId = config.ProjectID()
	}
	if opts.groupId == "" {
		return errors.New(`required flag(s) "projectId" not set`)
	}
	b, errDecode := hex.DecodeString(opts.groupId)
	if errDecode != nil || len(b) != 12 {
		return fmt.Errorf("the provided value '%s' is not a valid ID", opts.groupId)
	}

	if opts.format != "" {
		if opts.tmpl, err = template.New("").Parse(strings.ReplaceAll(opts.format, "\\n", "\n") + "\n"); err != nil {
			return err
		}
	}

	return nil
}

func (opts *getPinnedNamespacesOpts) run(ctx context.Context, _ io.Reader) error {

	params := &admin.GetPinnedNamespacesApiParams{
		GroupId:     opts.groupId,
		ClusterName: opts.clusterName,
	}

	var err error
	opts.resp, _, err = opts.client.CollectionLevelMetricsApi.GetPinnedNamespacesWithParams(ctx, params).Execute()
	return err
}

func (opts *getPinnedNamespacesOpts) postRun(_ context.Context, w io.Writer) error {

	prettyJSON, errJson := json.MarshalIndent(opts.resp, "", " ")
	if errJson != nil {
		return errJson
	}

	if opts.format == "" {
		_, err := fmt.Fprintln(w, string(prettyJSON))
		return err
	}

	var parsedJSON interface{}
	if err := json.Unmarshal([]byte(prettyJSON), &parsedJSON); err != nil {
		return err
	}

	return opts.tmpl.Execute(w, parsedJSON)
}

func getPinnedNamespacesBuilder() *cobra.Command {
	opts := getPinnedNamespacesOpts{}
	const use = "getPinnedNamespaces"
	cmd := &cobra.Command{
		Use:     use,
		Short:   "Return Pinned Namespaces",
		Aliases: cli.GenerateAliases(use),
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.preRun()
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.run(cmd.Context(), cmd.InOrStdin())
		},
		PostRunE: func(cmd *cobra.Command, args []string) error {
			return opts.postRun(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "projectId", "", `Unique 24-hexadecimal digit string that identifies your project.`)
	cmd.Flags().StringVar(&opts.clusterName, "clusterName", "", `Human-readable label that identifies the cluster to retrieve pinned namespaces for.`)

	_ = cmd.MarkFlagRequired("clusterName")
	cmd.Flags().StringVar(&opts.format, "format", "", "Format of the output")
	return cmd
}

type pinNamespacesPatchOpts struct {
	client      *admin.APIClient
	groupId     string
	clusterName string

	filename string
	fs       afero.Fs
	format   string
	tmpl     *template.Template
	resp     *admin.PinnedNamespaces
}

func (opts *pinNamespacesPatchOpts) preRun() (err error) {
	if opts.client, err = newClientWithAuth(config.UserAgent, config.Default()); err != nil {
		return err
	}

	if opts.groupId == "" {
		opts.groupId = config.ProjectID()
	}
	if opts.groupId == "" {
		return errors.New(`required flag(s) "projectId" not set`)
	}
	b, errDecode := hex.DecodeString(opts.groupId)
	if errDecode != nil || len(b) != 12 {
		return fmt.Errorf("the provided value '%s' is not a valid ID", opts.groupId)
	}

	if opts.format != "" {
		if opts.tmpl, err = template.New("").Parse(strings.ReplaceAll(opts.format, "\\n", "\n") + "\n"); err != nil {
			return err
		}
	}

	return nil
}

func (opts *pinNamespacesPatchOpts) readData(r io.Reader) (*admin.NamespacesRequest, error) {
	var out *admin.NamespacesRequest

	var buf []byte
	var err error
	if opts.filename == "" {
		buf, err = io.ReadAll(r)
	} else {
		if exists, errExists := afero.Exists(opts.fs, opts.filename); !exists || errExists != nil {
			return nil, fmt.Errorf("file not found: %s", opts.filename)
		}
		buf, err = afero.ReadFile(opts.fs, opts.filename)
	}
	if err != nil {
		return nil, err
	}
	if err = json.Unmarshal(buf, &out); err != nil {
		return nil, err
	}
	return out, nil
}

func (opts *pinNamespacesPatchOpts) run(ctx context.Context, r io.Reader) error {
	data, errData := opts.readData(r)
	if errData != nil {
		return errData
	}

	params := &admin.PinNamespacesPatchApiParams{
		GroupId:     opts.groupId,
		ClusterName: opts.clusterName,

		NamespacesRequest: data,
	}

	var err error
	opts.resp, _, err = opts.client.CollectionLevelMetricsApi.PinNamespacesPatchWithParams(ctx, params).Execute()
	return err
}

func (opts *pinNamespacesPatchOpts) postRun(_ context.Context, w io.Writer) error {

	prettyJSON, errJson := json.MarshalIndent(opts.resp, "", " ")
	if errJson != nil {
		return errJson
	}

	if opts.format == "" {
		_, err := fmt.Fprintln(w, string(prettyJSON))
		return err
	}

	var parsedJSON interface{}
	if err := json.Unmarshal([]byte(prettyJSON), &parsedJSON); err != nil {
		return err
	}

	return opts.tmpl.Execute(w, parsedJSON)
}

func pinNamespacesPatchBuilder() *cobra.Command {
	opts := pinNamespacesPatchOpts{
		fs: afero.NewOsFs(),
	}
	const use = "pinNamespacesPatch"
	cmd := &cobra.Command{
		Use:     use,
		Short:   "Add Pinned Namespaces",
		Aliases: cli.GenerateAliases(use),
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.preRun()
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.run(cmd.Context(), cmd.InOrStdin())
		},
		PostRunE: func(cmd *cobra.Command, args []string) error {
			return opts.postRun(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "projectId", "", `Unique 24-hexadecimal digit string that identifies your project.`)
	cmd.Flags().StringVar(&opts.clusterName, "clusterName", "", `Human-readable label that identifies the cluster to pin namespaces to.`)

	cmd.Flags().StringVarP(&opts.filename, "file", "f", "", "Path to an optional JSON configuration file if not passed stdin is expected")

	_ = cmd.MarkFlagRequired("clusterName")
	cmd.Flags().StringVar(&opts.format, "format", "", "Format of the output")
	return cmd
}

type pinNamespacesPutOpts struct {
	client      *admin.APIClient
	groupId     string
	clusterName string

	filename string
	fs       afero.Fs
	format   string
	tmpl     *template.Template
	resp     *admin.PinnedNamespaces
}

func (opts *pinNamespacesPutOpts) preRun() (err error) {
	if opts.client, err = newClientWithAuth(config.UserAgent, config.Default()); err != nil {
		return err
	}

	if opts.groupId == "" {
		opts.groupId = config.ProjectID()
	}
	if opts.groupId == "" {
		return errors.New(`required flag(s) "projectId" not set`)
	}
	b, errDecode := hex.DecodeString(opts.groupId)
	if errDecode != nil || len(b) != 12 {
		return fmt.Errorf("the provided value '%s' is not a valid ID", opts.groupId)
	}

	if opts.format != "" {
		if opts.tmpl, err = template.New("").Parse(strings.ReplaceAll(opts.format, "\\n", "\n") + "\n"); err != nil {
			return err
		}
	}

	return nil
}

func (opts *pinNamespacesPutOpts) readData(r io.Reader) (*admin.NamespacesRequest, error) {
	var out *admin.NamespacesRequest

	var buf []byte
	var err error
	if opts.filename == "" {
		buf, err = io.ReadAll(r)
	} else {
		if exists, errExists := afero.Exists(opts.fs, opts.filename); !exists || errExists != nil {
			return nil, fmt.Errorf("file not found: %s", opts.filename)
		}
		buf, err = afero.ReadFile(opts.fs, opts.filename)
	}
	if err != nil {
		return nil, err
	}
	if err = json.Unmarshal(buf, &out); err != nil {
		return nil, err
	}
	return out, nil
}

func (opts *pinNamespacesPutOpts) run(ctx context.Context, r io.Reader) error {
	data, errData := opts.readData(r)
	if errData != nil {
		return errData
	}

	params := &admin.PinNamespacesPutApiParams{
		GroupId:     opts.groupId,
		ClusterName: opts.clusterName,

		NamespacesRequest: data,
	}

	var err error
	opts.resp, _, err = opts.client.CollectionLevelMetricsApi.PinNamespacesPutWithParams(ctx, params).Execute()
	return err
}

func (opts *pinNamespacesPutOpts) postRun(_ context.Context, w io.Writer) error {

	prettyJSON, errJson := json.MarshalIndent(opts.resp, "", " ")
	if errJson != nil {
		return errJson
	}

	if opts.format == "" {
		_, err := fmt.Fprintln(w, string(prettyJSON))
		return err
	}

	var parsedJSON interface{}
	if err := json.Unmarshal([]byte(prettyJSON), &parsedJSON); err != nil {
		return err
	}

	return opts.tmpl.Execute(w, parsedJSON)
}

func pinNamespacesPutBuilder() *cobra.Command {
	opts := pinNamespacesPutOpts{
		fs: afero.NewOsFs(),
	}
	const use = "pinNamespacesPut"
	cmd := &cobra.Command{
		Use:     use,
		Short:   "Pin Namespaces",
		Aliases: cli.GenerateAliases(use),
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.preRun()
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.run(cmd.Context(), cmd.InOrStdin())
		},
		PostRunE: func(cmd *cobra.Command, args []string) error {
			return opts.postRun(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "projectId", "", `Unique 24-hexadecimal digit string that identifies your project.`)
	cmd.Flags().StringVar(&opts.clusterName, "clusterName", "", `Human-readable label that identifies the cluster to pin namespaces to.`)

	cmd.Flags().StringVarP(&opts.filename, "file", "f", "", "Path to an optional JSON configuration file if not passed stdin is expected")

	_ = cmd.MarkFlagRequired("clusterName")
	cmd.Flags().StringVar(&opts.format, "format", "", "Format of the output")
	return cmd
}

type unpinNamespacesOpts struct {
	client      *admin.APIClient
	groupId     string
	clusterName string

	filename string
	fs       afero.Fs
	format   string
	tmpl     *template.Template
	resp     *admin.PinnedNamespaces
}

func (opts *unpinNamespacesOpts) preRun() (err error) {
	if opts.client, err = newClientWithAuth(config.UserAgent, config.Default()); err != nil {
		return err
	}

	if opts.groupId == "" {
		opts.groupId = config.ProjectID()
	}
	if opts.groupId == "" {
		return errors.New(`required flag(s) "projectId" not set`)
	}
	b, errDecode := hex.DecodeString(opts.groupId)
	if errDecode != nil || len(b) != 12 {
		return fmt.Errorf("the provided value '%s' is not a valid ID", opts.groupId)
	}

	if opts.format != "" {
		if opts.tmpl, err = template.New("").Parse(strings.ReplaceAll(opts.format, "\\n", "\n") + "\n"); err != nil {
			return err
		}
	}

	return nil
}

func (opts *unpinNamespacesOpts) readData(r io.Reader) (*admin.NamespacesRequest, error) {
	var out *admin.NamespacesRequest

	var buf []byte
	var err error
	if opts.filename == "" {
		buf, err = io.ReadAll(r)
	} else {
		if exists, errExists := afero.Exists(opts.fs, opts.filename); !exists || errExists != nil {
			return nil, fmt.Errorf("file not found: %s", opts.filename)
		}
		buf, err = afero.ReadFile(opts.fs, opts.filename)
	}
	if err != nil {
		return nil, err
	}
	if err = json.Unmarshal(buf, &out); err != nil {
		return nil, err
	}
	return out, nil
}

func (opts *unpinNamespacesOpts) run(ctx context.Context, r io.Reader) error {
	data, errData := opts.readData(r)
	if errData != nil {
		return errData
	}

	params := &admin.UnpinNamespacesApiParams{
		GroupId:     opts.groupId,
		ClusterName: opts.clusterName,

		NamespacesRequest: data,
	}

	var err error
	opts.resp, _, err = opts.client.CollectionLevelMetricsApi.UnpinNamespacesWithParams(ctx, params).Execute()
	return err
}

func (opts *unpinNamespacesOpts) postRun(_ context.Context, w io.Writer) error {

	prettyJSON, errJson := json.MarshalIndent(opts.resp, "", " ")
	if errJson != nil {
		return errJson
	}

	if opts.format == "" {
		_, err := fmt.Fprintln(w, string(prettyJSON))
		return err
	}

	var parsedJSON interface{}
	if err := json.Unmarshal([]byte(prettyJSON), &parsedJSON); err != nil {
		return err
	}

	return opts.tmpl.Execute(w, parsedJSON)
}

func unpinNamespacesBuilder() *cobra.Command {
	opts := unpinNamespacesOpts{
		fs: afero.NewOsFs(),
	}
	const use = "unpinNamespaces"
	cmd := &cobra.Command{
		Use:     use,
		Short:   "Unpin namespaces",
		Aliases: cli.GenerateAliases(use),
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.preRun()
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.run(cmd.Context(), cmd.InOrStdin())
		},
		PostRunE: func(cmd *cobra.Command, args []string) error {
			return opts.postRun(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "projectId", "", `Unique 24-hexadecimal digit string that identifies your project.`)
	cmd.Flags().StringVar(&opts.clusterName, "clusterName", "", `Human-readable label that identifies the cluster to unpin namespaces from.`)

	cmd.Flags().StringVarP(&opts.filename, "file", "f", "", "Path to an optional JSON configuration file if not passed stdin is expected")

	_ = cmd.MarkFlagRequired("clusterName")
	cmd.Flags().StringVar(&opts.format, "format", "", "Format of the output")
	return cmd
}

func collectionLevelMetricsBuilder() *cobra.Command {
	const use = "collectionLevelMetrics"
	cmd := &cobra.Command{
		Use:     use,
		Short:   `Returns, adds, and edits pinned namespaces for the specified cluster or process. Also returns collection level latency metric data.`,
		Aliases: cli.GenerateAliases(use),
	}
	cmd.AddCommand(
		getCollStatsLatencyNamespaceClusterMeasurementsBuilder(),
		getCollStatsLatencyNamespaceHostMeasurementsBuilder(),
		getCollStatsLatencyNamespaceMetricsBuilder(),
		getCollStatsLatencyNamespacesForClusterBuilder(),
		getCollStatsLatencyNamespacesForHostBuilder(),
		getPinnedNamespacesBuilder(),
		pinNamespacesPatchBuilder(),
		pinNamespacesPutBuilder(),
		unpinNamespacesBuilder(),
	)
	return cmd
}
