// Copyright 2024 MongoDB Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"context"
	"encoding/hex"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"strings"
	"text/template"

	"github.com/mongodb/mongodb-atlas-cli/atlascli/internal/cli"
	"github.com/mongodb/mongodb-atlas-cli/atlascli/internal/config"
	"github.com/spf13/afero"
	"github.com/spf13/cobra"
	"go.mongodb.org/atlas-sdk/v20231115012/admin"
)

type createDataFederationPrivateEndpointOpts struct {
	client  *admin.APIClient
	groupId string

	filename string
	fs       afero.Fs
	format   string
	tmpl     *template.Template
	resp     *admin.PaginatedPrivateNetworkEndpointIdEntry
}

func (opts *createDataFederationPrivateEndpointOpts) preRun() (err error) {
	if opts.client, err = newClientWithAuth(config.UserAgent, config.Default()); err != nil {
		return err
	}

	if opts.groupId == "" {
		opts.groupId = config.ProjectID()
	}
	if opts.groupId == "" {
		return errors.New(`required flag(s) "projectId" not set`)
	}
	b, errDecode := hex.DecodeString(opts.groupId)
	if errDecode != nil || len(b) != 12 {
		return fmt.Errorf("the provided value '%s' is not a valid ID", opts.groupId)
	}

	if opts.format != "" {
		if opts.tmpl, err = template.New("").Parse(strings.ReplaceAll(opts.format, "\\n", "\n") + "\n"); err != nil {
			return err
		}
	}

	return nil
}

func (opts *createDataFederationPrivateEndpointOpts) readData(r io.Reader) (*admin.PrivateNetworkEndpointIdEntry, error) {
	var out *admin.PrivateNetworkEndpointIdEntry

	var buf []byte
	var err error
	if opts.filename == "" {
		buf, err = io.ReadAll(r)
	} else {
		if exists, errExists := afero.Exists(opts.fs, opts.filename); !exists || errExists != nil {
			return nil, fmt.Errorf("file not found: %s", opts.filename)
		}
		buf, err = afero.ReadFile(opts.fs, opts.filename)
	}
	if err != nil {
		return nil, err
	}
	if err = json.Unmarshal(buf, &out); err != nil {
		return nil, err
	}
	return out, nil
}

func (opts *createDataFederationPrivateEndpointOpts) run(ctx context.Context, r io.Reader) error {
	data, errData := opts.readData(r)
	if errData != nil {
		return errData
	}

	params := &admin.CreateDataFederationPrivateEndpointApiParams{
		GroupId: opts.groupId,

		PrivateNetworkEndpointIdEntry: data,
	}

	var err error
	opts.resp, _, err = opts.client.DataFederationApi.CreateDataFederationPrivateEndpointWithParams(ctx, params).Execute()
	return err
}

func (opts *createDataFederationPrivateEndpointOpts) postRun(_ context.Context, w io.Writer) error {

	prettyJSON, errJson := json.MarshalIndent(opts.resp, "", " ")
	if errJson != nil {
		return errJson
	}

	if opts.format == "" {
		_, err := fmt.Fprintln(w, string(prettyJSON))
		return err
	}

	var parsedJSON interface{}
	if err := json.Unmarshal([]byte(prettyJSON), &parsedJSON); err != nil {
		return err
	}

	return opts.tmpl.Execute(w, parsedJSON)
}

func createDataFederationPrivateEndpointBuilder() *cobra.Command {
	opts := createDataFederationPrivateEndpointOpts{
		fs: afero.NewOsFs(),
	}
	cmd := &cobra.Command{
		Use:   "createDataFederationPrivateEndpoint",
		Short: "Create One Federated Database Instance and Online Archive Private Endpoint for One Project",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.preRun()
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.run(cmd.Context(), cmd.InOrStdin())
		},
		PostRunE: func(cmd *cobra.Command, args []string) error {
			return opts.postRun(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "projectId", "", `Unique 24-hexadecimal digit string that identifies your project.`)

	cmd.Flags().StringVarP(&opts.filename, "file", "f", "", "Path to an optional JSON configuration file if not passed stdin is expected")

	cmd.Flags().StringVar(&opts.format, "format", "", "Format of the output")
	return cmd
}

type createFederatedDatabaseOpts struct {
	client  *admin.APIClient
	groupId string

	skipRoleValidation bool
	filename           string
	fs                 afero.Fs
	format             string
	tmpl               *template.Template
	resp               *admin.DataLakeTenant
}

func (opts *createFederatedDatabaseOpts) preRun() (err error) {
	if opts.client, err = newClientWithAuth(config.UserAgent, config.Default()); err != nil {
		return err
	}

	if opts.groupId == "" {
		opts.groupId = config.ProjectID()
	}
	if opts.groupId == "" {
		return errors.New(`required flag(s) "projectId" not set`)
	}
	b, errDecode := hex.DecodeString(opts.groupId)
	if errDecode != nil || len(b) != 12 {
		return fmt.Errorf("the provided value '%s' is not a valid ID", opts.groupId)
	}

	if opts.format != "" {
		if opts.tmpl, err = template.New("").Parse(strings.ReplaceAll(opts.format, "\\n", "\n") + "\n"); err != nil {
			return err
		}
	}

	return nil
}

func (opts *createFederatedDatabaseOpts) readData(r io.Reader) (*admin.DataLakeTenant, error) {
	var out *admin.DataLakeTenant

	var buf []byte
	var err error
	if opts.filename == "" {
		buf, err = io.ReadAll(r)
	} else {
		if exists, errExists := afero.Exists(opts.fs, opts.filename); !exists || errExists != nil {
			return nil, fmt.Errorf("file not found: %s", opts.filename)
		}
		buf, err = afero.ReadFile(opts.fs, opts.filename)
	}
	if err != nil {
		return nil, err
	}
	if err = json.Unmarshal(buf, &out); err != nil {
		return nil, err
	}
	return out, nil
}

func (opts *createFederatedDatabaseOpts) run(ctx context.Context, r io.Reader) error {
	data, errData := opts.readData(r)
	if errData != nil {
		return errData
	}

	params := &admin.CreateFederatedDatabaseApiParams{
		GroupId: opts.groupId,

		SkipRoleValidation: &opts.skipRoleValidation,

		DataLakeTenant: data,
	}

	var err error
	opts.resp, _, err = opts.client.DataFederationApi.CreateFederatedDatabaseWithParams(ctx, params).Execute()
	return err
}

func (opts *createFederatedDatabaseOpts) postRun(_ context.Context, w io.Writer) error {

	prettyJSON, errJson := json.MarshalIndent(opts.resp, "", " ")
	if errJson != nil {
		return errJson
	}

	if opts.format == "" {
		_, err := fmt.Fprintln(w, string(prettyJSON))
		return err
	}

	var parsedJSON interface{}
	if err := json.Unmarshal([]byte(prettyJSON), &parsedJSON); err != nil {
		return err
	}

	return opts.tmpl.Execute(w, parsedJSON)
}

func createFederatedDatabaseBuilder() *cobra.Command {
	opts := createFederatedDatabaseOpts{
		fs: afero.NewOsFs(),
	}
	cmd := &cobra.Command{
		Use:   "createFederatedDatabase",
		Short: "Create One Federated Database Instance in One Project",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.preRun()
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.run(cmd.Context(), cmd.InOrStdin())
		},
		PostRunE: func(cmd *cobra.Command, args []string) error {
			return opts.postRun(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "projectId", "", `Unique 24-hexadecimal digit string that identifies your project.`)

	cmd.Flags().BoolVar(&opts.skipRoleValidation, "skipRoleValidation", false, `Flag that indicates whether this request should check if the requesting IAM role can read from the S3 bucket. AWS checks if the role can list the objects in the bucket before writing to it. Some IAM roles only need write permissions. This flag allows you to skip that check.`)
	cmd.Flags().StringVarP(&opts.filename, "file", "f", "", "Path to an optional JSON configuration file if not passed stdin is expected")

	cmd.Flags().StringVar(&opts.format, "format", "", "Format of the output")
	return cmd
}

type createOneDataFederationQueryLimitOpts struct {
	client     *admin.APIClient
	groupId    string
	tenantName string
	limitName  string

	filename string
	fs       afero.Fs
	format   string
	tmpl     *template.Template
	resp     *admin.DataFederationTenantQueryLimit
}

func (opts *createOneDataFederationQueryLimitOpts) preRun() (err error) {
	if opts.client, err = newClientWithAuth(config.UserAgent, config.Default()); err != nil {
		return err
	}

	if opts.groupId == "" {
		opts.groupId = config.ProjectID()
	}
	if opts.groupId == "" {
		return errors.New(`required flag(s) "projectId" not set`)
	}
	b, errDecode := hex.DecodeString(opts.groupId)
	if errDecode != nil || len(b) != 12 {
		return fmt.Errorf("the provided value '%s' is not a valid ID", opts.groupId)
	}

	if opts.format != "" {
		if opts.tmpl, err = template.New("").Parse(strings.ReplaceAll(opts.format, "\\n", "\n") + "\n"); err != nil {
			return err
		}
	}

	return nil
}

func (opts *createOneDataFederationQueryLimitOpts) readData(r io.Reader) (*admin.DataFederationTenantQueryLimit, error) {
	var out *admin.DataFederationTenantQueryLimit

	var buf []byte
	var err error
	if opts.filename == "" {
		buf, err = io.ReadAll(r)
	} else {
		if exists, errExists := afero.Exists(opts.fs, opts.filename); !exists || errExists != nil {
			return nil, fmt.Errorf("file not found: %s", opts.filename)
		}
		buf, err = afero.ReadFile(opts.fs, opts.filename)
	}
	if err != nil {
		return nil, err
	}
	if err = json.Unmarshal(buf, &out); err != nil {
		return nil, err
	}
	return out, nil
}

func (opts *createOneDataFederationQueryLimitOpts) run(ctx context.Context, r io.Reader) error {
	data, errData := opts.readData(r)
	if errData != nil {
		return errData
	}

	params := &admin.CreateOneDataFederationQueryLimitApiParams{
		GroupId:    opts.groupId,
		TenantName: opts.tenantName,
		LimitName:  opts.limitName,

		DataFederationTenantQueryLimit: data,
	}

	var err error
	opts.resp, _, err = opts.client.DataFederationApi.CreateOneDataFederationQueryLimitWithParams(ctx, params).Execute()
	return err
}

func (opts *createOneDataFederationQueryLimitOpts) postRun(_ context.Context, w io.Writer) error {

	prettyJSON, errJson := json.MarshalIndent(opts.resp, "", " ")
	if errJson != nil {
		return errJson
	}

	if opts.format == "" {
		_, err := fmt.Fprintln(w, string(prettyJSON))
		return err
	}

	var parsedJSON interface{}
	if err := json.Unmarshal([]byte(prettyJSON), &parsedJSON); err != nil {
		return err
	}

	return opts.tmpl.Execute(w, parsedJSON)
}

func createOneDataFederationQueryLimitBuilder() *cobra.Command {
	opts := createOneDataFederationQueryLimitOpts{
		fs: afero.NewOsFs(),
	}
	cmd := &cobra.Command{
		Use:   "createOneDataFederationQueryLimit",
		Short: "Configure One Query Limit for One Federated Database Instance",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.preRun()
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.run(cmd.Context(), cmd.InOrStdin())
		},
		PostRunE: func(cmd *cobra.Command, args []string) error {
			return opts.postRun(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "projectId", "", `Unique 24-hexadecimal digit string that identifies your project.`)
	cmd.Flags().StringVar(&opts.tenantName, "tenantName", "", `Human-readable label that identifies the federated database instance to which the query limit applies.`)
	cmd.Flags().StringVar(&opts.limitName, "limitName", "", `Human-readable label that identifies this data federation instance limit.

| Limit Name | Description | Default |
| --- | --- | --- |
| bytesProcessed.query | Limit on the number of bytes processed during a single data federation query | N/A |
| bytesProcessed.daily | Limit on the number of bytes processed for the data federation instance for the current day | N/A |
| bytesProcessed.weekly | Limit on the number of bytes processed for the data federation instance for the current week | N/A |
| bytesProcessed.monthly | Limit on the number of bytes processed for the data federation instance for the current month | N/A |
`)

	cmd.Flags().StringVarP(&opts.filename, "file", "f", "", "Path to an optional JSON configuration file if not passed stdin is expected")

	_ = cmd.MarkFlagRequired("tenantName")
	_ = cmd.MarkFlagRequired("limitName")
	cmd.Flags().StringVar(&opts.format, "format", "", "Format of the output")
	return cmd
}

type deleteDataFederationPrivateEndpointOpts struct {
	client     *admin.APIClient
	groupId    string
	endpointId string
	format     string
	tmpl       *template.Template
	resp       map[string]interface{}
}

func (opts *deleteDataFederationPrivateEndpointOpts) preRun() (err error) {
	if opts.client, err = newClientWithAuth(config.UserAgent, config.Default()); err != nil {
		return err
	}

	if opts.groupId == "" {
		opts.groupId = config.ProjectID()
	}
	if opts.groupId == "" {
		return errors.New(`required flag(s) "projectId" not set`)
	}
	b, errDecode := hex.DecodeString(opts.groupId)
	if errDecode != nil || len(b) != 12 {
		return fmt.Errorf("the provided value '%s' is not a valid ID", opts.groupId)
	}

	if opts.format != "" {
		if opts.tmpl, err = template.New("").Parse(strings.ReplaceAll(opts.format, "\\n", "\n") + "\n"); err != nil {
			return err
		}
	}

	return nil
}

func (opts *deleteDataFederationPrivateEndpointOpts) run(ctx context.Context, _ io.Reader) error {

	params := &admin.DeleteDataFederationPrivateEndpointApiParams{
		GroupId:    opts.groupId,
		EndpointId: opts.endpointId,
	}

	var err error
	opts.resp, _, err = opts.client.DataFederationApi.DeleteDataFederationPrivateEndpointWithParams(ctx, params).Execute()
	return err
}

func (opts *deleteDataFederationPrivateEndpointOpts) postRun(_ context.Context, w io.Writer) error {

	prettyJSON, errJson := json.MarshalIndent(opts.resp, "", " ")
	if errJson != nil {
		return errJson
	}

	if opts.format == "" {
		_, err := fmt.Fprintln(w, string(prettyJSON))
		return err
	}

	var parsedJSON interface{}
	if err := json.Unmarshal([]byte(prettyJSON), &parsedJSON); err != nil {
		return err
	}

	return opts.tmpl.Execute(w, parsedJSON)
}

func deleteDataFederationPrivateEndpointBuilder() *cobra.Command {
	opts := deleteDataFederationPrivateEndpointOpts{}
	cmd := &cobra.Command{
		Use:   "deleteDataFederationPrivateEndpoint",
		Short: "Remove One Federated Database Instance and Online Archive Private Endpoint from One Project",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.preRun()
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.run(cmd.Context(), cmd.InOrStdin())
		},
		PostRunE: func(cmd *cobra.Command, args []string) error {
			return opts.postRun(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "projectId", "", `Unique 24-hexadecimal digit string that identifies your project.`)
	cmd.Flags().StringVar(&opts.endpointId, "endpointId", "", `Unique 22-character alphanumeric string that identifies the private endpoint to remove. Atlas Data Federation supports AWS private endpoints using the AWS PrivateLink feature.`)

	_ = cmd.MarkFlagRequired("endpointId")
	cmd.Flags().StringVar(&opts.format, "format", "", "Format of the output")
	return cmd
}

type deleteFederatedDatabaseOpts struct {
	client     *admin.APIClient
	groupId    string
	tenantName string
	format     string
	tmpl       *template.Template
	resp       map[string]interface{}
}

func (opts *deleteFederatedDatabaseOpts) preRun() (err error) {
	if opts.client, err = newClientWithAuth(config.UserAgent, config.Default()); err != nil {
		return err
	}

	if opts.groupId == "" {
		opts.groupId = config.ProjectID()
	}
	if opts.groupId == "" {
		return errors.New(`required flag(s) "projectId" not set`)
	}
	b, errDecode := hex.DecodeString(opts.groupId)
	if errDecode != nil || len(b) != 12 {
		return fmt.Errorf("the provided value '%s' is not a valid ID", opts.groupId)
	}

	if opts.format != "" {
		if opts.tmpl, err = template.New("").Parse(strings.ReplaceAll(opts.format, "\\n", "\n") + "\n"); err != nil {
			return err
		}
	}

	return nil
}

func (opts *deleteFederatedDatabaseOpts) run(ctx context.Context, _ io.Reader) error {

	params := &admin.DeleteFederatedDatabaseApiParams{
		GroupId:    opts.groupId,
		TenantName: opts.tenantName,
	}

	var err error
	opts.resp, _, err = opts.client.DataFederationApi.DeleteFederatedDatabaseWithParams(ctx, params).Execute()
	return err
}

func (opts *deleteFederatedDatabaseOpts) postRun(_ context.Context, w io.Writer) error {

	prettyJSON, errJson := json.MarshalIndent(opts.resp, "", " ")
	if errJson != nil {
		return errJson
	}

	if opts.format == "" {
		_, err := fmt.Fprintln(w, string(prettyJSON))
		return err
	}

	var parsedJSON interface{}
	if err := json.Unmarshal([]byte(prettyJSON), &parsedJSON); err != nil {
		return err
	}

	return opts.tmpl.Execute(w, parsedJSON)
}

func deleteFederatedDatabaseBuilder() *cobra.Command {
	opts := deleteFederatedDatabaseOpts{}
	cmd := &cobra.Command{
		Use:   "deleteFederatedDatabase",
		Short: "Remove One Federated Database Instance from One Project",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.preRun()
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.run(cmd.Context(), cmd.InOrStdin())
		},
		PostRunE: func(cmd *cobra.Command, args []string) error {
			return opts.postRun(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "projectId", "", `Unique 24-hexadecimal digit string that identifies your project.`)
	cmd.Flags().StringVar(&opts.tenantName, "tenantName", "", `Human-readable label that identifies the federated database instance to remove.`)

	_ = cmd.MarkFlagRequired("tenantName")
	cmd.Flags().StringVar(&opts.format, "format", "", "Format of the output")
	return cmd
}

type deleteOneDataFederationInstanceQueryLimitOpts struct {
	client     *admin.APIClient
	groupId    string
	tenantName string
	limitName  string
	format     string
	tmpl       *template.Template
	resp       map[string]interface{}
}

func (opts *deleteOneDataFederationInstanceQueryLimitOpts) preRun() (err error) {
	if opts.client, err = newClientWithAuth(config.UserAgent, config.Default()); err != nil {
		return err
	}

	if opts.groupId == "" {
		opts.groupId = config.ProjectID()
	}
	if opts.groupId == "" {
		return errors.New(`required flag(s) "projectId" not set`)
	}
	b, errDecode := hex.DecodeString(opts.groupId)
	if errDecode != nil || len(b) != 12 {
		return fmt.Errorf("the provided value '%s' is not a valid ID", opts.groupId)
	}

	if opts.format != "" {
		if opts.tmpl, err = template.New("").Parse(strings.ReplaceAll(opts.format, "\\n", "\n") + "\n"); err != nil {
			return err
		}
	}

	return nil
}

func (opts *deleteOneDataFederationInstanceQueryLimitOpts) run(ctx context.Context, _ io.Reader) error {

	params := &admin.DeleteOneDataFederationInstanceQueryLimitApiParams{
		GroupId:    opts.groupId,
		TenantName: opts.tenantName,
		LimitName:  opts.limitName,
	}

	var err error
	opts.resp, _, err = opts.client.DataFederationApi.DeleteOneDataFederationInstanceQueryLimitWithParams(ctx, params).Execute()
	return err
}

func (opts *deleteOneDataFederationInstanceQueryLimitOpts) postRun(_ context.Context, w io.Writer) error {

	prettyJSON, errJson := json.MarshalIndent(opts.resp, "", " ")
	if errJson != nil {
		return errJson
	}

	if opts.format == "" {
		_, err := fmt.Fprintln(w, string(prettyJSON))
		return err
	}

	var parsedJSON interface{}
	if err := json.Unmarshal([]byte(prettyJSON), &parsedJSON); err != nil {
		return err
	}

	return opts.tmpl.Execute(w, parsedJSON)
}

func deleteOneDataFederationInstanceQueryLimitBuilder() *cobra.Command {
	opts := deleteOneDataFederationInstanceQueryLimitOpts{}
	cmd := &cobra.Command{
		Use:   "deleteOneDataFederationInstanceQueryLimit",
		Short: "Delete One Query Limit For One Federated Database Instance",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.preRun()
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.run(cmd.Context(), cmd.InOrStdin())
		},
		PostRunE: func(cmd *cobra.Command, args []string) error {
			return opts.postRun(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "projectId", "", `Unique 24-hexadecimal digit string that identifies your project.`)
	cmd.Flags().StringVar(&opts.tenantName, "tenantName", "", `Human-readable label that identifies the federated database instance to which the query limit applies.`)
	cmd.Flags().StringVar(&opts.limitName, "limitName", "", `Human-readable label that identifies this data federation instance limit.

| Limit Name | Description | Default |
| --- | --- | --- |
| bytesProcessed.query | Limit on the number of bytes processed during a single data federation query | N/A |
| bytesProcessed.daily | Limit on the number of bytes processed for the data federation instance for the current day | N/A |
| bytesProcessed.weekly | Limit on the number of bytes processed for the data federation instance for the current week | N/A |
| bytesProcessed.monthly | Limit on the number of bytes processed for the data federation instance for the current month | N/A |
`)

	_ = cmd.MarkFlagRequired("tenantName")
	_ = cmd.MarkFlagRequired("limitName")
	cmd.Flags().StringVar(&opts.format, "format", "", "Format of the output")
	return cmd
}

type downloadFederatedDatabaseQueryLogsOpts struct {
	client     *admin.APIClient
	groupId    string
	tenantName string
	endDate    int64
	startDate  int64
	format     string
	tmpl       *template.Template
	resp       io.ReadCloser
}

func (opts *downloadFederatedDatabaseQueryLogsOpts) preRun() (err error) {
	if opts.client, err = newClientWithAuth(config.UserAgent, config.Default()); err != nil {
		return err
	}

	if opts.groupId == "" {
		opts.groupId = config.ProjectID()
	}
	if opts.groupId == "" {
		return errors.New(`required flag(s) "projectId" not set`)
	}
	b, errDecode := hex.DecodeString(opts.groupId)
	if errDecode != nil || len(b) != 12 {
		return fmt.Errorf("the provided value '%s' is not a valid ID", opts.groupId)
	}

	if opts.format != "" {
		if opts.tmpl, err = template.New("").Parse(strings.ReplaceAll(opts.format, "\\n", "\n") + "\n"); err != nil {
			return err
		}
	}

	return nil
}

func (opts *downloadFederatedDatabaseQueryLogsOpts) run(ctx context.Context, _ io.Reader) error {

	params := &admin.DownloadFederatedDatabaseQueryLogsApiParams{
		GroupId:    opts.groupId,
		TenantName: opts.tenantName,
		EndDate:    &opts.endDate,
		StartDate:  &opts.startDate,
	}

	var err error
	opts.resp, _, err = opts.client.DataFederationApi.DownloadFederatedDatabaseQueryLogsWithParams(ctx, params).Execute()
	return err
}

func (opts *downloadFederatedDatabaseQueryLogsOpts) postRun(_ context.Context, w io.Writer) error {

	prettyJSON, errJson := json.MarshalIndent(opts.resp, "", " ")
	if errJson != nil {
		return errJson
	}

	if opts.format == "" {
		_, err := fmt.Fprintln(w, string(prettyJSON))
		return err
	}

	var parsedJSON interface{}
	if err := json.Unmarshal([]byte(prettyJSON), &parsedJSON); err != nil {
		return err
	}

	return opts.tmpl.Execute(w, parsedJSON)
}

func downloadFederatedDatabaseQueryLogsBuilder() *cobra.Command {
	opts := downloadFederatedDatabaseQueryLogsOpts{}
	cmd := &cobra.Command{
		Use:   "downloadFederatedDatabaseQueryLogs",
		Short: "Download Query Logs for One Federated Database Instance",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.preRun()
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.run(cmd.Context(), cmd.InOrStdin())
		},
		PostRunE: func(cmd *cobra.Command, args []string) error {
			return opts.postRun(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "projectId", "", `Unique 24-hexadecimal digit string that identifies your project.`)
	cmd.Flags().StringVar(&opts.tenantName, "tenantName", "", `Human-readable label that identifies the federated database instance for which you want to download query logs.`)
	cmd.Flags().Int64Var(&opts.endDate, "endDate", 0, `Timestamp that specifies the end point for the range of log messages to download.  MongoDB Cloud expresses this timestamp in the number of seconds that have elapsed since the UNIX epoch.`)
	cmd.Flags().Int64Var(&opts.startDate, "startDate", 0, `Timestamp that specifies the starting point for the range of log messages to download. MongoDB Cloud expresses this timestamp in the number of seconds that have elapsed since the UNIX epoch.`)

	_ = cmd.MarkFlagRequired("tenantName")
	cmd.Flags().StringVar(&opts.format, "format", "", "Format of the output")
	return cmd
}

type getDataFederationPrivateEndpointOpts struct {
	client     *admin.APIClient
	groupId    string
	endpointId string
	format     string
	tmpl       *template.Template
	resp       *admin.PrivateNetworkEndpointIdEntry
}

func (opts *getDataFederationPrivateEndpointOpts) preRun() (err error) {
	if opts.client, err = newClientWithAuth(config.UserAgent, config.Default()); err != nil {
		return err
	}

	if opts.groupId == "" {
		opts.groupId = config.ProjectID()
	}
	if opts.groupId == "" {
		return errors.New(`required flag(s) "projectId" not set`)
	}
	b, errDecode := hex.DecodeString(opts.groupId)
	if errDecode != nil || len(b) != 12 {
		return fmt.Errorf("the provided value '%s' is not a valid ID", opts.groupId)
	}

	if opts.format != "" {
		if opts.tmpl, err = template.New("").Parse(strings.ReplaceAll(opts.format, "\\n", "\n") + "\n"); err != nil {
			return err
		}
	}

	return nil
}

func (opts *getDataFederationPrivateEndpointOpts) run(ctx context.Context, _ io.Reader) error {

	params := &admin.GetDataFederationPrivateEndpointApiParams{
		GroupId:    opts.groupId,
		EndpointId: opts.endpointId,
	}

	var err error
	opts.resp, _, err = opts.client.DataFederationApi.GetDataFederationPrivateEndpointWithParams(ctx, params).Execute()
	return err
}

func (opts *getDataFederationPrivateEndpointOpts) postRun(_ context.Context, w io.Writer) error {

	prettyJSON, errJson := json.MarshalIndent(opts.resp, "", " ")
	if errJson != nil {
		return errJson
	}

	if opts.format == "" {
		_, err := fmt.Fprintln(w, string(prettyJSON))
		return err
	}

	var parsedJSON interface{}
	if err := json.Unmarshal([]byte(prettyJSON), &parsedJSON); err != nil {
		return err
	}

	return opts.tmpl.Execute(w, parsedJSON)
}

func getDataFederationPrivateEndpointBuilder() *cobra.Command {
	opts := getDataFederationPrivateEndpointOpts{}
	cmd := &cobra.Command{
		Use:   "getDataFederationPrivateEndpoint",
		Short: "Return One Federated Database Instance and Online Archive Private Endpoint in One Project",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.preRun()
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.run(cmd.Context(), cmd.InOrStdin())
		},
		PostRunE: func(cmd *cobra.Command, args []string) error {
			return opts.postRun(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "projectId", "", `Unique 24-hexadecimal digit string that identifies your project.`)
	cmd.Flags().StringVar(&opts.endpointId, "endpointId", "", `Unique 22-character alphanumeric string that identifies the private endpoint to return. Atlas Data Federation supports AWS private endpoints using the AWS PrivateLink feature.`)

	_ = cmd.MarkFlagRequired("endpointId")
	cmd.Flags().StringVar(&opts.format, "format", "", "Format of the output")
	return cmd
}

type getFederatedDatabaseOpts struct {
	client     *admin.APIClient
	groupId    string
	tenantName string
	format     string
	tmpl       *template.Template
	resp       *admin.DataLakeTenant
}

func (opts *getFederatedDatabaseOpts) preRun() (err error) {
	if opts.client, err = newClientWithAuth(config.UserAgent, config.Default()); err != nil {
		return err
	}

	if opts.groupId == "" {
		opts.groupId = config.ProjectID()
	}
	if opts.groupId == "" {
		return errors.New(`required flag(s) "projectId" not set`)
	}
	b, errDecode := hex.DecodeString(opts.groupId)
	if errDecode != nil || len(b) != 12 {
		return fmt.Errorf("the provided value '%s' is not a valid ID", opts.groupId)
	}

	if opts.format != "" {
		if opts.tmpl, err = template.New("").Parse(strings.ReplaceAll(opts.format, "\\n", "\n") + "\n"); err != nil {
			return err
		}
	}

	return nil
}

func (opts *getFederatedDatabaseOpts) run(ctx context.Context, _ io.Reader) error {

	params := &admin.GetFederatedDatabaseApiParams{
		GroupId:    opts.groupId,
		TenantName: opts.tenantName,
	}

	var err error
	opts.resp, _, err = opts.client.DataFederationApi.GetFederatedDatabaseWithParams(ctx, params).Execute()
	return err
}

func (opts *getFederatedDatabaseOpts) postRun(_ context.Context, w io.Writer) error {

	prettyJSON, errJson := json.MarshalIndent(opts.resp, "", " ")
	if errJson != nil {
		return errJson
	}

	if opts.format == "" {
		_, err := fmt.Fprintln(w, string(prettyJSON))
		return err
	}

	var parsedJSON interface{}
	if err := json.Unmarshal([]byte(prettyJSON), &parsedJSON); err != nil {
		return err
	}

	return opts.tmpl.Execute(w, parsedJSON)
}

func getFederatedDatabaseBuilder() *cobra.Command {
	opts := getFederatedDatabaseOpts{}
	cmd := &cobra.Command{
		Use:   "getFederatedDatabase",
		Short: "Return One Federated Database Instance in One Project",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.preRun()
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.run(cmd.Context(), cmd.InOrStdin())
		},
		PostRunE: func(cmd *cobra.Command, args []string) error {
			return opts.postRun(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "projectId", "", `Unique 24-hexadecimal digit string that identifies your project.`)
	cmd.Flags().StringVar(&opts.tenantName, "tenantName", "", `Human-readable label that identifies the Federated Database to return.`)

	_ = cmd.MarkFlagRequired("tenantName")
	cmd.Flags().StringVar(&opts.format, "format", "", "Format of the output")
	return cmd
}

type listDataFederationPrivateEndpointsOpts struct {
	client       *admin.APIClient
	groupId      string
	includeCount bool
	itemsPerPage int
	pageNum      int
	format       string
	tmpl         *template.Template
	resp         *admin.PaginatedPrivateNetworkEndpointIdEntry
}

func (opts *listDataFederationPrivateEndpointsOpts) preRun() (err error) {
	if opts.client, err = newClientWithAuth(config.UserAgent, config.Default()); err != nil {
		return err
	}

	if opts.groupId == "" {
		opts.groupId = config.ProjectID()
	}
	if opts.groupId == "" {
		return errors.New(`required flag(s) "projectId" not set`)
	}
	b, errDecode := hex.DecodeString(opts.groupId)
	if errDecode != nil || len(b) != 12 {
		return fmt.Errorf("the provided value '%s' is not a valid ID", opts.groupId)
	}

	if opts.format != "" {
		if opts.tmpl, err = template.New("").Parse(strings.ReplaceAll(opts.format, "\\n", "\n") + "\n"); err != nil {
			return err
		}
	}

	return nil
}

func (opts *listDataFederationPrivateEndpointsOpts) run(ctx context.Context, _ io.Reader) error {

	params := &admin.ListDataFederationPrivateEndpointsApiParams{
		GroupId:      opts.groupId,
		IncludeCount: &opts.includeCount,
		ItemsPerPage: &opts.itemsPerPage,
		PageNum:      &opts.pageNum,
	}

	var err error
	opts.resp, _, err = opts.client.DataFederationApi.ListDataFederationPrivateEndpointsWithParams(ctx, params).Execute()
	return err
}

func (opts *listDataFederationPrivateEndpointsOpts) postRun(_ context.Context, w io.Writer) error {

	prettyJSON, errJson := json.MarshalIndent(opts.resp, "", " ")
	if errJson != nil {
		return errJson
	}

	if opts.format == "" {
		_, err := fmt.Fprintln(w, string(prettyJSON))
		return err
	}

	var parsedJSON interface{}
	if err := json.Unmarshal([]byte(prettyJSON), &parsedJSON); err != nil {
		return err
	}

	return opts.tmpl.Execute(w, parsedJSON)
}

func listDataFederationPrivateEndpointsBuilder() *cobra.Command {
	opts := listDataFederationPrivateEndpointsOpts{}
	cmd := &cobra.Command{
		Use:   "listDataFederationPrivateEndpoints",
		Short: "Return All Federated Database Instance and Online Archive Private Endpoints in One Project",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.preRun()
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.run(cmd.Context(), cmd.InOrStdin())
		},
		PostRunE: func(cmd *cobra.Command, args []string) error {
			return opts.postRun(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "projectId", "", `Unique 24-hexadecimal digit string that identifies your project.`)
	cmd.Flags().BoolVar(&opts.includeCount, "includeCount", true, `Flag that indicates whether the response returns the total number of items (**totalCount**) in the response.`)
	cmd.Flags().IntVar(&opts.itemsPerPage, "itemsPerPage", 100, `Number of items that the response returns per page.`)
	cmd.Flags().IntVar(&opts.pageNum, "pageNum", 1, `Number of the page that displays the current set of the total objects that the response returns.`)

	cmd.Flags().StringVar(&opts.format, "format", "", "Format of the output")
	return cmd
}

type listFederatedDatabasesOpts struct {
	client  *admin.APIClient
	groupId string
	type_   string
	format  string
	tmpl    *template.Template
	resp    []admin.DataLakeTenant
}

func (opts *listFederatedDatabasesOpts) preRun() (err error) {
	if opts.client, err = newClientWithAuth(config.UserAgent, config.Default()); err != nil {
		return err
	}

	if opts.groupId == "" {
		opts.groupId = config.ProjectID()
	}
	if opts.groupId == "" {
		return errors.New(`required flag(s) "projectId" not set`)
	}
	b, errDecode := hex.DecodeString(opts.groupId)
	if errDecode != nil || len(b) != 12 {
		return fmt.Errorf("the provided value '%s' is not a valid ID", opts.groupId)
	}

	if opts.format != "" {
		if opts.tmpl, err = template.New("").Parse(strings.ReplaceAll(opts.format, "\\n", "\n") + "\n"); err != nil {
			return err
		}
	}

	return nil
}

func (opts *listFederatedDatabasesOpts) run(ctx context.Context, _ io.Reader) error {

	params := &admin.ListFederatedDatabasesApiParams{
		GroupId: opts.groupId,
		Type_:   &opts.type_,
	}

	var err error
	opts.resp, _, err = opts.client.DataFederationApi.ListFederatedDatabasesWithParams(ctx, params).Execute()
	return err
}

func (opts *listFederatedDatabasesOpts) postRun(_ context.Context, w io.Writer) error {

	prettyJSON, errJson := json.MarshalIndent(opts.resp, "", " ")
	if errJson != nil {
		return errJson
	}

	if opts.format == "" {
		_, err := fmt.Fprintln(w, string(prettyJSON))
		return err
	}

	var parsedJSON interface{}
	if err := json.Unmarshal([]byte(prettyJSON), &parsedJSON); err != nil {
		return err
	}

	return opts.tmpl.Execute(w, parsedJSON)
}

func listFederatedDatabasesBuilder() *cobra.Command {
	opts := listFederatedDatabasesOpts{}
	cmd := &cobra.Command{
		Use:   "listFederatedDatabases",
		Short: "Return All Federated Database Instances in One Project",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.preRun()
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.run(cmd.Context(), cmd.InOrStdin())
		},
		PostRunE: func(cmd *cobra.Command, args []string) error {
			return opts.postRun(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "projectId", "", `Unique 24-hexadecimal digit string that identifies your project.`)
	cmd.Flags().StringVar(&opts.type_, "type_", "&quot;USER&quot;", `Type of Federated Database Instances to return.`)

	cmd.Flags().StringVar(&opts.format, "format", "", "Format of the output")
	return cmd
}

type returnFederatedDatabaseQueryLimitOpts struct {
	client     *admin.APIClient
	groupId    string
	tenantName string
	limitName  string
	format     string
	tmpl       *template.Template
	resp       *admin.DataFederationTenantQueryLimit
}

func (opts *returnFederatedDatabaseQueryLimitOpts) preRun() (err error) {
	if opts.client, err = newClientWithAuth(config.UserAgent, config.Default()); err != nil {
		return err
	}

	if opts.groupId == "" {
		opts.groupId = config.ProjectID()
	}
	if opts.groupId == "" {
		return errors.New(`required flag(s) "projectId" not set`)
	}
	b, errDecode := hex.DecodeString(opts.groupId)
	if errDecode != nil || len(b) != 12 {
		return fmt.Errorf("the provided value '%s' is not a valid ID", opts.groupId)
	}

	if opts.format != "" {
		if opts.tmpl, err = template.New("").Parse(strings.ReplaceAll(opts.format, "\\n", "\n") + "\n"); err != nil {
			return err
		}
	}

	return nil
}

func (opts *returnFederatedDatabaseQueryLimitOpts) run(ctx context.Context, _ io.Reader) error {

	params := &admin.ReturnFederatedDatabaseQueryLimitApiParams{
		GroupId:    opts.groupId,
		TenantName: opts.tenantName,
		LimitName:  opts.limitName,
	}

	var err error
	opts.resp, _, err = opts.client.DataFederationApi.ReturnFederatedDatabaseQueryLimitWithParams(ctx, params).Execute()
	return err
}

func (opts *returnFederatedDatabaseQueryLimitOpts) postRun(_ context.Context, w io.Writer) error {

	prettyJSON, errJson := json.MarshalIndent(opts.resp, "", " ")
	if errJson != nil {
		return errJson
	}

	if opts.format == "" {
		_, err := fmt.Fprintln(w, string(prettyJSON))
		return err
	}

	var parsedJSON interface{}
	if err := json.Unmarshal([]byte(prettyJSON), &parsedJSON); err != nil {
		return err
	}

	return opts.tmpl.Execute(w, parsedJSON)
}

func returnFederatedDatabaseQueryLimitBuilder() *cobra.Command {
	opts := returnFederatedDatabaseQueryLimitOpts{}
	cmd := &cobra.Command{
		Use:   "returnFederatedDatabaseQueryLimit",
		Short: "Return One Federated Database Instance Query Limit for One Project",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.preRun()
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.run(cmd.Context(), cmd.InOrStdin())
		},
		PostRunE: func(cmd *cobra.Command, args []string) error {
			return opts.postRun(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "projectId", "", `Unique 24-hexadecimal digit string that identifies your project.`)
	cmd.Flags().StringVar(&opts.tenantName, "tenantName", "", `Human-readable label that identifies the federated database instance to which the query limit applies.`)
	cmd.Flags().StringVar(&opts.limitName, "limitName", "", `Human-readable label that identifies this data federation instance limit.

| Limit Name | Description | Default |
| --- | --- | --- |
| bytesProcessed.query | Limit on the number of bytes processed during a single data federation query | N/A |
| bytesProcessed.daily | Limit on the number of bytes processed for the data federation instance for the current day | N/A |
| bytesProcessed.weekly | Limit on the number of bytes processed for the data federation instance for the current week | N/A |
| bytesProcessed.monthly | Limit on the number of bytes processed for the data federation instance for the current month | N/A |
`)

	_ = cmd.MarkFlagRequired("tenantName")
	_ = cmd.MarkFlagRequired("limitName")
	cmd.Flags().StringVar(&opts.format, "format", "", "Format of the output")
	return cmd
}

type returnFederatedDatabaseQueryLimitsOpts struct {
	client     *admin.APIClient
	groupId    string
	tenantName string
	format     string
	tmpl       *template.Template
	resp       []admin.DataFederationTenantQueryLimit
}

func (opts *returnFederatedDatabaseQueryLimitsOpts) preRun() (err error) {
	if opts.client, err = newClientWithAuth(config.UserAgent, config.Default()); err != nil {
		return err
	}

	if opts.groupId == "" {
		opts.groupId = config.ProjectID()
	}
	if opts.groupId == "" {
		return errors.New(`required flag(s) "projectId" not set`)
	}
	b, errDecode := hex.DecodeString(opts.groupId)
	if errDecode != nil || len(b) != 12 {
		return fmt.Errorf("the provided value '%s' is not a valid ID", opts.groupId)
	}

	if opts.format != "" {
		if opts.tmpl, err = template.New("").Parse(strings.ReplaceAll(opts.format, "\\n", "\n") + "\n"); err != nil {
			return err
		}
	}

	return nil
}

func (opts *returnFederatedDatabaseQueryLimitsOpts) run(ctx context.Context, _ io.Reader) error {

	params := &admin.ReturnFederatedDatabaseQueryLimitsApiParams{
		GroupId:    opts.groupId,
		TenantName: opts.tenantName,
	}

	var err error
	opts.resp, _, err = opts.client.DataFederationApi.ReturnFederatedDatabaseQueryLimitsWithParams(ctx, params).Execute()
	return err
}

func (opts *returnFederatedDatabaseQueryLimitsOpts) postRun(_ context.Context, w io.Writer) error {

	prettyJSON, errJson := json.MarshalIndent(opts.resp, "", " ")
	if errJson != nil {
		return errJson
	}

	if opts.format == "" {
		_, err := fmt.Fprintln(w, string(prettyJSON))
		return err
	}

	var parsedJSON interface{}
	if err := json.Unmarshal([]byte(prettyJSON), &parsedJSON); err != nil {
		return err
	}

	return opts.tmpl.Execute(w, parsedJSON)
}

func returnFederatedDatabaseQueryLimitsBuilder() *cobra.Command {
	opts := returnFederatedDatabaseQueryLimitsOpts{}
	cmd := &cobra.Command{
		Use:   "returnFederatedDatabaseQueryLimits",
		Short: "Return All Query Limits for One Federated Database Instance",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.preRun()
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.run(cmd.Context(), cmd.InOrStdin())
		},
		PostRunE: func(cmd *cobra.Command, args []string) error {
			return opts.postRun(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "projectId", "", `Unique 24-hexadecimal digit string that identifies your project.`)
	cmd.Flags().StringVar(&opts.tenantName, "tenantName", "", `Human-readable label that identifies the federated database instance for which you want to retrieve query limits.`)

	_ = cmd.MarkFlagRequired("tenantName")
	cmd.Flags().StringVar(&opts.format, "format", "", "Format of the output")
	return cmd
}

type updateFederatedDatabaseOpts struct {
	client             *admin.APIClient
	groupId            string
	tenantName         string
	skipRoleValidation bool

	filename string
	fs       afero.Fs
	format   string
	tmpl     *template.Template
	resp     *admin.DataLakeTenant
}

func (opts *updateFederatedDatabaseOpts) preRun() (err error) {
	if opts.client, err = newClientWithAuth(config.UserAgent, config.Default()); err != nil {
		return err
	}

	if opts.groupId == "" {
		opts.groupId = config.ProjectID()
	}
	if opts.groupId == "" {
		return errors.New(`required flag(s) "projectId" not set`)
	}
	b, errDecode := hex.DecodeString(opts.groupId)
	if errDecode != nil || len(b) != 12 {
		return fmt.Errorf("the provided value '%s' is not a valid ID", opts.groupId)
	}

	if opts.format != "" {
		if opts.tmpl, err = template.New("").Parse(strings.ReplaceAll(opts.format, "\\n", "\n") + "\n"); err != nil {
			return err
		}
	}

	return nil
}

func (opts *updateFederatedDatabaseOpts) readData(r io.Reader) (*admin.DataLakeTenant, error) {
	var out *admin.DataLakeTenant

	var buf []byte
	var err error
	if opts.filename == "" {
		buf, err = io.ReadAll(r)
	} else {
		if exists, errExists := afero.Exists(opts.fs, opts.filename); !exists || errExists != nil {
			return nil, fmt.Errorf("file not found: %s", opts.filename)
		}
		buf, err = afero.ReadFile(opts.fs, opts.filename)
	}
	if err != nil {
		return nil, err
	}
	if err = json.Unmarshal(buf, &out); err != nil {
		return nil, err
	}
	return out, nil
}

func (opts *updateFederatedDatabaseOpts) run(ctx context.Context, r io.Reader) error {
	data, errData := opts.readData(r)
	if errData != nil {
		return errData
	}

	params := &admin.UpdateFederatedDatabaseApiParams{
		GroupId:            opts.groupId,
		TenantName:         opts.tenantName,
		SkipRoleValidation: &opts.skipRoleValidation,

		DataLakeTenant: data,
	}

	var err error
	opts.resp, _, err = opts.client.DataFederationApi.UpdateFederatedDatabaseWithParams(ctx, params).Execute()
	return err
}

func (opts *updateFederatedDatabaseOpts) postRun(_ context.Context, w io.Writer) error {

	prettyJSON, errJson := json.MarshalIndent(opts.resp, "", " ")
	if errJson != nil {
		return errJson
	}

	if opts.format == "" {
		_, err := fmt.Fprintln(w, string(prettyJSON))
		return err
	}

	var parsedJSON interface{}
	if err := json.Unmarshal([]byte(prettyJSON), &parsedJSON); err != nil {
		return err
	}

	return opts.tmpl.Execute(w, parsedJSON)
}

func updateFederatedDatabaseBuilder() *cobra.Command {
	opts := updateFederatedDatabaseOpts{
		fs: afero.NewOsFs(),
	}
	cmd := &cobra.Command{
		Use:   "updateFederatedDatabase",
		Short: "Update One Federated Database Instance in One Project",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.preRun()
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.run(cmd.Context(), cmd.InOrStdin())
		},
		PostRunE: func(cmd *cobra.Command, args []string) error {
			return opts.postRun(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "projectId", "", `Unique 24-hexadecimal digit string that identifies your project.`)
	cmd.Flags().StringVar(&opts.tenantName, "tenantName", "", `Human-readable label that identifies the federated database instance to update.`)
	cmd.Flags().BoolVar(&opts.skipRoleValidation, "skipRoleValidation", false, `Flag that indicates whether this request should check if the requesting IAM role can read from the S3 bucket. AWS checks if the role can list the objects in the bucket before writing to it. Some IAM roles only need write permissions. This flag allows you to skip that check.`)

	cmd.Flags().StringVarP(&opts.filename, "file", "f", "", "Path to an optional JSON configuration file if not passed stdin is expected")

	_ = cmd.MarkFlagRequired("tenantName")
	_ = cmd.MarkFlagRequired("skipRoleValidation")
	cmd.Flags().StringVar(&opts.format, "format", "", "Format of the output")
	return cmd
}

func dataFederationBuilder() *cobra.Command {
	const use = "dataFederation"
	cmd := &cobra.Command{
		Use:     use,
		Short:   `Returns, adds, edits, and removes Federated Database Instances. This resource requires your project ID. Changes to federated database instance configurations can affect costs.`,
		Aliases: cli.GenerateAliases(use),
	}
	cmd.AddCommand(
		createDataFederationPrivateEndpointBuilder(),
		createFederatedDatabaseBuilder(),
		createOneDataFederationQueryLimitBuilder(),
		deleteDataFederationPrivateEndpointBuilder(),
		deleteFederatedDatabaseBuilder(),
		deleteOneDataFederationInstanceQueryLimitBuilder(),
		downloadFederatedDatabaseQueryLogsBuilder(),
		getDataFederationPrivateEndpointBuilder(),
		getFederatedDatabaseBuilder(),
		listDataFederationPrivateEndpointsBuilder(),
		listFederatedDatabasesBuilder(),
		returnFederatedDatabaseQueryLimitBuilder(),
		returnFederatedDatabaseQueryLimitsBuilder(),
		updateFederatedDatabaseBuilder(),
	)
	return cmd
}
