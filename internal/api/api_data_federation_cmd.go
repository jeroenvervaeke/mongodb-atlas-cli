// Copyright 2023 MongoDB Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"os"

	"github.com/mongodb/mongodb-atlas-cli/internal/cli"
	"github.com/mongodb/mongodb-atlas-cli/internal/jsonwriter"
	"github.com/spf13/afero"
	"github.com/spf13/cobra"
	"go.mongodb.org/atlas-sdk/v20230201008/admin"
)

type createDataFederationPrivateEndpointOpts struct {
	cli.GlobalOpts
	client  *admin.APIClient
	groupId string

	filename string
	fs       afero.Fs
}

func (opts *createDataFederationPrivateEndpointOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *createDataFederationPrivateEndpointOpts) readData() (*admin.PrivateNetworkEndpointIdEntry, error) {
	var out *admin.PrivateNetworkEndpointIdEntry

	var buf []byte
	var err error
	if opts.filename == "" {
		buf, err = io.ReadAll(os.Stdin)
	} else {
		if exists, errExists := afero.Exists(opts.fs, opts.filename); !exists || errExists != nil {
			return nil, fmt.Errorf("file not found: %s", opts.filename)
		}
		buf, err = afero.ReadFile(opts.fs, opts.filename)
	}
	if err != nil {
		return nil, err
	}
	if err = json.Unmarshal(buf, &out); err != nil {
		return nil, err
	}
	return out, nil
}

func (opts *createDataFederationPrivateEndpointOpts) Run(ctx context.Context, w io.Writer) error {
	data, errData := opts.readData()
	if errData != nil {
		return errData
	}
	params := &admin.CreateDataFederationPrivateEndpointApiParams{
		GroupId: opts.groupId,

		PrivateNetworkEndpointIdEntry: data,
	}
	resp, _, err := opts.client.DataFederationApi.CreateDataFederationPrivateEndpointWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return jsonwriter.Print(w, resp)
}

func createDataFederationPrivateEndpointBuilder() *cobra.Command {
	opts := createDataFederationPrivateEndpointOpts{
		fs: afero.NewOsFs(),
	}
	cmd := &cobra.Command{
		Use:   "createDataFederationPrivateEndpoint",
		Short: "Create One Federated Database Instance and Online Archive Private Endpoint for One Project",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)

	cmd.Flags().StringVarP(&opts.filename, "file", "f", "", "Path to an optional JSON configuration file if not passed stdin is expected")

	_ = cmd.MarkFlagRequired("groupId")
	return cmd
}

type createFederatedDatabaseOpts struct {
	cli.GlobalOpts
	client  *admin.APIClient
	groupId string

	skipRoleValidation bool
	filename           string
	fs                 afero.Fs
}

func (opts *createFederatedDatabaseOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *createFederatedDatabaseOpts) readData() (*admin.DataLakeTenant, error) {
	var out *admin.DataLakeTenant

	var buf []byte
	var err error
	if opts.filename == "" {
		buf, err = io.ReadAll(os.Stdin)
	} else {
		if exists, errExists := afero.Exists(opts.fs, opts.filename); !exists || errExists != nil {
			return nil, fmt.Errorf("file not found: %s", opts.filename)
		}
		buf, err = afero.ReadFile(opts.fs, opts.filename)
	}
	if err != nil {
		return nil, err
	}
	if err = json.Unmarshal(buf, &out); err != nil {
		return nil, err
	}
	return out, nil
}

func (opts *createFederatedDatabaseOpts) Run(ctx context.Context, w io.Writer) error {
	data, errData := opts.readData()
	if errData != nil {
		return errData
	}
	params := &admin.CreateFederatedDatabaseApiParams{
		GroupId: opts.groupId,

		SkipRoleValidation: &opts.skipRoleValidation,

		DataLakeTenant: data,
	}
	resp, _, err := opts.client.DataFederationApi.CreateFederatedDatabaseWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return jsonwriter.Print(w, resp)
}

func createFederatedDatabaseBuilder() *cobra.Command {
	opts := createFederatedDatabaseOpts{
		fs: afero.NewOsFs(),
	}
	cmd := &cobra.Command{
		Use:   "createFederatedDatabase",
		Short: "Create One Federated Database Instance in One Project",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)

	cmd.Flags().BoolVar(&opts.skipRoleValidation, "skipRoleValidation", false, `Flag that indicates whether this request should check if the requesting IAM role can read from the S3 bucket. AWS checks if the role can list the objects in the bucket before writing to it. Some IAM roles only need write permissions. This flag allows you to skip that check.`)
	cmd.Flags().StringVarP(&opts.filename, "file", "f", "", "Path to an optional JSON configuration file if not passed stdin is expected")

	_ = cmd.MarkFlagRequired("groupId")
	return cmd
}

type createOneDataFederationQueryLimitOpts struct {
	cli.GlobalOpts
	client     *admin.APIClient
	groupId    string
	tenantName string
	limitName  string

	filename string
	fs       afero.Fs
}

func (opts *createOneDataFederationQueryLimitOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *createOneDataFederationQueryLimitOpts) readData() (*admin.DataFederationTenantQueryLimit, error) {
	var out *admin.DataFederationTenantQueryLimit

	var buf []byte
	var err error
	if opts.filename == "" {
		buf, err = io.ReadAll(os.Stdin)
	} else {
		if exists, errExists := afero.Exists(opts.fs, opts.filename); !exists || errExists != nil {
			return nil, fmt.Errorf("file not found: %s", opts.filename)
		}
		buf, err = afero.ReadFile(opts.fs, opts.filename)
	}
	if err != nil {
		return nil, err
	}
	if err = json.Unmarshal(buf, &out); err != nil {
		return nil, err
	}
	return out, nil
}

func (opts *createOneDataFederationQueryLimitOpts) Run(ctx context.Context, w io.Writer) error {
	data, errData := opts.readData()
	if errData != nil {
		return errData
	}
	params := &admin.CreateOneDataFederationQueryLimitApiParams{
		GroupId:    opts.groupId,
		TenantName: opts.tenantName,
		LimitName:  opts.limitName,

		DataFederationTenantQueryLimit: data,
	}
	resp, _, err := opts.client.DataFederationApi.CreateOneDataFederationQueryLimitWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return jsonwriter.Print(w, resp)
}

func createOneDataFederationQueryLimitBuilder() *cobra.Command {
	opts := createOneDataFederationQueryLimitOpts{
		fs: afero.NewOsFs(),
	}
	cmd := &cobra.Command{
		Use:   "createOneDataFederationQueryLimit",
		Short: "Configure One Query Limit for One Federated Database Instance",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)
	cmd.Flags().StringVar(&opts.tenantName, "tenantName", "", `Human-readable label that identifies the federated database instance to which the query limit applies.`)
	cmd.Flags().StringVar(&opts.limitName, "limitName", "", `Human-readable label that identifies this data federation instance limit.

| Limit Name | Description | Default |
| --- | --- | --- |
| bytesProcessed.query | Limit on the number of bytes processed during a single data federation query | N/A |
| bytesProcessed.daily | Limit on the number of bytes processed for the data federation instance for the current day | N/A |
| bytesProcessed.weekly | Limit on the number of bytes processed for the data federation instance for the current week | N/A |
| bytesProcessed.monthly | Limit on the number of bytes processed for the data federation instance for the current month | N/A |
`)

	cmd.Flags().StringVarP(&opts.filename, "file", "f", "", "Path to an optional JSON configuration file if not passed stdin is expected")

	_ = cmd.MarkFlagRequired("groupId")
	_ = cmd.MarkFlagRequired("tenantName")
	_ = cmd.MarkFlagRequired("limitName")
	return cmd
}

type deleteDataFederationPrivateEndpointOpts struct {
	cli.GlobalOpts
	client     *admin.APIClient
	groupId    string
	endpointId string
}

func (opts *deleteDataFederationPrivateEndpointOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *deleteDataFederationPrivateEndpointOpts) Run(ctx context.Context, w io.Writer) error {
	params := &admin.DeleteDataFederationPrivateEndpointApiParams{
		GroupId:    opts.groupId,
		EndpointId: opts.endpointId,
	}
	resp, _, err := opts.client.DataFederationApi.DeleteDataFederationPrivateEndpointWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return jsonwriter.Print(w, resp)
}

func deleteDataFederationPrivateEndpointBuilder() *cobra.Command {
	opts := deleteDataFederationPrivateEndpointOpts{}
	cmd := &cobra.Command{
		Use:   "deleteDataFederationPrivateEndpoint",
		Short: "Remove One Federated Database Instance and Online Archive Private Endpoint from One Project",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)
	cmd.Flags().StringVar(&opts.endpointId, "endpointId", "", `Unique 22-character alphanumeric string that identifies the private endpoint to remove. Atlas Data Federation supports AWS private endpoints using the AWS PrivateLink feature.`)

	_ = cmd.MarkFlagRequired("groupId")
	_ = cmd.MarkFlagRequired("endpointId")
	return cmd
}

type deleteFederatedDatabaseOpts struct {
	cli.GlobalOpts
	client     *admin.APIClient
	groupId    string
	tenantName string
}

func (opts *deleteFederatedDatabaseOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *deleteFederatedDatabaseOpts) Run(ctx context.Context, w io.Writer) error {
	params := &admin.DeleteFederatedDatabaseApiParams{
		GroupId:    opts.groupId,
		TenantName: opts.tenantName,
	}
	resp, _, err := opts.client.DataFederationApi.DeleteFederatedDatabaseWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return jsonwriter.Print(w, resp)
}

func deleteFederatedDatabaseBuilder() *cobra.Command {
	opts := deleteFederatedDatabaseOpts{}
	cmd := &cobra.Command{
		Use:   "deleteFederatedDatabase",
		Short: "Remove One Federated Database Instance from One Project",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)
	cmd.Flags().StringVar(&opts.tenantName, "tenantName", "", `Human-readable label that identifies the federated database instance to remove.`)

	_ = cmd.MarkFlagRequired("groupId")
	_ = cmd.MarkFlagRequired("tenantName")
	return cmd
}

type deleteOneDataFederationInstanceQueryLimitOpts struct {
	cli.GlobalOpts
	client     *admin.APIClient
	groupId    string
	tenantName string
	limitName  string
}

func (opts *deleteOneDataFederationInstanceQueryLimitOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *deleteOneDataFederationInstanceQueryLimitOpts) Run(ctx context.Context, w io.Writer) error {
	params := &admin.DeleteOneDataFederationInstanceQueryLimitApiParams{
		GroupId:    opts.groupId,
		TenantName: opts.tenantName,
		LimitName:  opts.limitName,
	}
	resp, _, err := opts.client.DataFederationApi.DeleteOneDataFederationInstanceQueryLimitWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return jsonwriter.Print(w, resp)
}

func deleteOneDataFederationInstanceQueryLimitBuilder() *cobra.Command {
	opts := deleteOneDataFederationInstanceQueryLimitOpts{}
	cmd := &cobra.Command{
		Use:   "deleteOneDataFederationInstanceQueryLimit",
		Short: "Delete One Query Limit For One Federated Database Instance",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)
	cmd.Flags().StringVar(&opts.tenantName, "tenantName", "", `Human-readable label that identifies the federated database instance to which the query limit applies.`)
	cmd.Flags().StringVar(&opts.limitName, "limitName", "", `Human-readable label that identifies this data federation instance limit.

| Limit Name | Description | Default |
| --- | --- | --- |
| bytesProcessed.query | Limit on the number of bytes processed during a single data federation query | N/A |
| bytesProcessed.daily | Limit on the number of bytes processed for the data federation instance for the current day | N/A |
| bytesProcessed.weekly | Limit on the number of bytes processed for the data federation instance for the current week | N/A |
| bytesProcessed.monthly | Limit on the number of bytes processed for the data federation instance for the current month | N/A |
`)

	_ = cmd.MarkFlagRequired("groupId")
	_ = cmd.MarkFlagRequired("tenantName")
	_ = cmd.MarkFlagRequired("limitName")
	return cmd
}

type downloadFederatedDatabaseQueryLogsOpts struct {
	cli.GlobalOpts
	client     *admin.APIClient
	groupId    string
	tenantName string
	endDate    int64
	startDate  int64
}

func (opts *downloadFederatedDatabaseQueryLogsOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *downloadFederatedDatabaseQueryLogsOpts) Run(ctx context.Context, w io.Writer) error {
	params := &admin.DownloadFederatedDatabaseQueryLogsApiParams{
		GroupId:    opts.groupId,
		TenantName: opts.tenantName,
		EndDate:    &opts.endDate,
		StartDate:  &opts.startDate,
	}
	resp, _, err := opts.client.DataFederationApi.DownloadFederatedDatabaseQueryLogsWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return jsonwriter.Print(w, resp)
}

func downloadFederatedDatabaseQueryLogsBuilder() *cobra.Command {
	opts := downloadFederatedDatabaseQueryLogsOpts{}
	cmd := &cobra.Command{
		Use:   "downloadFederatedDatabaseQueryLogs",
		Short: "Download Query Logs for One Federated Database Instance",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)
	cmd.Flags().StringVar(&opts.tenantName, "tenantName", "", `Human-readable label that identifies the federated database instance for which you want to download query logs.`)
	cmd.Flags().Int64Var(&opts.endDate, "endDate", 0, `Timestamp that specifies the end point for the range of log messages to download.  MongoDB Cloud expresses this timestamp in the number of seconds that have elapsed since the UNIX epoch.`)
	cmd.Flags().Int64Var(&opts.startDate, "startDate", 0, `Timestamp that specifies the starting point for the range of log messages to download. MongoDB Cloud expresses this timestamp in the number of seconds that have elapsed since the UNIX epoch.`)

	_ = cmd.MarkFlagRequired("groupId")
	_ = cmd.MarkFlagRequired("tenantName")
	return cmd
}

type getDataFederationPrivateEndpointOpts struct {
	cli.GlobalOpts
	client     *admin.APIClient
	groupId    string
	endpointId string
}

func (opts *getDataFederationPrivateEndpointOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *getDataFederationPrivateEndpointOpts) Run(ctx context.Context, w io.Writer) error {
	params := &admin.GetDataFederationPrivateEndpointApiParams{
		GroupId:    opts.groupId,
		EndpointId: opts.endpointId,
	}
	resp, _, err := opts.client.DataFederationApi.GetDataFederationPrivateEndpointWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return jsonwriter.Print(w, resp)
}

func getDataFederationPrivateEndpointBuilder() *cobra.Command {
	opts := getDataFederationPrivateEndpointOpts{}
	cmd := &cobra.Command{
		Use:   "getDataFederationPrivateEndpoint",
		Short: "Return One Federated Database Instance and Online Archive Private Endpoint in One Project",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)
	cmd.Flags().StringVar(&opts.endpointId, "endpointId", "", `Unique 22-character alphanumeric string that identifies the private endpoint to return. Atlas Data Federation supports AWS private endpoints using the AWS PrivateLink feature.`)

	_ = cmd.MarkFlagRequired("groupId")
	_ = cmd.MarkFlagRequired("endpointId")
	return cmd
}

type getFederatedDatabaseOpts struct {
	cli.GlobalOpts
	client     *admin.APIClient
	groupId    string
	tenantName string
}

func (opts *getFederatedDatabaseOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *getFederatedDatabaseOpts) Run(ctx context.Context, w io.Writer) error {
	params := &admin.GetFederatedDatabaseApiParams{
		GroupId:    opts.groupId,
		TenantName: opts.tenantName,
	}
	resp, _, err := opts.client.DataFederationApi.GetFederatedDatabaseWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return jsonwriter.Print(w, resp)
}

func getFederatedDatabaseBuilder() *cobra.Command {
	opts := getFederatedDatabaseOpts{}
	cmd := &cobra.Command{
		Use:   "getFederatedDatabase",
		Short: "Return One Federated Database Instance in One Project",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)
	cmd.Flags().StringVar(&opts.tenantName, "tenantName", "", `Human-readable label that identifies the Federated Database to return.`)

	_ = cmd.MarkFlagRequired("groupId")
	_ = cmd.MarkFlagRequired("tenantName")
	return cmd
}

type listDataFederationPrivateEndpointsOpts struct {
	cli.GlobalOpts
	client       *admin.APIClient
	groupId      string
	includeCount bool
	itemsPerPage int
	pageNum      int
}

func (opts *listDataFederationPrivateEndpointsOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *listDataFederationPrivateEndpointsOpts) Run(ctx context.Context, w io.Writer) error {
	params := &admin.ListDataFederationPrivateEndpointsApiParams{
		GroupId:      opts.groupId,
		IncludeCount: &opts.includeCount,
		ItemsPerPage: &opts.itemsPerPage,
		PageNum:      &opts.pageNum,
	}
	resp, _, err := opts.client.DataFederationApi.ListDataFederationPrivateEndpointsWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return jsonwriter.Print(w, resp)
}

func listDataFederationPrivateEndpointsBuilder() *cobra.Command {
	opts := listDataFederationPrivateEndpointsOpts{}
	cmd := &cobra.Command{
		Use:   "listDataFederationPrivateEndpoints",
		Short: "Return All Federated Database Instance and Online Archive Private Endpoints in One Project",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)
	cmd.Flags().BoolVar(&opts.includeCount, "includeCount", true, `Flag that indicates whether the response returns the total number of items (**totalCount**) in the response.`)
	cmd.Flags().IntVar(&opts.itemsPerPage, "itemsPerPage", 100, `Number of items that the response returns per page.`)
	cmd.Flags().IntVar(&opts.pageNum, "pageNum", 1, `Number of the page that displays the current set of the total objects that the response returns.`)

	_ = cmd.MarkFlagRequired("groupId")
	return cmd
}

type listFederatedDatabasesOpts struct {
	cli.GlobalOpts
	client  *admin.APIClient
	groupId string
	type_   string
}

func (opts *listFederatedDatabasesOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *listFederatedDatabasesOpts) Run(ctx context.Context, w io.Writer) error {
	params := &admin.ListFederatedDatabasesApiParams{
		GroupId: opts.groupId,
		Type_:   &opts.type_,
	}
	resp, _, err := opts.client.DataFederationApi.ListFederatedDatabasesWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return jsonwriter.Print(w, resp)
}

func listFederatedDatabasesBuilder() *cobra.Command {
	opts := listFederatedDatabasesOpts{}
	cmd := &cobra.Command{
		Use:   "listFederatedDatabases",
		Short: "Return All Federated Database Instances in One Project",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)
	cmd.Flags().StringVar(&opts.type_, "type_", "&quot;USER&quot;", `Type of Federated Database Instances to return.`)

	_ = cmd.MarkFlagRequired("groupId")
	return cmd
}

type returnFederatedDatabaseQueryLimitOpts struct {
	cli.GlobalOpts
	client     *admin.APIClient
	groupId    string
	tenantName string
	limitName  string
}

func (opts *returnFederatedDatabaseQueryLimitOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *returnFederatedDatabaseQueryLimitOpts) Run(ctx context.Context, w io.Writer) error {
	params := &admin.ReturnFederatedDatabaseQueryLimitApiParams{
		GroupId:    opts.groupId,
		TenantName: opts.tenantName,
		LimitName:  opts.limitName,
	}
	resp, _, err := opts.client.DataFederationApi.ReturnFederatedDatabaseQueryLimitWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return jsonwriter.Print(w, resp)
}

func returnFederatedDatabaseQueryLimitBuilder() *cobra.Command {
	opts := returnFederatedDatabaseQueryLimitOpts{}
	cmd := &cobra.Command{
		Use:   "returnFederatedDatabaseQueryLimit",
		Short: "Return One Federated Database Instance Query Limit for One Project",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)
	cmd.Flags().StringVar(&opts.tenantName, "tenantName", "", `Human-readable label that identifies the federated database instance to which the query limit applies.`)
	cmd.Flags().StringVar(&opts.limitName, "limitName", "", `Human-readable label that identifies this data federation instance limit.

| Limit Name | Description | Default |
| --- | --- | --- |
| bytesProcessed.query | Limit on the number of bytes processed during a single data federation query | N/A |
| bytesProcessed.daily | Limit on the number of bytes processed for the data federation instance for the current day | N/A |
| bytesProcessed.weekly | Limit on the number of bytes processed for the data federation instance for the current week | N/A |
| bytesProcessed.monthly | Limit on the number of bytes processed for the data federation instance for the current month | N/A |
`)

	_ = cmd.MarkFlagRequired("groupId")
	_ = cmd.MarkFlagRequired("tenantName")
	_ = cmd.MarkFlagRequired("limitName")
	return cmd
}

type returnFederatedDatabaseQueryLimitsOpts struct {
	cli.GlobalOpts
	client     *admin.APIClient
	groupId    string
	tenantName string
}

func (opts *returnFederatedDatabaseQueryLimitsOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *returnFederatedDatabaseQueryLimitsOpts) Run(ctx context.Context, w io.Writer) error {
	params := &admin.ReturnFederatedDatabaseQueryLimitsApiParams{
		GroupId:    opts.groupId,
		TenantName: opts.tenantName,
	}
	resp, _, err := opts.client.DataFederationApi.ReturnFederatedDatabaseQueryLimitsWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return jsonwriter.Print(w, resp)
}

func returnFederatedDatabaseQueryLimitsBuilder() *cobra.Command {
	opts := returnFederatedDatabaseQueryLimitsOpts{}
	cmd := &cobra.Command{
		Use:   "returnFederatedDatabaseQueryLimits",
		Short: "Return All Query Limits for One Federated Database Instance",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)
	cmd.Flags().StringVar(&opts.tenantName, "tenantName", "", `Human-readable label that identifies the federated database instance for which you want to retrieve query limits.`)

	_ = cmd.MarkFlagRequired("groupId")
	_ = cmd.MarkFlagRequired("tenantName")
	return cmd
}

type updateFederatedDatabaseOpts struct {
	cli.GlobalOpts
	client             *admin.APIClient
	groupId            string
	tenantName         string
	skipRoleValidation bool

	filename string
	fs       afero.Fs
}

func (opts *updateFederatedDatabaseOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *updateFederatedDatabaseOpts) readData() (*admin.DataLakeTenant, error) {
	var out *admin.DataLakeTenant

	var buf []byte
	var err error
	if opts.filename == "" {
		buf, err = io.ReadAll(os.Stdin)
	} else {
		if exists, errExists := afero.Exists(opts.fs, opts.filename); !exists || errExists != nil {
			return nil, fmt.Errorf("file not found: %s", opts.filename)
		}
		buf, err = afero.ReadFile(opts.fs, opts.filename)
	}
	if err != nil {
		return nil, err
	}
	if err = json.Unmarshal(buf, &out); err != nil {
		return nil, err
	}
	return out, nil
}

func (opts *updateFederatedDatabaseOpts) Run(ctx context.Context, w io.Writer) error {
	data, errData := opts.readData()
	if errData != nil {
		return errData
	}
	params := &admin.UpdateFederatedDatabaseApiParams{
		GroupId:            opts.groupId,
		TenantName:         opts.tenantName,
		SkipRoleValidation: &opts.skipRoleValidation,

		DataLakeTenant: data,
	}
	resp, _, err := opts.client.DataFederationApi.UpdateFederatedDatabaseWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return jsonwriter.Print(w, resp)
}

func updateFederatedDatabaseBuilder() *cobra.Command {
	opts := updateFederatedDatabaseOpts{
		fs: afero.NewOsFs(),
	}
	cmd := &cobra.Command{
		Use:   "updateFederatedDatabase",
		Short: "Update One Federated Database Instance in One Project",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)
	cmd.Flags().StringVar(&opts.tenantName, "tenantName", "", `Human-readable label that identifies the federated database instance to update.`)
	cmd.Flags().BoolVar(&opts.skipRoleValidation, "skipRoleValidation", false, `Flag that indicates whether this request should check if the requesting IAM role can read from the S3 bucket. AWS checks if the role can list the objects in the bucket before writing to it. Some IAM roles only need write permissions. This flag allows you to skip that check.`)

	cmd.Flags().StringVarP(&opts.filename, "file", "f", "", "Path to an optional JSON configuration file if not passed stdin is expected")

	_ = cmd.MarkFlagRequired("groupId")
	_ = cmd.MarkFlagRequired("tenantName")
	_ = cmd.MarkFlagRequired("skipRoleValidation")
	return cmd
}

func dataFederationBuilder() *cobra.Command {
	cmd := &cobra.Command{
		Use:   "dataFederation",
		Short: `Returns, adds, edits, and removes Federated Database Instances. This resource requires your project ID. Changes to federated database instance configurations can affect costs.`,
	}
	cmd.AddCommand(
		createDataFederationPrivateEndpointBuilder(),
		createFederatedDatabaseBuilder(),
		createOneDataFederationQueryLimitBuilder(),
		deleteDataFederationPrivateEndpointBuilder(),
		deleteFederatedDatabaseBuilder(),
		deleteOneDataFederationInstanceQueryLimitBuilder(),
		downloadFederatedDatabaseQueryLogsBuilder(),
		getDataFederationPrivateEndpointBuilder(),
		getFederatedDatabaseBuilder(),
		listDataFederationPrivateEndpointsBuilder(),
		listFederatedDatabasesBuilder(),
		returnFederatedDatabaseQueryLimitBuilder(),
		returnFederatedDatabaseQueryLimitsBuilder(),
		updateFederatedDatabaseBuilder(),
	)
	return cmd
}
