// Copyright 2024 MongoDB Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"context"
	"encoding/hex"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"strings"
	"text/template"
	"time"

	"github.com/briandowns/spinner"
	"github.com/mongodb/mongodb-atlas-cli/atlascli/internal/cli"
	"github.com/mongodb/mongodb-atlas-cli/atlascli/internal/config"
	"github.com/spf13/afero"
	"github.com/spf13/cobra"
	"go.mongodb.org/atlas-sdk/v20231115012/admin"
)

type createClusterOpts struct {
	client  *admin.APIClient
	groupId string

	filename     string
	fs           afero.Fs
	format       string
	tmpl         *template.Template
	resp         *admin.AdvancedClusterDescription
	watchEnabled bool
	watchTimeout string
	wt           time.Duration
}

func (opts *createClusterOpts) preRun() (err error) {
	if opts.client, err = newClientWithAuth(config.UserAgent, config.Default()); err != nil {
		return err
	}

	if opts.groupId == "" {
		opts.groupId = config.ProjectID()
	}
	if opts.groupId == "" {
		return errors.New(`required flag(s) "projectId" not set`)
	}
	b, errDecode := hex.DecodeString(opts.groupId)
	if errDecode != nil || len(b) != 12 {
		return fmt.Errorf("the provided value '%s' is not a valid ID", opts.groupId)
	}

	if opts.format != "" {
		if opts.tmpl, err = template.New("").Parse(strings.ReplaceAll(opts.format, "\\n", "\n") + "\n"); err != nil {
			return err
		}
	}
	if opts.wt, err = time.ParseDuration(opts.watchTimeout); err != nil {
		return err
	}

	return nil
}

func (opts *createClusterOpts) readData(r io.Reader) (*admin.AdvancedClusterDescription, error) {
	var out *admin.AdvancedClusterDescription

	var buf []byte
	var err error
	if opts.filename == "" {
		buf, err = io.ReadAll(r)
	} else {
		if exists, errExists := afero.Exists(opts.fs, opts.filename); !exists || errExists != nil {
			return nil, fmt.Errorf("file not found: %s", opts.filename)
		}
		buf, err = afero.ReadFile(opts.fs, opts.filename)
	}
	if err != nil {
		return nil, err
	}
	if err = json.Unmarshal(buf, &out); err != nil {
		return nil, err
	}
	return out, nil
}

func (opts *createClusterOpts) run(ctx context.Context, r io.Reader) error {
	data, errData := opts.readData(r)
	if errData != nil {
		return errData
	}

	params := &admin.CreateClusterApiParams{
		GroupId: opts.groupId,

		AdvancedClusterDescription: data,
	}

	var err error
	opts.resp, _, err = opts.client.ClustersApi.CreateClusterWithParams(ctx, params).Execute()
	return err
}

func (opts *createClusterOpts) watch(ctx context.Context) error {
	if !opts.watchEnabled {
		return nil
	}

	spin := spinner.New(spinner.CharSets[9], 100*time.Millisecond)
	spin.Start()
	defer spin.Stop()

	watchCtx, cancel := context.WithTimeout(ctx, opts.wt)
	defer cancel()
	for {
		select {
		case <-watchCtx.Done():
			return watchCtx.Err()
		default:
			params := &admin.GetClusterApiParams{
				GroupId:     *opts.resp.GroupId,
				ClusterName: *opts.resp.Name,
			}
			resp, _, err := opts.client.ClustersApi.GetClusterWithParams(ctx, params).Execute()
			if err != nil {
				return err
			}
			if resp.StateName != nil && *resp.StateName == "IDLE" {
				return nil
			}
			time.Sleep(4 * time.Second)
		}
	}
}

func (opts *createClusterOpts) postRun(ctx context.Context, w io.Writer) error {
	if err := opts.watch(ctx); err != nil {
		return err
	}

	prettyJSON, errJson := json.MarshalIndent(opts.resp, "", " ")
	if errJson != nil {
		return errJson
	}

	if opts.format == "" {
		_, err := fmt.Fprintln(w, string(prettyJSON))
		return err
	}

	var parsedJSON interface{}
	if err := json.Unmarshal([]byte(prettyJSON), &parsedJSON); err != nil {
		return err
	}

	return opts.tmpl.Execute(w, parsedJSON)
}

func createClusterBuilder() *cobra.Command {
	opts := createClusterOpts{
		fs: afero.NewOsFs(),
	}
	const use = "createCluster"
	cmd := &cobra.Command{
		Use:     use,
		Short:   "TEST DESCRIPTION",
		Aliases: cli.GenerateAliases(use),
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.preRun()
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.run(cmd.Context(), cmd.InOrStdin())
		},
		PostRunE: func(cmd *cobra.Command, args []string) error {
			return opts.postRun(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "projectId", "", `Unique 24-hexadecimal digit string that identifies your project.`)

	cmd.Flags().StringVarP(&opts.filename, "file", "f", "", "Path to an optional JSON configuration file if not passed stdin is expected")

	cmd.Flags().StringVar(&opts.format, "format", "", "Format of the output")
	cmd.Flags().BoolVarP(&opts.watchEnabled, "watch", "w", false, "WATCH DESCRIPTION")
	cmd.Flags().StringVar(&opts.watchTimeout, "timeout", "5m", "WATCH TIMEOUT DESCRIPTION")
	return cmd
}

type deleteClusterOpts struct {
	client        *admin.APIClient
	groupId       string
	clusterName   string
	retainBackups bool
}

func (opts *deleteClusterOpts) preRun() (err error) {
	if opts.client, err = newClientWithAuth(config.UserAgent, config.Default()); err != nil {
		return err
	}

	if opts.groupId == "" {
		opts.groupId = config.ProjectID()
	}
	if opts.groupId == "" {
		return errors.New(`required flag(s) "projectId" not set`)
	}
	b, errDecode := hex.DecodeString(opts.groupId)
	if errDecode != nil || len(b) != 12 {
		return fmt.Errorf("the provided value '%s' is not a valid ID", opts.groupId)
	}

	return nil
}

func (opts *deleteClusterOpts) run(ctx context.Context, _ io.Reader) error {

	params := &admin.DeleteClusterApiParams{
		GroupId:       opts.groupId,
		ClusterName:   opts.clusterName,
		RetainBackups: &opts.retainBackups,
	}

	var err error
	_, err = opts.client.ClustersApi.DeleteClusterWithParams(ctx, params).Execute()
	return err
}

func (opts *deleteClusterOpts) postRun(_ context.Context, _ io.Writer) error {

	return nil
}

func deleteClusterBuilder() *cobra.Command {
	opts := deleteClusterOpts{}
	const use = "deleteCluster"
	cmd := &cobra.Command{
		Use:     use,
		Short:   "Remove One Cluster from One Project",
		Aliases: cli.GenerateAliases(use),
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.preRun()
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.run(cmd.Context(), cmd.InOrStdin())
		},
		PostRunE: func(cmd *cobra.Command, args []string) error {
			return opts.postRun(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "projectId", "", `Unique 24-hexadecimal digit string that identifies your project.`)
	cmd.Flags().StringVar(&opts.clusterName, "clusterName", "", `Human-readable label that identifies the cluster.`)
	cmd.Flags().BoolVar(&opts.retainBackups, "retainBackups", false, `Flag that indicates whether to retain backup snapshots for the deleted dedicated cluster.`)

	_ = cmd.MarkFlagRequired("clusterName")
	return cmd
}

type getClusterOpts struct {
	client      *admin.APIClient
	groupId     string
	clusterName string
	format      string
	tmpl        *template.Template
	resp        *admin.AdvancedClusterDescription
}

func (opts *getClusterOpts) preRun() (err error) {
	if opts.client, err = newClientWithAuth(config.UserAgent, config.Default()); err != nil {
		return err
	}

	if opts.groupId == "" {
		opts.groupId = config.ProjectID()
	}
	if opts.groupId == "" {
		return errors.New(`required flag(s) "projectId" not set`)
	}
	b, errDecode := hex.DecodeString(opts.groupId)
	if errDecode != nil || len(b) != 12 {
		return fmt.Errorf("the provided value '%s' is not a valid ID", opts.groupId)
	}

	if opts.format != "" {
		if opts.tmpl, err = template.New("").Parse(strings.ReplaceAll(opts.format, "\\n", "\n") + "\n"); err != nil {
			return err
		}
	}

	return nil
}

func (opts *getClusterOpts) run(ctx context.Context, _ io.Reader) error {

	params := &admin.GetClusterApiParams{
		GroupId:     opts.groupId,
		ClusterName: opts.clusterName,
	}

	var err error
	opts.resp, _, err = opts.client.ClustersApi.GetClusterWithParams(ctx, params).Execute()
	return err
}

func (opts *getClusterOpts) postRun(_ context.Context, w io.Writer) error {

	prettyJSON, errJson := json.MarshalIndent(opts.resp, "", " ")
	if errJson != nil {
		return errJson
	}

	if opts.format == "" {
		_, err := fmt.Fprintln(w, string(prettyJSON))
		return err
	}

	var parsedJSON interface{}
	if err := json.Unmarshal([]byte(prettyJSON), &parsedJSON); err != nil {
		return err
	}

	return opts.tmpl.Execute(w, parsedJSON)
}

func getClusterBuilder() *cobra.Command {
	opts := getClusterOpts{}
	const use = "getCluster"
	cmd := &cobra.Command{
		Use:     use,
		Short:   "Return One Cluster from One Project",
		Aliases: cli.GenerateAliases(use),
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.preRun()
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.run(cmd.Context(), cmd.InOrStdin())
		},
		PostRunE: func(cmd *cobra.Command, args []string) error {
			return opts.postRun(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "projectId", "", `Unique 24-hexadecimal digit string that identifies your project.`)
	cmd.Flags().StringVar(&opts.clusterName, "clusterName", "", `Human-readable label that identifies this cluster.`)

	_ = cmd.MarkFlagRequired("clusterName")
	cmd.Flags().StringVar(&opts.format, "format", "", "Format of the output")
	return cmd
}

type getClusterAdvancedConfigurationOpts struct {
	client      *admin.APIClient
	groupId     string
	clusterName string
	format      string
	tmpl        *template.Template
	resp        *admin.ClusterDescriptionProcessArgs
}

func (opts *getClusterAdvancedConfigurationOpts) preRun() (err error) {
	if opts.client, err = newClientWithAuth(config.UserAgent, config.Default()); err != nil {
		return err
	}

	if opts.groupId == "" {
		opts.groupId = config.ProjectID()
	}
	if opts.groupId == "" {
		return errors.New(`required flag(s) "projectId" not set`)
	}
	b, errDecode := hex.DecodeString(opts.groupId)
	if errDecode != nil || len(b) != 12 {
		return fmt.Errorf("the provided value '%s' is not a valid ID", opts.groupId)
	}

	if opts.format != "" {
		if opts.tmpl, err = template.New("").Parse(strings.ReplaceAll(opts.format, "\\n", "\n") + "\n"); err != nil {
			return err
		}
	}

	return nil
}

func (opts *getClusterAdvancedConfigurationOpts) run(ctx context.Context, _ io.Reader) error {

	params := &admin.GetClusterAdvancedConfigurationApiParams{
		GroupId:     opts.groupId,
		ClusterName: opts.clusterName,
	}

	var err error
	opts.resp, _, err = opts.client.ClustersApi.GetClusterAdvancedConfigurationWithParams(ctx, params).Execute()
	return err
}

func (opts *getClusterAdvancedConfigurationOpts) postRun(_ context.Context, w io.Writer) error {

	prettyJSON, errJson := json.MarshalIndent(opts.resp, "", " ")
	if errJson != nil {
		return errJson
	}

	if opts.format == "" {
		_, err := fmt.Fprintln(w, string(prettyJSON))
		return err
	}

	var parsedJSON interface{}
	if err := json.Unmarshal([]byte(prettyJSON), &parsedJSON); err != nil {
		return err
	}

	return opts.tmpl.Execute(w, parsedJSON)
}

func getClusterAdvancedConfigurationBuilder() *cobra.Command {
	opts := getClusterAdvancedConfigurationOpts{}
	const use = "getClusterAdvancedConfiguration"
	cmd := &cobra.Command{
		Use:     use,
		Short:   "Return One Advanced Configuration Options for One Cluster",
		Aliases: cli.GenerateAliases(use),
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.preRun()
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.run(cmd.Context(), cmd.InOrStdin())
		},
		PostRunE: func(cmd *cobra.Command, args []string) error {
			return opts.postRun(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "projectId", "", `Unique 24-hexadecimal digit string that identifies your project.`)
	cmd.Flags().StringVar(&opts.clusterName, "clusterName", "", `Human-readable label that identifies the cluster.`)

	_ = cmd.MarkFlagRequired("clusterName")
	cmd.Flags().StringVar(&opts.format, "format", "", "Format of the output")
	return cmd
}

type getClusterStatusOpts struct {
	client      *admin.APIClient
	groupId     string
	clusterName string
	format      string
	tmpl        *template.Template
	resp        *admin.ClusterStatus
}

func (opts *getClusterStatusOpts) preRun() (err error) {
	if opts.client, err = newClientWithAuth(config.UserAgent, config.Default()); err != nil {
		return err
	}

	if opts.groupId == "" {
		opts.groupId = config.ProjectID()
	}
	if opts.groupId == "" {
		return errors.New(`required flag(s) "projectId" not set`)
	}
	b, errDecode := hex.DecodeString(opts.groupId)
	if errDecode != nil || len(b) != 12 {
		return fmt.Errorf("the provided value '%s' is not a valid ID", opts.groupId)
	}

	if opts.format != "" {
		if opts.tmpl, err = template.New("").Parse(strings.ReplaceAll(opts.format, "\\n", "\n") + "\n"); err != nil {
			return err
		}
	}

	return nil
}

func (opts *getClusterStatusOpts) run(ctx context.Context, _ io.Reader) error {

	params := &admin.GetClusterStatusApiParams{
		GroupId:     opts.groupId,
		ClusterName: opts.clusterName,
	}

	var err error
	opts.resp, _, err = opts.client.ClustersApi.GetClusterStatusWithParams(ctx, params).Execute()
	return err
}

func (opts *getClusterStatusOpts) postRun(_ context.Context, w io.Writer) error {

	prettyJSON, errJson := json.MarshalIndent(opts.resp, "", " ")
	if errJson != nil {
		return errJson
	}

	if opts.format == "" {
		_, err := fmt.Fprintln(w, string(prettyJSON))
		return err
	}

	var parsedJSON interface{}
	if err := json.Unmarshal([]byte(prettyJSON), &parsedJSON); err != nil {
		return err
	}

	return opts.tmpl.Execute(w, parsedJSON)
}

func getClusterStatusBuilder() *cobra.Command {
	opts := getClusterStatusOpts{}
	const use = "getClusterStatus"
	cmd := &cobra.Command{
		Use:     use,
		Short:   "Return Status of All Cluster Operations",
		Aliases: cli.GenerateAliases(use),
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.preRun()
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.run(cmd.Context(), cmd.InOrStdin())
		},
		PostRunE: func(cmd *cobra.Command, args []string) error {
			return opts.postRun(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "projectId", "", `Unique 24-hexadecimal digit string that identifies your project.`)
	cmd.Flags().StringVar(&opts.clusterName, "clusterName", "", `Human-readable label that identifies the cluster.`)

	_ = cmd.MarkFlagRequired("clusterName")
	cmd.Flags().StringVar(&opts.format, "format", "", "Format of the output")
	return cmd
}

type getSampleDatasetLoadStatusOpts struct {
	client          *admin.APIClient
	groupId         string
	sampleDatasetId string
	format          string
	tmpl            *template.Template
	resp            *admin.SampleDatasetStatus
}

func (opts *getSampleDatasetLoadStatusOpts) preRun() (err error) {
	if opts.client, err = newClientWithAuth(config.UserAgent, config.Default()); err != nil {
		return err
	}

	if opts.groupId == "" {
		opts.groupId = config.ProjectID()
	}
	if opts.groupId == "" {
		return errors.New(`required flag(s) "projectId" not set`)
	}
	b, errDecode := hex.DecodeString(opts.groupId)
	if errDecode != nil || len(b) != 12 {
		return fmt.Errorf("the provided value '%s' is not a valid ID", opts.groupId)
	}

	if opts.format != "" {
		if opts.tmpl, err = template.New("").Parse(strings.ReplaceAll(opts.format, "\\n", "\n") + "\n"); err != nil {
			return err
		}
	}

	return nil
}

func (opts *getSampleDatasetLoadStatusOpts) run(ctx context.Context, _ io.Reader) error {

	params := &admin.GetSampleDatasetLoadStatusApiParams{
		GroupId:         opts.groupId,
		SampleDatasetId: opts.sampleDatasetId,
	}

	var err error
	opts.resp, _, err = opts.client.ClustersApi.GetSampleDatasetLoadStatusWithParams(ctx, params).Execute()
	return err
}

func (opts *getSampleDatasetLoadStatusOpts) postRun(_ context.Context, w io.Writer) error {

	prettyJSON, errJson := json.MarshalIndent(opts.resp, "", " ")
	if errJson != nil {
		return errJson
	}

	if opts.format == "" {
		_, err := fmt.Fprintln(w, string(prettyJSON))
		return err
	}

	var parsedJSON interface{}
	if err := json.Unmarshal([]byte(prettyJSON), &parsedJSON); err != nil {
		return err
	}

	return opts.tmpl.Execute(w, parsedJSON)
}

func getSampleDatasetLoadStatusBuilder() *cobra.Command {
	opts := getSampleDatasetLoadStatusOpts{}
	const use = "getSampleDatasetLoadStatus"
	cmd := &cobra.Command{
		Use:     use,
		Short:   "Check Status of Cluster Sample Dataset Request",
		Aliases: cli.GenerateAliases(use),
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.preRun()
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.run(cmd.Context(), cmd.InOrStdin())
		},
		PostRunE: func(cmd *cobra.Command, args []string) error {
			return opts.postRun(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "projectId", "", `Unique 24-hexadecimal digit string that identifies your project.`)
	cmd.Flags().StringVar(&opts.sampleDatasetId, "sampleDatasetId", "", `Unique 24-hexadecimal digit string that identifies the loaded sample dataset.`)

	_ = cmd.MarkFlagRequired("sampleDatasetId")
	cmd.Flags().StringVar(&opts.format, "format", "", "Format of the output")
	return cmd
}

type listCloudProviderRegionsOpts struct {
	client       *admin.APIClient
	groupId      string
	includeCount bool
	itemsPerPage int
	pageNum      int
	providers    []string
	tier         string
	format       string
	tmpl         *template.Template
	resp         *admin.PaginatedApiAtlasProviderRegions
}

func (opts *listCloudProviderRegionsOpts) preRun() (err error) {
	if opts.client, err = newClientWithAuth(config.UserAgent, config.Default()); err != nil {
		return err
	}

	if opts.groupId == "" {
		opts.groupId = config.ProjectID()
	}
	if opts.groupId == "" {
		return errors.New(`required flag(s) "projectId" not set`)
	}
	b, errDecode := hex.DecodeString(opts.groupId)
	if errDecode != nil || len(b) != 12 {
		return fmt.Errorf("the provided value '%s' is not a valid ID", opts.groupId)
	}

	if opts.format != "" {
		if opts.tmpl, err = template.New("").Parse(strings.ReplaceAll(opts.format, "\\n", "\n") + "\n"); err != nil {
			return err
		}
	}

	return nil
}

func (opts *listCloudProviderRegionsOpts) run(ctx context.Context, _ io.Reader) error {

	params := &admin.ListCloudProviderRegionsApiParams{
		GroupId:      opts.groupId,
		IncludeCount: &opts.includeCount,
		ItemsPerPage: &opts.itemsPerPage,
		PageNum:      &opts.pageNum,
		Providers:    &opts.providers,
		Tier:         &opts.tier,
	}

	var err error
	opts.resp, _, err = opts.client.ClustersApi.ListCloudProviderRegionsWithParams(ctx, params).Execute()
	return err
}

func (opts *listCloudProviderRegionsOpts) postRun(_ context.Context, w io.Writer) error {

	prettyJSON, errJson := json.MarshalIndent(opts.resp, "", " ")
	if errJson != nil {
		return errJson
	}

	if opts.format == "" {
		_, err := fmt.Fprintln(w, string(prettyJSON))
		return err
	}

	var parsedJSON interface{}
	if err := json.Unmarshal([]byte(prettyJSON), &parsedJSON); err != nil {
		return err
	}

	return opts.tmpl.Execute(w, parsedJSON)
}

func listCloudProviderRegionsBuilder() *cobra.Command {
	opts := listCloudProviderRegionsOpts{}
	const use = "listCloudProviderRegions"
	cmd := &cobra.Command{
		Use:     use,
		Short:   "Return All Cloud Provider Regions",
		Aliases: cli.GenerateAliases(use),
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.preRun()
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.run(cmd.Context(), cmd.InOrStdin())
		},
		PostRunE: func(cmd *cobra.Command, args []string) error {
			return opts.postRun(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "projectId", "", `Unique 24-hexadecimal digit string that identifies your project.`)
	cmd.Flags().BoolVar(&opts.includeCount, "includeCount", true, `Flag that indicates whether the response returns the total number of items (**totalCount**) in the response.`)
	cmd.Flags().IntVar(&opts.itemsPerPage, "itemsPerPage", 100, `Number of items that the response returns per page.`)
	cmd.Flags().IntVar(&opts.pageNum, "pageNum", 1, `Number of the page that displays the current set of the total objects that the response returns.`)
	cmd.Flags().StringSliceVar(&opts.providers, "providers", nil, `Cloud providers whose regions to retrieve. When you specify multiple providers, the response can return only tiers and regions that support multi-cloud clusters.`)
	cmd.Flags().StringVar(&opts.tier, "tier", "", `Cluster tier for which to retrieve the regions.`)

	cmd.Flags().StringVar(&opts.format, "format", "", "Format of the output")
	return cmd
}

type listClustersOpts struct {
	client                            *admin.APIClient
	groupId                           string
	includeCount                      bool
	itemsPerPage                      int
	pageNum                           int
	includeDeletedWithRetainedBackups bool
	format                            string
	tmpl                              *template.Template
	resp                              *admin.PaginatedAdvancedClusterDescription
}

func (opts *listClustersOpts) preRun() (err error) {
	if opts.client, err = newClientWithAuth(config.UserAgent, config.Default()); err != nil {
		return err
	}

	if opts.groupId == "" {
		opts.groupId = config.ProjectID()
	}
	if opts.groupId == "" {
		return errors.New(`required flag(s) "projectId" not set`)
	}
	b, errDecode := hex.DecodeString(opts.groupId)
	if errDecode != nil || len(b) != 12 {
		return fmt.Errorf("the provided value '%s' is not a valid ID", opts.groupId)
	}

	if opts.format != "" {
		if opts.tmpl, err = template.New("").Parse(strings.ReplaceAll(opts.format, "\\n", "\n") + "\n"); err != nil {
			return err
		}
	}

	return nil
}

func (opts *listClustersOpts) run(ctx context.Context, _ io.Reader) error {

	params := &admin.ListClustersApiParams{
		GroupId:                           opts.groupId,
		IncludeCount:                      &opts.includeCount,
		ItemsPerPage:                      &opts.itemsPerPage,
		PageNum:                           &opts.pageNum,
		IncludeDeletedWithRetainedBackups: &opts.includeDeletedWithRetainedBackups,
	}

	var err error
	opts.resp, _, err = opts.client.ClustersApi.ListClustersWithParams(ctx, params).Execute()
	return err
}

func (opts *listClustersOpts) postRun(_ context.Context, w io.Writer) error {

	prettyJSON, errJson := json.MarshalIndent(opts.resp, "", " ")
	if errJson != nil {
		return errJson
	}

	if opts.format == "" {
		_, err := fmt.Fprintln(w, string(prettyJSON))
		return err
	}

	var parsedJSON interface{}
	if err := json.Unmarshal([]byte(prettyJSON), &parsedJSON); err != nil {
		return err
	}

	return opts.tmpl.Execute(w, parsedJSON)
}

func listClustersBuilder() *cobra.Command {
	opts := listClustersOpts{}
	const use = "listClusters"
	cmd := &cobra.Command{
		Use:     use,
		Short:   "Return All Clusters in One Project",
		Aliases: cli.GenerateAliases(use),
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.preRun()
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.run(cmd.Context(), cmd.InOrStdin())
		},
		PostRunE: func(cmd *cobra.Command, args []string) error {
			return opts.postRun(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "projectId", "", `Unique 24-hexadecimal digit string that identifies your project.`)
	cmd.Flags().BoolVar(&opts.includeCount, "includeCount", true, `Flag that indicates whether the response returns the total number of items (**totalCount**) in the response.`)
	cmd.Flags().IntVar(&opts.itemsPerPage, "itemsPerPage", 100, `Number of items that the response returns per page.`)
	cmd.Flags().IntVar(&opts.pageNum, "pageNum", 1, `Number of the page that displays the current set of the total objects that the response returns.`)
	cmd.Flags().BoolVar(&opts.includeDeletedWithRetainedBackups, "includeDeletedWithRetainedBackups", false, `Flag that indicates whether to return Clusters with retain backups.`)

	cmd.Flags().StringVar(&opts.format, "format", "", "Format of the output")
	return cmd
}

type listClustersForAllProjectsOpts struct {
	client       *admin.APIClient
	includeCount bool
	itemsPerPage int
	pageNum      int
	format       string
	tmpl         *template.Template
	resp         *admin.PaginatedOrgGroup
}

func (opts *listClustersForAllProjectsOpts) preRun() (err error) {
	if opts.client, err = newClientWithAuth(config.UserAgent, config.Default()); err != nil {
		return err
	}

	if opts.format != "" {
		if opts.tmpl, err = template.New("").Parse(strings.ReplaceAll(opts.format, "\\n", "\n") + "\n"); err != nil {
			return err
		}
	}

	return nil
}

func (opts *listClustersForAllProjectsOpts) run(ctx context.Context, _ io.Reader) error {

	params := &admin.ListClustersForAllProjectsApiParams{
		IncludeCount: &opts.includeCount,
		ItemsPerPage: &opts.itemsPerPage,
		PageNum:      &opts.pageNum,
	}

	var err error
	opts.resp, _, err = opts.client.ClustersApi.ListClustersForAllProjectsWithParams(ctx, params).Execute()
	return err
}

func (opts *listClustersForAllProjectsOpts) postRun(_ context.Context, w io.Writer) error {

	prettyJSON, errJson := json.MarshalIndent(opts.resp, "", " ")
	if errJson != nil {
		return errJson
	}

	if opts.format == "" {
		_, err := fmt.Fprintln(w, string(prettyJSON))
		return err
	}

	var parsedJSON interface{}
	if err := json.Unmarshal([]byte(prettyJSON), &parsedJSON); err != nil {
		return err
	}

	return opts.tmpl.Execute(w, parsedJSON)
}

func listClustersForAllProjectsBuilder() *cobra.Command {
	opts := listClustersForAllProjectsOpts{}
	const use = "listClustersForAllProjects"
	cmd := &cobra.Command{
		Use:     use,
		Short:   "Return All Authorized Clusters in All Projects",
		Aliases: cli.GenerateAliases(use),
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.preRun()
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.run(cmd.Context(), cmd.InOrStdin())
		},
		PostRunE: func(cmd *cobra.Command, args []string) error {
			return opts.postRun(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().BoolVar(&opts.includeCount, "includeCount", true, `Flag that indicates whether the response returns the total number of items (**totalCount**) in the response.`)
	cmd.Flags().IntVar(&opts.itemsPerPage, "itemsPerPage", 100, `Number of items that the response returns per page.`)
	cmd.Flags().IntVar(&opts.pageNum, "pageNum", 1, `Number of the page that displays the current set of the total objects that the response returns.`)

	cmd.Flags().StringVar(&opts.format, "format", "", "Format of the output")
	return cmd
}

type loadSampleDatasetOpts struct {
	client  *admin.APIClient
	groupId string
	name    string
	format  string
	tmpl    *template.Template
	resp    *admin.SampleDatasetStatus
}

func (opts *loadSampleDatasetOpts) preRun() (err error) {
	if opts.client, err = newClientWithAuth(config.UserAgent, config.Default()); err != nil {
		return err
	}

	if opts.groupId == "" {
		opts.groupId = config.ProjectID()
	}
	if opts.groupId == "" {
		return errors.New(`required flag(s) "projectId" not set`)
	}
	b, errDecode := hex.DecodeString(opts.groupId)
	if errDecode != nil || len(b) != 12 {
		return fmt.Errorf("the provided value '%s' is not a valid ID", opts.groupId)
	}

	if opts.format != "" {
		if opts.tmpl, err = template.New("").Parse(strings.ReplaceAll(opts.format, "\\n", "\n") + "\n"); err != nil {
			return err
		}
	}

	return nil
}

func (opts *loadSampleDatasetOpts) run(ctx context.Context, _ io.Reader) error {

	params := &admin.LoadSampleDatasetApiParams{
		GroupId: opts.groupId,
		Name:    opts.name,
	}

	var err error
	opts.resp, _, err = opts.client.ClustersApi.LoadSampleDatasetWithParams(ctx, params).Execute()
	return err
}

func (opts *loadSampleDatasetOpts) postRun(_ context.Context, w io.Writer) error {

	prettyJSON, errJson := json.MarshalIndent(opts.resp, "", " ")
	if errJson != nil {
		return errJson
	}

	if opts.format == "" {
		_, err := fmt.Fprintln(w, string(prettyJSON))
		return err
	}

	var parsedJSON interface{}
	if err := json.Unmarshal([]byte(prettyJSON), &parsedJSON); err != nil {
		return err
	}

	return opts.tmpl.Execute(w, parsedJSON)
}

func loadSampleDatasetBuilder() *cobra.Command {
	opts := loadSampleDatasetOpts{}
	const use = "loadSampleDataset"
	cmd := &cobra.Command{
		Use:     use,
		Short:   "Load Sample Dataset Request into Cluster",
		Aliases: cli.GenerateAliases(use),
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.preRun()
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.run(cmd.Context(), cmd.InOrStdin())
		},
		PostRunE: func(cmd *cobra.Command, args []string) error {
			return opts.postRun(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "projectId", "", `Unique 24-hexadecimal digit string that identifies your project.`)
	cmd.Flags().StringVar(&opts.name, "name", "", `Human-readable label that identifies the cluster into which you load the sample dataset.`)

	_ = cmd.MarkFlagRequired("name")
	cmd.Flags().StringVar(&opts.format, "format", "", "Format of the output")
	return cmd
}

type testFailoverOpts struct {
	client      *admin.APIClient
	groupId     string
	clusterName string
}

func (opts *testFailoverOpts) preRun() (err error) {
	if opts.client, err = newClientWithAuth(config.UserAgent, config.Default()); err != nil {
		return err
	}

	if opts.groupId == "" {
		opts.groupId = config.ProjectID()
	}
	if opts.groupId == "" {
		return errors.New(`required flag(s) "projectId" not set`)
	}
	b, errDecode := hex.DecodeString(opts.groupId)
	if errDecode != nil || len(b) != 12 {
		return fmt.Errorf("the provided value '%s' is not a valid ID", opts.groupId)
	}

	return nil
}

func (opts *testFailoverOpts) run(ctx context.Context, _ io.Reader) error {

	params := &admin.TestFailoverApiParams{
		GroupId:     opts.groupId,
		ClusterName: opts.clusterName,
	}

	var err error
	_, err = opts.client.ClustersApi.TestFailoverWithParams(ctx, params).Execute()
	return err
}

func (opts *testFailoverOpts) postRun(_ context.Context, _ io.Writer) error {

	return nil
}

func testFailoverBuilder() *cobra.Command {
	opts := testFailoverOpts{}
	const use = "testFailover"
	cmd := &cobra.Command{
		Use:     use,
		Short:   "Test Failover for One Cluster",
		Aliases: cli.GenerateAliases(use),
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.preRun()
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.run(cmd.Context(), cmd.InOrStdin())
		},
		PostRunE: func(cmd *cobra.Command, args []string) error {
			return opts.postRun(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "projectId", "", `Unique 24-hexadecimal digit string that identifies your project.`)
	cmd.Flags().StringVar(&opts.clusterName, "clusterName", "", `Human-readable label that identifies the cluster.`)

	_ = cmd.MarkFlagRequired("clusterName")
	return cmd
}

type updateClusterOpts struct {
	client      *admin.APIClient
	groupId     string
	clusterName string

	filename string
	fs       afero.Fs
	format   string
	tmpl     *template.Template
	resp     *admin.AdvancedClusterDescription
}

func (opts *updateClusterOpts) preRun() (err error) {
	if opts.client, err = newClientWithAuth(config.UserAgent, config.Default()); err != nil {
		return err
	}

	if opts.groupId == "" {
		opts.groupId = config.ProjectID()
	}
	if opts.groupId == "" {
		return errors.New(`required flag(s) "projectId" not set`)
	}
	b, errDecode := hex.DecodeString(opts.groupId)
	if errDecode != nil || len(b) != 12 {
		return fmt.Errorf("the provided value '%s' is not a valid ID", opts.groupId)
	}

	if opts.format != "" {
		if opts.tmpl, err = template.New("").Parse(strings.ReplaceAll(opts.format, "\\n", "\n") + "\n"); err != nil {
			return err
		}
	}

	return nil
}

func (opts *updateClusterOpts) readData(r io.Reader) (*admin.AdvancedClusterDescription, error) {
	var out *admin.AdvancedClusterDescription

	var buf []byte
	var err error
	if opts.filename == "" {
		buf, err = io.ReadAll(r)
	} else {
		if exists, errExists := afero.Exists(opts.fs, opts.filename); !exists || errExists != nil {
			return nil, fmt.Errorf("file not found: %s", opts.filename)
		}
		buf, err = afero.ReadFile(opts.fs, opts.filename)
	}
	if err != nil {
		return nil, err
	}
	if err = json.Unmarshal(buf, &out); err != nil {
		return nil, err
	}
	return out, nil
}

func (opts *updateClusterOpts) run(ctx context.Context, r io.Reader) error {
	data, errData := opts.readData(r)
	if errData != nil {
		return errData
	}

	params := &admin.UpdateClusterApiParams{
		GroupId:     opts.groupId,
		ClusterName: opts.clusterName,

		AdvancedClusterDescription: data,
	}

	var err error
	opts.resp, _, err = opts.client.ClustersApi.UpdateClusterWithParams(ctx, params).Execute()
	return err
}

func (opts *updateClusterOpts) postRun(_ context.Context, w io.Writer) error {

	prettyJSON, errJson := json.MarshalIndent(opts.resp, "", " ")
	if errJson != nil {
		return errJson
	}

	if opts.format == "" {
		_, err := fmt.Fprintln(w, string(prettyJSON))
		return err
	}

	var parsedJSON interface{}
	if err := json.Unmarshal([]byte(prettyJSON), &parsedJSON); err != nil {
		return err
	}

	return opts.tmpl.Execute(w, parsedJSON)
}

func updateClusterBuilder() *cobra.Command {
	opts := updateClusterOpts{
		fs: afero.NewOsFs(),
	}
	const use = "updateCluster"
	cmd := &cobra.Command{
		Use:     use,
		Short:   "Modify One Cluster from One Project",
		Aliases: cli.GenerateAliases(use),
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.preRun()
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.run(cmd.Context(), cmd.InOrStdin())
		},
		PostRunE: func(cmd *cobra.Command, args []string) error {
			return opts.postRun(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "projectId", "", `Unique 24-hexadecimal digit string that identifies your project.`)
	cmd.Flags().StringVar(&opts.clusterName, "clusterName", "", `Human-readable label that identifies the cluster.`)

	cmd.Flags().StringVarP(&opts.filename, "file", "f", "", "Path to an optional JSON configuration file if not passed stdin is expected")

	_ = cmd.MarkFlagRequired("clusterName")
	cmd.Flags().StringVar(&opts.format, "format", "", "Format of the output")
	return cmd
}

type updateClusterAdvancedConfigurationOpts struct {
	client      *admin.APIClient
	groupId     string
	clusterName string

	filename string
	fs       afero.Fs
	format   string
	tmpl     *template.Template
	resp     *admin.ClusterDescriptionProcessArgs
}

func (opts *updateClusterAdvancedConfigurationOpts) preRun() (err error) {
	if opts.client, err = newClientWithAuth(config.UserAgent, config.Default()); err != nil {
		return err
	}

	if opts.groupId == "" {
		opts.groupId = config.ProjectID()
	}
	if opts.groupId == "" {
		return errors.New(`required flag(s) "projectId" not set`)
	}
	b, errDecode := hex.DecodeString(opts.groupId)
	if errDecode != nil || len(b) != 12 {
		return fmt.Errorf("the provided value '%s' is not a valid ID", opts.groupId)
	}

	if opts.format != "" {
		if opts.tmpl, err = template.New("").Parse(strings.ReplaceAll(opts.format, "\\n", "\n") + "\n"); err != nil {
			return err
		}
	}

	return nil
}

func (opts *updateClusterAdvancedConfigurationOpts) readData(r io.Reader) (*admin.ClusterDescriptionProcessArgs, error) {
	var out *admin.ClusterDescriptionProcessArgs

	var buf []byte
	var err error
	if opts.filename == "" {
		buf, err = io.ReadAll(r)
	} else {
		if exists, errExists := afero.Exists(opts.fs, opts.filename); !exists || errExists != nil {
			return nil, fmt.Errorf("file not found: %s", opts.filename)
		}
		buf, err = afero.ReadFile(opts.fs, opts.filename)
	}
	if err != nil {
		return nil, err
	}
	if err = json.Unmarshal(buf, &out); err != nil {
		return nil, err
	}
	return out, nil
}

func (opts *updateClusterAdvancedConfigurationOpts) run(ctx context.Context, r io.Reader) error {
	data, errData := opts.readData(r)
	if errData != nil {
		return errData
	}

	params := &admin.UpdateClusterAdvancedConfigurationApiParams{
		GroupId:     opts.groupId,
		ClusterName: opts.clusterName,

		ClusterDescriptionProcessArgs: data,
	}

	var err error
	opts.resp, _, err = opts.client.ClustersApi.UpdateClusterAdvancedConfigurationWithParams(ctx, params).Execute()
	return err
}

func (opts *updateClusterAdvancedConfigurationOpts) postRun(_ context.Context, w io.Writer) error {

	prettyJSON, errJson := json.MarshalIndent(opts.resp, "", " ")
	if errJson != nil {
		return errJson
	}

	if opts.format == "" {
		_, err := fmt.Fprintln(w, string(prettyJSON))
		return err
	}

	var parsedJSON interface{}
	if err := json.Unmarshal([]byte(prettyJSON), &parsedJSON); err != nil {
		return err
	}

	return opts.tmpl.Execute(w, parsedJSON)
}

func updateClusterAdvancedConfigurationBuilder() *cobra.Command {
	opts := updateClusterAdvancedConfigurationOpts{
		fs: afero.NewOsFs(),
	}
	const use = "updateClusterAdvancedConfiguration"
	cmd := &cobra.Command{
		Use:     use,
		Short:   "Update Advanced Configuration Options for One Cluster",
		Aliases: cli.GenerateAliases(use),
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.preRun()
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.run(cmd.Context(), cmd.InOrStdin())
		},
		PostRunE: func(cmd *cobra.Command, args []string) error {
			return opts.postRun(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "projectId", "", `Unique 24-hexadecimal digit string that identifies your project.`)
	cmd.Flags().StringVar(&opts.clusterName, "clusterName", "", `Human-readable label that identifies the cluster.`)

	cmd.Flags().StringVarP(&opts.filename, "file", "f", "", "Path to an optional JSON configuration file if not passed stdin is expected")

	_ = cmd.MarkFlagRequired("clusterName")
	cmd.Flags().StringVar(&opts.format, "format", "", "Format of the output")
	return cmd
}

type upgradeSharedClusterOpts struct {
	client  *admin.APIClient
	groupId string

	filename string
	fs       afero.Fs
	format   string
	tmpl     *template.Template
	resp     *admin.LegacyAtlasCluster
}

func (opts *upgradeSharedClusterOpts) preRun() (err error) {
	if opts.client, err = newClientWithAuth(config.UserAgent, config.Default()); err != nil {
		return err
	}

	if opts.groupId == "" {
		opts.groupId = config.ProjectID()
	}
	if opts.groupId == "" {
		return errors.New(`required flag(s) "projectId" not set`)
	}
	b, errDecode := hex.DecodeString(opts.groupId)
	if errDecode != nil || len(b) != 12 {
		return fmt.Errorf("the provided value '%s' is not a valid ID", opts.groupId)
	}

	if opts.format != "" {
		if opts.tmpl, err = template.New("").Parse(strings.ReplaceAll(opts.format, "\\n", "\n") + "\n"); err != nil {
			return err
		}
	}

	return nil
}

func (opts *upgradeSharedClusterOpts) readData(r io.Reader) (*admin.LegacyAtlasTenantClusterUpgradeRequest, error) {
	var out *admin.LegacyAtlasTenantClusterUpgradeRequest

	var buf []byte
	var err error
	if opts.filename == "" {
		buf, err = io.ReadAll(r)
	} else {
		if exists, errExists := afero.Exists(opts.fs, opts.filename); !exists || errExists != nil {
			return nil, fmt.Errorf("file not found: %s", opts.filename)
		}
		buf, err = afero.ReadFile(opts.fs, opts.filename)
	}
	if err != nil {
		return nil, err
	}
	if err = json.Unmarshal(buf, &out); err != nil {
		return nil, err
	}
	return out, nil
}

func (opts *upgradeSharedClusterOpts) run(ctx context.Context, r io.Reader) error {
	data, errData := opts.readData(r)
	if errData != nil {
		return errData
	}

	params := &admin.UpgradeSharedClusterApiParams{
		GroupId: opts.groupId,

		LegacyAtlasTenantClusterUpgradeRequest: data,
	}

	var err error
	opts.resp, _, err = opts.client.ClustersApi.UpgradeSharedClusterWithParams(ctx, params).Execute()
	return err
}

func (opts *upgradeSharedClusterOpts) postRun(_ context.Context, w io.Writer) error {

	prettyJSON, errJson := json.MarshalIndent(opts.resp, "", " ")
	if errJson != nil {
		return errJson
	}

	if opts.format == "" {
		_, err := fmt.Fprintln(w, string(prettyJSON))
		return err
	}

	var parsedJSON interface{}
	if err := json.Unmarshal([]byte(prettyJSON), &parsedJSON); err != nil {
		return err
	}

	return opts.tmpl.Execute(w, parsedJSON)
}

func upgradeSharedClusterBuilder() *cobra.Command {
	opts := upgradeSharedClusterOpts{
		fs: afero.NewOsFs(),
	}
	const use = "upgradeSharedCluster"
	cmd := &cobra.Command{
		Use:     use,
		Short:   "Upgrade One Shared-tier Cluster",
		Aliases: cli.GenerateAliases(use),
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.preRun()
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.run(cmd.Context(), cmd.InOrStdin())
		},
		PostRunE: func(cmd *cobra.Command, args []string) error {
			return opts.postRun(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "projectId", "", `Unique 24-hexadecimal digit string that identifies your project.`)

	cmd.Flags().StringVarP(&opts.filename, "file", "f", "", "Path to an optional JSON configuration file if not passed stdin is expected")

	cmd.Flags().StringVar(&opts.format, "format", "", "Format of the output")
	return cmd
}

type upgradeSharedClusterToServerlessOpts struct {
	client  *admin.APIClient
	groupId string

	filename string
	fs       afero.Fs
	format   string
	tmpl     *template.Template
	resp     *admin.ServerlessInstanceDescription
}

func (opts *upgradeSharedClusterToServerlessOpts) preRun() (err error) {
	if opts.client, err = newClientWithAuth(config.UserAgent, config.Default()); err != nil {
		return err
	}

	if opts.groupId == "" {
		opts.groupId = config.ProjectID()
	}
	if opts.groupId == "" {
		return errors.New(`required flag(s) "projectId" not set`)
	}
	b, errDecode := hex.DecodeString(opts.groupId)
	if errDecode != nil || len(b) != 12 {
		return fmt.Errorf("the provided value '%s' is not a valid ID", opts.groupId)
	}

	if opts.format != "" {
		if opts.tmpl, err = template.New("").Parse(strings.ReplaceAll(opts.format, "\\n", "\n") + "\n"); err != nil {
			return err
		}
	}

	return nil
}

func (opts *upgradeSharedClusterToServerlessOpts) readData(r io.Reader) (*admin.ServerlessInstanceDescription, error) {
	var out *admin.ServerlessInstanceDescription

	var buf []byte
	var err error
	if opts.filename == "" {
		buf, err = io.ReadAll(r)
	} else {
		if exists, errExists := afero.Exists(opts.fs, opts.filename); !exists || errExists != nil {
			return nil, fmt.Errorf("file not found: %s", opts.filename)
		}
		buf, err = afero.ReadFile(opts.fs, opts.filename)
	}
	if err != nil {
		return nil, err
	}
	if err = json.Unmarshal(buf, &out); err != nil {
		return nil, err
	}
	return out, nil
}

func (opts *upgradeSharedClusterToServerlessOpts) run(ctx context.Context, r io.Reader) error {
	data, errData := opts.readData(r)
	if errData != nil {
		return errData
	}

	params := &admin.UpgradeSharedClusterToServerlessApiParams{
		GroupId: opts.groupId,

		ServerlessInstanceDescription: data,
	}

	var err error
	opts.resp, _, err = opts.client.ClustersApi.UpgradeSharedClusterToServerlessWithParams(ctx, params).Execute()
	return err
}

func (opts *upgradeSharedClusterToServerlessOpts) postRun(_ context.Context, w io.Writer) error {

	prettyJSON, errJson := json.MarshalIndent(opts.resp, "", " ")
	if errJson != nil {
		return errJson
	}

	if opts.format == "" {
		_, err := fmt.Fprintln(w, string(prettyJSON))
		return err
	}

	var parsedJSON interface{}
	if err := json.Unmarshal([]byte(prettyJSON), &parsedJSON); err != nil {
		return err
	}

	return opts.tmpl.Execute(w, parsedJSON)
}

func upgradeSharedClusterToServerlessBuilder() *cobra.Command {
	opts := upgradeSharedClusterToServerlessOpts{
		fs: afero.NewOsFs(),
	}
	const use = "upgradeSharedClusterToServerless"
	cmd := &cobra.Command{
		Use:     use,
		Short:   "Upgrades One Shared-Tier Cluster to the Serverless Instance",
		Aliases: cli.GenerateAliases(use),
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.preRun()
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.run(cmd.Context(), cmd.InOrStdin())
		},
		PostRunE: func(cmd *cobra.Command, args []string) error {
			return opts.postRun(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "projectId", "", `Unique 24-hexadecimal digit string that identifies your project.`)

	cmd.Flags().StringVarP(&opts.filename, "file", "f", "", "Path to an optional JSON configuration file if not passed stdin is expected")

	cmd.Flags().StringVar(&opts.format, "format", "", "Format of the output")
	return cmd
}

func clustersBuilder() *cobra.Command {
	const use = "clusters"
	cmd := &cobra.Command{
		Use:     use,
		Short:   `Returns, adds, edits, and removes database deployments. Changes to cluster configurations can affect costs. This resource requires your Project ID.`,
		Aliases: cli.GenerateAliases(use),
	}
	cmd.AddCommand(
		createClusterBuilder(),
		deleteClusterBuilder(),
		getClusterBuilder(),
		getClusterAdvancedConfigurationBuilder(),
		getClusterStatusBuilder(),
		getSampleDatasetLoadStatusBuilder(),
		listCloudProviderRegionsBuilder(),
		listClustersBuilder(),
		listClustersForAllProjectsBuilder(),
		loadSampleDatasetBuilder(),
		testFailoverBuilder(),
		updateClusterBuilder(),
		updateClusterAdvancedConfigurationBuilder(),
		upgradeSharedClusterBuilder(),
		upgradeSharedClusterToServerlessBuilder(),
	)
	return cmd
}
