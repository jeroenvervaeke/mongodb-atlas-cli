// Copyright 2023 MongoDB Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package api

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"os"

	"github.com/mongodb/mongodb-atlas-cli/internal/cli"
	"github.com/mongodb/mongodb-atlas-cli/internal/jsonwriter"
	"github.com/spf13/afero"
	"github.com/spf13/cobra"
	"go.mongodb.org/atlas-sdk/v20230201008/admin"
)

type createClusterOpts struct {
	cli.GlobalOpts
	client  *admin.APIClient
	groupId string

	filename string
	fs       afero.Fs
}

func (opts *createClusterOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *createClusterOpts) readData() (*admin.AdvancedClusterDescription, error) {
	var out *admin.AdvancedClusterDescription

	var buf []byte
	var err error
	if opts.filename == "" {
		buf, err = io.ReadAll(os.Stdin)
	} else {
		if exists, errExists := afero.Exists(opts.fs, opts.filename); !exists || errExists != nil {
			return nil, fmt.Errorf("file not found: %s", opts.filename)
		}
		buf, err = afero.ReadFile(opts.fs, opts.filename)
	}
	if err != nil {
		return nil, err
	}
	if err = json.Unmarshal(buf, &out); err != nil {
		return nil, err
	}
	return out, nil
}

func (opts *createClusterOpts) Run(ctx context.Context, w io.Writer) error {
	data, errData := opts.readData()
	if errData != nil {
		return errData
	}
	params := &admin.CreateClusterApiParams{
		GroupId: opts.groupId,

		AdvancedClusterDescription: data,
	}
	resp, _, err := opts.client.ClustersApi.CreateClusterWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return jsonwriter.Print(w, resp)
}

func createClusterBuilder() *cobra.Command {
	opts := createClusterOpts{
		fs: afero.NewOsFs(),
	}
	cmd := &cobra.Command{
		Use:   "createCluster",
		Short: "Create One Multi-Cloud Cluster from One Project",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)

	cmd.Flags().StringVarP(&opts.filename, "file", "f", "", "Path to an optional JSON configuration file if not passed stdin is expected")

	_ = cmd.MarkFlagRequired("groupId")
	return cmd
}

type deleteClusterOpts struct {
	cli.GlobalOpts
	client        *admin.APIClient
	groupId       string
	clusterName   string
	retainBackups bool
}

func (opts *deleteClusterOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *deleteClusterOpts) Run(ctx context.Context, _ io.Writer) error {
	params := &admin.DeleteClusterApiParams{
		GroupId:       opts.groupId,
		ClusterName:   opts.clusterName,
		RetainBackups: &opts.retainBackups,
	}
	_, err := opts.client.ClustersApi.DeleteClusterWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return nil
}

func deleteClusterBuilder() *cobra.Command {
	opts := deleteClusterOpts{}
	cmd := &cobra.Command{
		Use:   "deleteCluster",
		Short: "Remove One Multi-Cloud Cluster from One Project",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)
	cmd.Flags().StringVar(&opts.clusterName, "clusterName", "", `Human-readable label that identifies the cluster.`)
	cmd.Flags().BoolVar(&opts.retainBackups, "retainBackups", false, `Flag that indicates whether to retain backup snapshots for the deleted dedicated cluster.`)

	_ = cmd.MarkFlagRequired("groupId")
	_ = cmd.MarkFlagRequired("clusterName")
	return cmd
}

type getClusterOpts struct {
	cli.GlobalOpts
	client      *admin.APIClient
	groupId     string
	clusterName string
}

func (opts *getClusterOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *getClusterOpts) Run(ctx context.Context, w io.Writer) error {
	params := &admin.GetClusterApiParams{
		GroupId:     opts.groupId,
		ClusterName: opts.clusterName,
	}
	resp, _, err := opts.client.ClustersApi.GetClusterWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return jsonwriter.Print(w, resp)
}

func getClusterBuilder() *cobra.Command {
	opts := getClusterOpts{}
	cmd := &cobra.Command{
		Use:   "getCluster",
		Short: "Return One Multi-Cloud Cluster from One Project",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)
	cmd.Flags().StringVar(&opts.clusterName, "clusterName", "", `Human-readable label that identifies this advanced cluster.`)

	_ = cmd.MarkFlagRequired("groupId")
	_ = cmd.MarkFlagRequired("clusterName")
	return cmd
}

type getClusterAdvancedConfigurationOpts struct {
	cli.GlobalOpts
	client      *admin.APIClient
	groupId     string
	clusterName string
}

func (opts *getClusterAdvancedConfigurationOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *getClusterAdvancedConfigurationOpts) Run(ctx context.Context, w io.Writer) error {
	params := &admin.GetClusterAdvancedConfigurationApiParams{
		GroupId:     opts.groupId,
		ClusterName: opts.clusterName,
	}
	resp, _, err := opts.client.ClustersApi.GetClusterAdvancedConfigurationWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return jsonwriter.Print(w, resp)
}

func getClusterAdvancedConfigurationBuilder() *cobra.Command {
	opts := getClusterAdvancedConfigurationOpts{}
	cmd := &cobra.Command{
		Use:   "getClusterAdvancedConfiguration",
		Short: "Return One Advanced Configuration Options for One Cluster",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)
	cmd.Flags().StringVar(&opts.clusterName, "clusterName", "", `Human-readable label that identifies the cluster.`)

	_ = cmd.MarkFlagRequired("groupId")
	_ = cmd.MarkFlagRequired("clusterName")
	return cmd
}

type getClusterStatusOpts struct {
	cli.GlobalOpts
	client      *admin.APIClient
	groupId     string
	clusterName string
}

func (opts *getClusterStatusOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *getClusterStatusOpts) Run(ctx context.Context, w io.Writer) error {
	params := &admin.GetClusterStatusApiParams{
		GroupId:     opts.groupId,
		ClusterName: opts.clusterName,
	}
	resp, _, err := opts.client.ClustersApi.GetClusterStatusWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return jsonwriter.Print(w, resp)
}

func getClusterStatusBuilder() *cobra.Command {
	opts := getClusterStatusOpts{}
	cmd := &cobra.Command{
		Use:   "getClusterStatus",
		Short: "Return Status of All Cluster Operations",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)
	cmd.Flags().StringVar(&opts.clusterName, "clusterName", "", `Human-readable label that identifies the cluster.`)

	_ = cmd.MarkFlagRequired("groupId")
	_ = cmd.MarkFlagRequired("clusterName")
	return cmd
}

type getSampleDatasetLoadStatusOpts struct {
	cli.GlobalOpts
	client          *admin.APIClient
	groupId         string
	sampleDatasetId string
}

func (opts *getSampleDatasetLoadStatusOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *getSampleDatasetLoadStatusOpts) Run(ctx context.Context, w io.Writer) error {
	params := &admin.GetSampleDatasetLoadStatusApiParams{
		GroupId:         opts.groupId,
		SampleDatasetId: opts.sampleDatasetId,
	}
	resp, _, err := opts.client.ClustersApi.GetSampleDatasetLoadStatusWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return jsonwriter.Print(w, resp)
}

func getSampleDatasetLoadStatusBuilder() *cobra.Command {
	opts := getSampleDatasetLoadStatusOpts{}
	cmd := &cobra.Command{
		Use:   "getSampleDatasetLoadStatus",
		Short: "Check Status of Cluster Sample Dataset Request",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)
	cmd.Flags().StringVar(&opts.sampleDatasetId, "sampleDatasetId", "", `Unique 24-hexadecimal digit string that identifies the loaded sample dataset.`)

	_ = cmd.MarkFlagRequired("groupId")
	_ = cmd.MarkFlagRequired("sampleDatasetId")
	return cmd
}

type listCloudProviderRegionsOpts struct {
	cli.GlobalOpts
	client       *admin.APIClient
	groupId      string
	includeCount bool
	itemsPerPage int
	pageNum      int
	providers    []string
	tier         string
}

func (opts *listCloudProviderRegionsOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *listCloudProviderRegionsOpts) Run(ctx context.Context, w io.Writer) error {
	params := &admin.ListCloudProviderRegionsApiParams{
		GroupId:      opts.groupId,
		IncludeCount: &opts.includeCount,
		ItemsPerPage: &opts.itemsPerPage,
		PageNum:      &opts.pageNum,
		Providers:    &opts.providers,
		Tier:         &opts.tier,
	}
	resp, _, err := opts.client.ClustersApi.ListCloudProviderRegionsWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return jsonwriter.Print(w, resp)
}

func listCloudProviderRegionsBuilder() *cobra.Command {
	opts := listCloudProviderRegionsOpts{}
	cmd := &cobra.Command{
		Use:   "listCloudProviderRegions",
		Short: "Return All Cloud Provider Regions",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)
	cmd.Flags().BoolVar(&opts.includeCount, "includeCount", true, `Flag that indicates whether the response returns the total number of items (**totalCount**) in the response.`)
	cmd.Flags().IntVar(&opts.itemsPerPage, "itemsPerPage", 100, `Number of items that the response returns per page.`)
	cmd.Flags().IntVar(&opts.pageNum, "pageNum", 1, `Number of the page that displays the current set of the total objects that the response returns.`)
	cmd.Flags().StringSliceVar(&opts.providers, "providers", nil, `Cloud providers whose regions to retrieve. When you specify multiple providers, the response can return only tiers and regions that support multi-cloud clusters.`)
	cmd.Flags().StringVar(&opts.tier, "tier", "", `Cluster tier for which to retrieve the regions.`)

	_ = cmd.MarkFlagRequired("groupId")
	return cmd
}

type listClustersOpts struct {
	cli.GlobalOpts
	client                            *admin.APIClient
	groupId                           string
	includeCount                      bool
	itemsPerPage                      int
	pageNum                           int
	includeDeletedWithRetainedBackups bool
}

func (opts *listClustersOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *listClustersOpts) Run(ctx context.Context, w io.Writer) error {
	params := &admin.ListClustersApiParams{
		GroupId:                           opts.groupId,
		IncludeCount:                      &opts.includeCount,
		ItemsPerPage:                      &opts.itemsPerPage,
		PageNum:                           &opts.pageNum,
		IncludeDeletedWithRetainedBackups: &opts.includeDeletedWithRetainedBackups,
	}
	resp, _, err := opts.client.ClustersApi.ListClustersWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return jsonwriter.Print(w, resp)
}

func listClustersBuilder() *cobra.Command {
	opts := listClustersOpts{}
	cmd := &cobra.Command{
		Use:   "listClusters",
		Short: "Return All Clusters in One Project",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)
	cmd.Flags().BoolVar(&opts.includeCount, "includeCount", true, `Flag that indicates whether the response returns the total number of items (**totalCount**) in the response.`)
	cmd.Flags().IntVar(&opts.itemsPerPage, "itemsPerPage", 100, `Number of items that the response returns per page.`)
	cmd.Flags().IntVar(&opts.pageNum, "pageNum", 1, `Number of the page that displays the current set of the total objects that the response returns.`)
	cmd.Flags().BoolVar(&opts.includeDeletedWithRetainedBackups, "includeDeletedWithRetainedBackups", false, `Flag that indicates whether to return Clusters with retain backups.`)

	_ = cmd.MarkFlagRequired("groupId")
	return cmd
}

type listClustersForAllProjectsOpts struct {
	cli.GlobalOpts
	client       *admin.APIClient
	includeCount bool
	itemsPerPage int
	pageNum      int
}

func (opts *listClustersForAllProjectsOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *listClustersForAllProjectsOpts) Run(ctx context.Context, w io.Writer) error {
	params := &admin.ListClustersForAllProjectsApiParams{
		IncludeCount: &opts.includeCount,
		ItemsPerPage: &opts.itemsPerPage,
		PageNum:      &opts.pageNum,
	}
	resp, _, err := opts.client.ClustersApi.ListClustersForAllProjectsWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return jsonwriter.Print(w, resp)
}

func listClustersForAllProjectsBuilder() *cobra.Command {
	opts := listClustersForAllProjectsOpts{}
	cmd := &cobra.Command{
		Use:   "listClustersForAllProjects",
		Short: "Return All Authorized Clusters in All Projects",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().BoolVar(&opts.includeCount, "includeCount", true, `Flag that indicates whether the response returns the total number of items (**totalCount**) in the response.`)
	cmd.Flags().IntVar(&opts.itemsPerPage, "itemsPerPage", 100, `Number of items that the response returns per page.`)
	cmd.Flags().IntVar(&opts.pageNum, "pageNum", 1, `Number of the page that displays the current set of the total objects that the response returns.`)

	return cmd
}

type loadSampleDatasetOpts struct {
	cli.GlobalOpts
	client  *admin.APIClient
	groupId string
	name    string
}

func (opts *loadSampleDatasetOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *loadSampleDatasetOpts) Run(ctx context.Context, w io.Writer) error {
	params := &admin.LoadSampleDatasetApiParams{
		GroupId: opts.groupId,
		Name:    opts.name,
	}
	resp, _, err := opts.client.ClustersApi.LoadSampleDatasetWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return jsonwriter.Print(w, resp)
}

func loadSampleDatasetBuilder() *cobra.Command {
	opts := loadSampleDatasetOpts{}
	cmd := &cobra.Command{
		Use:   "loadSampleDataset",
		Short: "Load Sample Dataset Request into Cluster",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)
	cmd.Flags().StringVar(&opts.name, "name", "", `Human-readable label that identifies the cluster into which you load the sample dataset.`)

	_ = cmd.MarkFlagRequired("groupId")
	_ = cmd.MarkFlagRequired("name")
	return cmd
}

type testFailoverOpts struct {
	cli.GlobalOpts
	client      *admin.APIClient
	groupId     string
	clusterName string
}

func (opts *testFailoverOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *testFailoverOpts) Run(ctx context.Context, _ io.Writer) error {
	params := &admin.TestFailoverApiParams{
		GroupId:     opts.groupId,
		ClusterName: opts.clusterName,
	}
	_, err := opts.client.ClustersApi.TestFailoverWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return nil
}

func testFailoverBuilder() *cobra.Command {
	opts := testFailoverOpts{}
	cmd := &cobra.Command{
		Use:   "testFailover",
		Short: "Test Failover for One Multi-Cloud Cluster",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)
	cmd.Flags().StringVar(&opts.clusterName, "clusterName", "", `Human-readable label that identifies the cluster.`)

	_ = cmd.MarkFlagRequired("groupId")
	_ = cmd.MarkFlagRequired("clusterName")
	return cmd
}

type updateClusterOpts struct {
	cli.GlobalOpts
	client      *admin.APIClient
	groupId     string
	clusterName string

	filename string
	fs       afero.Fs
}

func (opts *updateClusterOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *updateClusterOpts) readData() (*admin.AdvancedClusterDescription, error) {
	var out *admin.AdvancedClusterDescription

	var buf []byte
	var err error
	if opts.filename == "" {
		buf, err = io.ReadAll(os.Stdin)
	} else {
		if exists, errExists := afero.Exists(opts.fs, opts.filename); !exists || errExists != nil {
			return nil, fmt.Errorf("file not found: %s", opts.filename)
		}
		buf, err = afero.ReadFile(opts.fs, opts.filename)
	}
	if err != nil {
		return nil, err
	}
	if err = json.Unmarshal(buf, &out); err != nil {
		return nil, err
	}
	return out, nil
}

func (opts *updateClusterOpts) Run(ctx context.Context, w io.Writer) error {
	data, errData := opts.readData()
	if errData != nil {
		return errData
	}
	params := &admin.UpdateClusterApiParams{
		GroupId:     opts.groupId,
		ClusterName: opts.clusterName,

		AdvancedClusterDescription: data,
	}
	resp, _, err := opts.client.ClustersApi.UpdateClusterWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return jsonwriter.Print(w, resp)
}

func updateClusterBuilder() *cobra.Command {
	opts := updateClusterOpts{
		fs: afero.NewOsFs(),
	}
	cmd := &cobra.Command{
		Use:   "updateCluster",
		Short: "Modify One Multi-Cloud Cluster from One Project",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)
	cmd.Flags().StringVar(&opts.clusterName, "clusterName", "", `Human-readable label that identifies the cluster.`)

	cmd.Flags().StringVarP(&opts.filename, "file", "f", "", "Path to an optional JSON configuration file if not passed stdin is expected")

	_ = cmd.MarkFlagRequired("groupId")
	_ = cmd.MarkFlagRequired("clusterName")
	return cmd
}

type updateClusterAdvancedConfigurationOpts struct {
	cli.GlobalOpts
	client      *admin.APIClient
	groupId     string
	clusterName string

	filename string
	fs       afero.Fs
}

func (opts *updateClusterAdvancedConfigurationOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *updateClusterAdvancedConfigurationOpts) readData() (*admin.ClusterDescriptionProcessArgs, error) {
	var out *admin.ClusterDescriptionProcessArgs

	var buf []byte
	var err error
	if opts.filename == "" {
		buf, err = io.ReadAll(os.Stdin)
	} else {
		if exists, errExists := afero.Exists(opts.fs, opts.filename); !exists || errExists != nil {
			return nil, fmt.Errorf("file not found: %s", opts.filename)
		}
		buf, err = afero.ReadFile(opts.fs, opts.filename)
	}
	if err != nil {
		return nil, err
	}
	if err = json.Unmarshal(buf, &out); err != nil {
		return nil, err
	}
	return out, nil
}

func (opts *updateClusterAdvancedConfigurationOpts) Run(ctx context.Context, w io.Writer) error {
	data, errData := opts.readData()
	if errData != nil {
		return errData
	}
	params := &admin.UpdateClusterAdvancedConfigurationApiParams{
		GroupId:     opts.groupId,
		ClusterName: opts.clusterName,

		ClusterDescriptionProcessArgs: data,
	}
	resp, _, err := opts.client.ClustersApi.UpdateClusterAdvancedConfigurationWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return jsonwriter.Print(w, resp)
}

func updateClusterAdvancedConfigurationBuilder() *cobra.Command {
	opts := updateClusterAdvancedConfigurationOpts{
		fs: afero.NewOsFs(),
	}
	cmd := &cobra.Command{
		Use:   "updateClusterAdvancedConfiguration",
		Short: "Update Advanced Configuration Options for One Cluster",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)
	cmd.Flags().StringVar(&opts.clusterName, "clusterName", "", `Human-readable label that identifies the cluster.`)

	cmd.Flags().StringVarP(&opts.filename, "file", "f", "", "Path to an optional JSON configuration file if not passed stdin is expected")

	_ = cmd.MarkFlagRequired("groupId")
	_ = cmd.MarkFlagRequired("clusterName")
	return cmd
}

type upgradeSharedClusterOpts struct {
	cli.GlobalOpts
	client  *admin.APIClient
	groupId string

	filename string
	fs       afero.Fs
}

func (opts *upgradeSharedClusterOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *upgradeSharedClusterOpts) readData() (*admin.LegacyAtlasCluster, error) {
	var out *admin.LegacyAtlasCluster

	var buf []byte
	var err error
	if opts.filename == "" {
		buf, err = io.ReadAll(os.Stdin)
	} else {
		if exists, errExists := afero.Exists(opts.fs, opts.filename); !exists || errExists != nil {
			return nil, fmt.Errorf("file not found: %s", opts.filename)
		}
		buf, err = afero.ReadFile(opts.fs, opts.filename)
	}
	if err != nil {
		return nil, err
	}
	if err = json.Unmarshal(buf, &out); err != nil {
		return nil, err
	}
	return out, nil
}

func (opts *upgradeSharedClusterOpts) Run(ctx context.Context, w io.Writer) error {
	data, errData := opts.readData()
	if errData != nil {
		return errData
	}
	params := &admin.UpgradeSharedClusterApiParams{
		GroupId: opts.groupId,

		LegacyAtlasCluster: data,
	}
	resp, _, err := opts.client.ClustersApi.UpgradeSharedClusterWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return jsonwriter.Print(w, resp)
}

func upgradeSharedClusterBuilder() *cobra.Command {
	opts := upgradeSharedClusterOpts{
		fs: afero.NewOsFs(),
	}
	cmd := &cobra.Command{
		Use:   "upgradeSharedCluster",
		Short: "Upgrade One Shared-tier Cluster",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)

	cmd.Flags().StringVarP(&opts.filename, "file", "f", "", "Path to an optional JSON configuration file if not passed stdin is expected")

	_ = cmd.MarkFlagRequired("groupId")
	return cmd
}

type upgradeSharedClusterToServerlessOpts struct {
	cli.GlobalOpts
	client  *admin.APIClient
	groupId string

	filename string
	fs       afero.Fs
}

func (opts *upgradeSharedClusterToServerlessOpts) initClient() func() error {
	return func() error {
		var err error
		opts.client, err = newClientWithAuth()
		return err
	}
}

func (opts *upgradeSharedClusterToServerlessOpts) readData() (*admin.ServerlessInstanceDescription, error) {
	var out *admin.ServerlessInstanceDescription

	var buf []byte
	var err error
	if opts.filename == "" {
		buf, err = io.ReadAll(os.Stdin)
	} else {
		if exists, errExists := afero.Exists(opts.fs, opts.filename); !exists || errExists != nil {
			return nil, fmt.Errorf("file not found: %s", opts.filename)
		}
		buf, err = afero.ReadFile(opts.fs, opts.filename)
	}
	if err != nil {
		return nil, err
	}
	if err = json.Unmarshal(buf, &out); err != nil {
		return nil, err
	}
	return out, nil
}

func (opts *upgradeSharedClusterToServerlessOpts) Run(ctx context.Context, w io.Writer) error {
	data, errData := opts.readData()
	if errData != nil {
		return errData
	}
	params := &admin.UpgradeSharedClusterToServerlessApiParams{
		GroupId: opts.groupId,

		ServerlessInstanceDescription: data,
	}
	resp, _, err := opts.client.ClustersApi.UpgradeSharedClusterToServerlessWithParams(ctx, params).Execute()
	if err != nil {
		return err
	}

	return jsonwriter.Print(w, resp)
}

func upgradeSharedClusterToServerlessBuilder() *cobra.Command {
	opts := upgradeSharedClusterToServerlessOpts{
		fs: afero.NewOsFs(),
	}
	cmd := &cobra.Command{
		Use:   "upgradeSharedClusterToServerless",
		Short: "Upgrades One Shared-Tier Cluster to the Serverless Instance",
		PreRunE: func(cmd *cobra.Command, args []string) error {
			return opts.PreRunE(
				opts.initClient(),
			)
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			return opts.Run(cmd.Context(), cmd.OutOrStdout())
		},
	}
	cmd.Flags().StringVar(&opts.groupId, "groupId", "", `Unique 24-hexadecimal digit string that identifies your project. Use the [/groups](#tag/Projects/operation/listProjects) endpoint to retrieve all projects to which the authenticated user has access.

**NOTE**: Groups and projects are synonymous terms. Your group id is the same as your project id. For existing groups, your group/project id remains the same. The resource and corresponding endpoints use the term groups.`)

	cmd.Flags().StringVarP(&opts.filename, "file", "f", "", "Path to an optional JSON configuration file if not passed stdin is expected")

	_ = cmd.MarkFlagRequired("groupId")
	return cmd
}

func clustersBuilder() *cobra.Command {
	cmd := &cobra.Command{
		Use:   "clusters",
		Short: `Returns, adds, edits, and removes database deployments. Changes to cluster configurations can affect costs. This resource requires your Project ID.`,
	}
	cmd.AddCommand(
		createClusterBuilder(),
		deleteClusterBuilder(),
		getClusterBuilder(),
		getClusterAdvancedConfigurationBuilder(),
		getClusterStatusBuilder(),
		getSampleDatasetLoadStatusBuilder(),
		listCloudProviderRegionsBuilder(),
		listClustersBuilder(),
		listClustersForAllProjectsBuilder(),
		loadSampleDatasetBuilder(),
		testFailoverBuilder(),
		updateClusterBuilder(),
		updateClusterAdvancedConfigurationBuilder(),
		upgradeSharedClusterBuilder(),
		upgradeSharedClusterToServerlessBuilder(),
	)
	return cmd
}
